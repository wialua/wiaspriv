local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local MarketplaceService = game:GetService("MarketplaceService")
local Camera = Workspace.CurrentCamera
local UIS = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Options = Library.Options
local Toggles = Library.Toggles

Library.ShowToggleFrameInKeybinds = true
Library.ShowCustomCursor = true
Library.NotifySide = "Left"

local gameName = MarketplaceService:GetProductInfo(game.PlaceId).Name
local Window = Library:CreateWindow({
    Title = 'üî• ' .. gameName .. ' üî•',
    Center = true,
    AutoShow = true,
    Resizable = true,
    ShowCustomCursor = false,
    UnlockMouseWhileOpen = true,
    NotifySide = "Left",
    TabPadding = 8,
    MenuFadeTime = 0,
})

local Tabs = {
    Hitbox = Window:AddTab('Hitbox'),
    Aimbot = Window:AddTab('Aimbot'),
    Combat = Window:AddTab('‚öîÔ∏è Combat'),
    ['Silent Aim'] = Window:AddTab('Silent Aim'),
    Vehicles = Window:AddTab('üöó Ara√ß'),
    ['UI Ayarlarƒ±'] = Window:AddTab('UI Ayarlarƒ±'),
}

Library:SetWatermarkVisibility(false)

local HitboxSettings = {
    Enabled = false,
    Size = 8,
    Transparency = 0.7,
    BodyPart = "Head",
    Optimized = false,
}

local AimbotSettings = {
    Enabled = false,
    Mode = "Hold",
    Keybind = Enum.UserInputType.MouseButton2,
    FOV = 100,
    FOVVisible = true,
    FOVTransparency = 0.5,
    FOVColor = Color3.fromRGB(255, 255, 255),
    FOVThickness = 1,
    FOVNumSides = 64,
    MaxDistance = 1000,
    WallCheck = true,
    VisibleCheck = true,
    TeamCheck = true,
    TargetAimbot = false,
    TargetPlayer = nil,
    Triggerbot = false,
    TriggerbotWallCheck = true,
    TriggerbotVisibleCheck = true,
    TriggerbotTeamCheck = true,
    AimbotBodyPart = "Head",
}

local ActiveHitboxes = {}
local IgnoredPlayerName = "MAD_CITYAIMBOTLOL"
local Connections = {}
local HitboxTag = "HitboxExpanded"
local AimbotLocked = false
local AimbotTarget = nil
local FixedTargetPart = nil
local TriggerbotDebounce = false
local OptimizedConn = nil

local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Radius = AimbotSettings.FOV
FOVCircle.Thickness = AimbotSettings.FOVThickness
FOVCircle.Color = AimbotSettings.FOVColor
FOVCircle.Transparency = AimbotSettings.FOVTransparency
FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
FOVCircle.NumSides = AimbotSettings.FOVNumSides

local function ShouldExpandHitbox(player)
    if not player or player == LocalPlayer or player.Name == IgnoredPlayerName then
        return false
    end
    if not player.Team or not LocalPlayer.Team then
        return true
    end
    local playerTeam = player.Team.Name
    local localTeam = LocalPlayer.Team.Name
    if localTeam == "Prisoners" or localTeam == "Criminals" or localTeam == "Villains" then
        return playerTeam == "Police" or playerTeam == "Heroes"
    elseif localTeam == "Police" or localTeam == "Heroes" then
        return playerTeam == "Prisoners" or playerTeam == "Criminals" or playerTeam == "Villains"
    end
    return false
end

local function IsPlayerVisible(player, part)
    if not AimbotSettings.VisibleCheck or not part or not player or not player.Character then
        return true
    end
    local ignoreList = {LocalPlayer.Character, Camera}
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = ignoreList
    raycastParams.IgnoreWater = true
    raycastParams.RespectCanCollide = true
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin)
    local result = Workspace:Raycast(origin, direction, raycastParams)
    return result and result.Instance and result.Instance:IsDescendantOf(player.Character) and result.Instance.Transparency <= HitboxSettings.Transparency
end

local function IsPlayerBehindWall(player, part)
    if not AimbotSettings.WallCheck or not part or not player or not player.Character then
        return false
    end
    local ignoreList = {LocalPlayer.Character, Camera}
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = ignoreList
    raycastParams.IgnoreWater = true
    raycastParams.RespectCanCollide = true
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin)
    local result = Workspace:Raycast(origin, direction, raycastParams)
    return not (result and result.Instance and result.Instance:IsDescendantOf(player.Character))
end

local function IsWithinFOV(part)
    if not part or not AimbotSettings.FOVVisible then
        return true
    end
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then
        return false
    end
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local distance = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
    return distance <= AimbotSettings.FOV
end

local function IsInView(player)
    if not player or not player.Character then return false end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    local part = player.Character:FindFirstChild(HitboxSettings.BodyPart)
    if not humanoid or humanoid.Health <= 0 or not part then return false end
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then return false end
    local distance = (part.Position - Camera.CFrame.Position).Magnitude
    if distance > AimbotSettings.MaxDistance then return false end
    return true
end

local function GetClosestPlayer()
    if AimbotSettings.TargetAimbot and AimbotSettings.TargetPlayer then
        local player = Players:FindFirstChild(AimbotSettings.TargetPlayer)
        if player and player.Character and player.Character:IsDescendantOf(Workspace) then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local part = player.Character:FindFirstChild(AimbotSettings.AimbotBodyPart)
            if humanoid and humanoid.Health > 0 and part and part:IsA("BasePart") then
                if (not AimbotSettings.TeamCheck or ShouldExpandHitbox(player)) and
                   IsWithinFOV(part) and
                   not IsPlayerBehindWall(player, part) and
                   IsPlayerVisible(player, part) then
                    return player, part
                end
            end
        end
        return nil, nil
    end

    local closestPlayer, closestPart, closestDistance = nil, nil, math.huge
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName and player.Character and player.Character:IsDescendantOf(Workspace) then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local part = player.Character:FindFirstChild(AimbotSettings.AimbotBodyPart)
            if humanoid and humanoid.Health > 0 and part and part:IsA("BasePart") then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    local worldDist = (Camera.CFrame.Position - part.Position).Magnitude
                    if worldDist <= AimbotSettings.MaxDistance and screenDist < closestDistance and
                       (not AimbotSettings.TeamCheck or ShouldExpandHitbox(player)) and
                       IsWithinFOV(part) and
                       not IsPlayerBehindWall(player, part) and
                       IsPlayerVisible(player, part) then
                        closestPlayer, closestPart, closestDistance = player, part, screenDist
                    end
                end
            end
        end
    end
    return closestPlayer, closestPart
end

local function ApplyHitbox(player)
    if not HitboxSettings.Enabled or not ShouldExpandHitbox(player) or not player then
        return
    end
    local character = player.Character
    if not character or not character:IsDescendantOf(Workspace) then
        return
    end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        return
    end
    local part = character:FindFirstChild(HitboxSettings.BodyPart)
    if part and part:IsA("BasePart") and not ActiveHitboxes[player] then
        ActiveHitboxes[player] = {
            part = part,
            originalSize = part.Size,
            originalMassless = part.Massless,
            originalTransparency = part.Transparency,
            originalCanCollide = part.CanCollide
        }
        part.Size = Vector3.new(HitboxSettings.Size, HitboxSettings.Size, HitboxSettings.Size)
        part.Transparency = HitboxSettings.Transparency
        part.CanCollide = false
        part.Massless = true
        CollectionService:AddTag(part, HitboxTag)
    end
end

local function RestoreHitbox(player)
    if ActiveHitboxes[player] then
        local data = ActiveHitboxes[player]
        local part = data.part
        if part and part:IsA("BasePart") and part:IsDescendantOf(Workspace) then
            part.Size = data.originalSize
            part.Transparency = data.originalTransparency
            part.CanCollide = data.originalCanCollide
            part.Massless = data.originalMassless
            CollectionService:RemoveTag(part, HitboxTag)
        end
        ActiveHitboxes[player] = nil
    end
end

local function UpdateAllHitboxes()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName then
            RestoreHitbox(player)
            if HitboxSettings.Enabled and ShouldExpandHitbox(player) then
                ApplyHitbox(player)
            end
        end
    end
end

local function UpdateVisibleHitboxes()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName then
            if HitboxSettings.Enabled and ShouldExpandHitbox(player) and IsInView(player) then
                ApplyHitbox(player)
            else
                RestoreHitbox(player)
            end
        end
    end
end

local function ToggleOptimized(value)
    HitboxSettings.Optimized = value
    if value then
        if OptimizedConn then OptimizedConn:Disconnect() end
        OptimizedConn = RunService.Heartbeat:Connect(UpdateVisibleHitboxes)
        Library:Notify("Optimized Hitbox Modu Etkinle≈ütirildi", 3)
    else
        if OptimizedConn then
            OptimizedConn:Disconnect()
            OptimizedConn = nil
        end
        UpdateAllHitboxes()
        Library:Notify("Optimized Hitbox Modu Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±", 3)
    end
end

local function SetupPlayer(player)
    if not player or player == LocalPlayer or player.Name == IgnoredPlayerName then
        return
    end
    Connections[player] = Connections[player] or {}

    local charAddedConn = player.CharacterAdded:Connect(function(character)
        if not HitboxSettings.Enabled or not ShouldExpandHitbox(player) then
            return
        end
        task.spawn(function()
            local timeout = tick() + 2
            while not character:IsDescendantOf(Workspace) or not character:FindFirstChild(HitboxSettings.BodyPart) or not character:FindFirstChildOfClass("Humanoid") do
                if tick() > timeout then
                    return
                end
                task.wait()
            end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                if not HitboxSettings.Optimized or IsInView(player) then
                    ApplyHitbox(player)
                end
            end
        end)
    end)
    table.insert(Connections[player], charAddedConn)

    if player.Character then
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local healthConn = humanoid.HealthChanged:Connect(function(health)
                if health > 0 and HitboxSettings.Enabled and ShouldExpandHitbox(player) then
                    if not HitboxSettings.Optimized or IsInView(player) then
                        task.defer(ApplyHitbox, player)
                    end
                else
                    RestoreHitbox(player)
                end
            end)
            table.insert(Connections[player], healthConn)

            local diedConn = humanoid.Died:Connect(function()
                RestoreHitbox(player)
            end)
            table.insert(Connections[player], diedConn)

            local stateConn = humanoid.StateChanged:Connect(function(_, newState)
                if newState == Enum.HumanoidStateType.Running and HitboxSettings.Enabled and ShouldExpandHitbox(player) then
                    if not HitboxSettings.Optimized or IsInView(player) then
                        task.defer(ApplyHitbox, player)
                    end
                end
            end)
            table.insert(Connections[player], stateConn)
        end

        local ancestryConn = player.Character.AncestryChanged:Connect(function()
            if player.Character and player.Character:IsDescendantOf(Workspace) and HitboxSettings.Enabled and ShouldExpandHitbox(player) then
                if not HitboxSettings.Optimized or IsInView(player) then
                    task.defer(ApplyHitbox, player)
                end
            end
        end)
        table.insert(Connections[player], ancestryConn)
    end

    if player.Character and player.Character:IsDescendantOf(Workspace) then
        if not HitboxSettings.Optimized or IsInView(player) then
            ApplyHitbox(player)
        end
    end

    local watchdogConn = RunService.Heartbeat:Connect(function()
        if not HitboxSettings.Enabled or not ShouldExpandHitbox(player) or not player:IsDescendantOf(game) then
            return
        end
        local character = player.Character
        if character and character:IsDescendantOf(Workspace) and character:FindFirstChildOfClass("Humanoid") and not ActiveHitboxes[player] then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                if not HitboxSettings.Optimized or IsInView(player) then
                    task.defer(ApplyHitbox, player)
                end
            end
        end
    end)
    table.insert(Connections[player], watchdogConn)
end

Players.PlayerAdded:Connect(function(player)
    SetupPlayer(player)
end)

Players.PlayerRemoving:Connect(function(player)
    RestoreHitbox(player)
    if Connections[player] then
        for _, conn in ipairs(Connections[player]) do
            conn:Disconnect()
        end
        Connections[player] = nil
    end
    if AimbotSettings.TargetPlayer == player.Name then
        AimbotSettings.TargetPlayer = nil
        AimbotLocked = false
        AimbotTarget = nil
        FixedTargetPart = nil
    end
end)

Workspace.ChildAdded:Connect(function(child)
    if child:IsA("Model") and child:FindFirstChildOfClass("Humanoid") then
        local player = Players:GetPlayerFromCharacter(child)
        if player and player ~= LocalPlayer and player.Name ~= IgnoredPlayerName and HitboxSettings.Enabled and ShouldExpandHitbox(player) then
            if not HitboxSettings.Optimized or IsInView(player) then
                task.defer(ApplyHitbox, player)
            end
        end
    end
end)

Workspace.ChildRemoved:Connect(function(child)
    if child:IsA("Model") then
        local player = Players:GetPlayerFromCharacter(child)
        if player then
            RestoreHitbox(player)
        end
    end
end)

local teamConn = LocalPlayer:GetPropertyChangedSignal("Team"):Connect(function()
    task.defer(function()
        if HitboxSettings.Optimized then
            UpdateVisibleHitboxes()
        else
            UpdateAllHitboxes()
        end
        Library:Notify("Takƒ±m " .. (LocalPlayer.Team and LocalPlayer.Team.Name or "Yok") .. " olarak deƒüi≈ütirildi, hitbox'lar g√ºncellendi!", 3)
    end)
end)
table.insert(Connections, teamConn)

local aimbotConn = RunService.RenderStepped:Connect(function()
    if not AimbotSettings.Enabled then
        AimbotTarget = nil
        FixedTargetPart = nil
        FOVCircle.Visible = false
        return
    end

    FOVCircle.Radius = AimbotSettings.FOV
    FOVCircle.Transparency = AimbotSettings.FOVTransparency
    FOVCircle.Color = AimbotSettings.FOVColor
    FOVCircle.Thickness = AimbotSettings.FOVThickness
    FOVCircle.NumSides = AimbotSettings.FOVNumSides
    FOVCircle.Visible = AimbotSettings.FOVVisible
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    if not AimbotLocked then
        AimbotTarget = nil
        FixedTargetPart = nil
        return
    end

    if AimbotSettings.Mode == "Toggle" then
        if not FixedTargetPart or not FixedTargetPart.Parent or not FixedTargetPart:IsDescendantOf(Workspace) then
            local _, part = GetClosestPlayer()
            FixedTargetPart = part
        end
        AimbotTarget = FixedTargetPart
    else
        local _, part = GetClosestPlayer()
        AimbotTarget = part
    end

    if AimbotTarget then
        local player = Players:GetPlayerFromCharacter(AimbotTarget.Parent)
        local humanoid = AimbotTarget.Parent:FindFirstChildOfClass("Humanoid")
        if not player or not humanoid or humanoid.Health <= 0 or not IsWithinFOV(AimbotTarget) or IsPlayerBehindWall(player, AimbotTarget) or not IsPlayerVisible(player, AimbotTarget) then
            AimbotLocked = false
            FixedTargetPart = nil
            AimbotTarget = nil
            Library:Notify("Hedef ge√ßersiz, aimbot kilidi a√ßƒ±ldƒ±!", 3)
            return
        end
    else
        return
    end

    if AimbotTarget then
        local targetPos = AimbotTarget.Position
        local currentPos = Camera.CFrame.Position
        local newCFrame = CFrame.new(currentPos, targetPos)
        Camera.CFrame = newCFrame
    end

    if AimbotSettings.Triggerbot and not TriggerbotDebounce then
        TriggerbotDebounce = true
        local mousePos = UserInputService:GetMouseLocation()
        local ray = Camera:ViewportPointToRay(mousePos.X, mousePos.Y)
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
        local result = Workspace:Raycast(ray.Origin, ray.Direction * AimbotSettings.MaxDistance, raycastParams)
        if result and result.Instance and CollectionService:HasTag(result.Instance, HitboxTag) then
            local player = Players:GetPlayerFromCharacter(result.Instance.Parent)
            if player and (not AimbotSettings.TriggerbotTeamCheck or ShouldExpandHitbox(player)) and
               (not AimbotSettings.TriggerbotWallCheck or not IsPlayerBehindWall(player, result.Instance)) and
               (not AimbotSettings.TriggerbotVisibleCheck or IsPlayerVisible(player, result.Instance)) then
                if mouse1press and mouse1release then
                    mouse1press()
                    task.wait(0)
                    mouse1release()
                else
                    Library:Notify("Triggerbot bu executor'da desteklenmiyor!", 3)
                end
            end
        end
        task.delay(0.01, function() TriggerbotDebounce = false end)
    end
end)
table.insert(Connections, aimbotConn)

local inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or not AimbotSettings.Enabled then
        return
    end
    local isKeybind = (input.UserInputType == AimbotSettings.Keybind) or (input.KeyCode == AimbotSettings.Keybind)
    if isKeybind then
        if AimbotSettings.Mode == "Hold" then
            AimbotLocked = true
        elseif AimbotSettings.Mode == "Toggle" then
            AimbotLocked = not AimbotLocked
            if AimbotLocked then
                local _, part = GetClosestPlayer()
                FixedTargetPart = part
            else
                FixedTargetPart = nil
            end
            Library:Notify("Aimbot " .. (AimbotLocked and "Kilitlendi" or "Kilidi A√ßƒ±ldƒ±"), 3)
        end
    end
end)
table.insert(Connections, inputConn)

local inputEndConn = UserInputService.InputEnded:Connect(function(input)
    if AimbotSettings.Mode == "Hold" then
        local isKeybind = (input.UserInputType == AimbotSettings.Keybind) or (input.KeyCode == AimbotSettings.Keybind)
        if isKeybind then
            AimbotLocked = false
            AimbotTarget = nil
        end
    end
end)
table.insert(Connections, inputEndConn)

for _, player in ipairs(Players:GetPlayers()) do
    SetupPlayer(player)
end

local LeftGroupBox = Tabs.Hitbox:AddLeftGroupbox('Hitbox Kontrolleri')

LeftGroupBox:AddToggle('HitboxToggle', {
    Text = 'Hitbox Geni≈ületiciyi Etkinle≈ütir',
    Default = false,
    Tooltip = 'Hitbox geni≈ületmeyi a√ß/kapat',
    Risky = true,
    Callback = function(Value)
        HitboxSettings.Enabled = Value
        if Value then
            if HitboxSettings.Optimized then
                ToggleOptimized(true)
            else
                UpdateAllHitboxes()
            end
        else
            for _, p in ipairs(Players:GetPlayers()) do
                RestoreHitbox(p)
            end
        end
        Library:Notify("Hitbox Geni≈ületici " .. (Value and "Etkinle≈ütirildi" or "Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±"), 3)
    end
})

LeftGroupBox:AddToggle('OptimizedHitboxToggle', {
    Text = 'Optimized Hitbox Modu',
    Default = false,
    Tooltip = 'Yalnƒ±zca kameradaki oyunculara hitbox uygula (FPS optimizasyonu)',
    Callback = function(Value)
        ToggleOptimized(Value)
    end
})

LeftGroupBox:AddDropdown('BodyPartDropdown', {
    Values = {'Head', 'HumanoidRootPart'},
    Default = 'Head',
    Text = 'V√ºcut Par√ßasƒ± Se√ß',
    Tooltip = 'Geni≈ületilecek v√ºcut par√ßasƒ±nƒ± se√ß',
    Callback = function(Value)
        for player, _ in pairs(ActiveHitboxes) do
            RestoreHitbox(player)
        end
        HitboxSettings.BodyPart = Value
        if HitboxSettings.Optimized then
            UpdateVisibleHitboxes()
        else
            UpdateAllHitboxes()
        end
        Library:Notify("V√ºcut Par√ßasƒ± " .. Value .. " olarak ayarlandƒ±", 3)
    end
})

LeftGroupBox:AddSlider('HitboxSizeSlider', {
    Text = 'Hitbox Boyutu',
    Default = 8,
    Min = 5,
    Max = 10,
    Rounding = 1,
    Tooltip = 'Hitbox boyutunu ayarla',
    Callback = function(Value)
        HitboxSettings.Size = Value
        if HitboxSettings.Optimized then
            UpdateVisibleHitboxes()
        else
            UpdateAllHitboxes()
        end
        Library:Notify("Hitbox Boyutu " .. Value .. " olarak ayarlandƒ±", 3)
    end
})

LeftGroupBox:AddSlider('HitboxTransparencySlider', {
    Text = 'Hitbox ≈ûeffaflƒ±ƒüƒ±',
    Default = 0.7,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Tooltip = 'Hitbox ≈üeffaflƒ±ƒüƒ±nƒ± ayarla (0 = tamamen g√∂r√ºnmez)',
    Callback = function(Value)
        HitboxSettings.Transparency = Value
        if HitboxSettings.Optimized then
            UpdateVisibleHitboxes()
        else
            UpdateAllHitboxes()
        end
        Library:Notify("Hitbox ≈ûeffaflƒ±ƒüƒ± " .. Value .. " olarak ayarlandƒ±", 3)
    end
})

local AimbotGroupBox = Tabs.Aimbot:AddLeftGroupbox('Aimbot Kontrolleri')

AimbotGroupBox:AddToggle('AimbotToggle', {
    Text = 'Aimbot\'u Etkinle≈ütir',
    Default = false,
    Tooltip = 'Aimbot fonksiyonunu a√ß/kapat',
    Risky = true,
    Callback = function(Value)
        AimbotSettings.Enabled = Value
        AimbotLocked = false
        AimbotTarget = nil
        FixedTargetPart = nil
        Library:Notify("Aimbot " .. (Value and "Etkinle≈ütirildi" or "Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±"), 3)
    end
})

AimbotGroupBox:AddDropdown('AimbotMode', {
    Values = {'Hold', 'Toggle'},
    Default = 'Hold',
    Text = 'Aimbot Modu',
    Tooltip = 'Aimbot modu se√ß (Hold veya Toggle)',
    Callback = function(Value)
        AimbotSettings.Mode = Value
        AimbotLocked = false
        AimbotTarget = nil
        FixedTargetPart = nil
        Library:Notify("Aimbot Modu " .. Value .. " olarak ayarlandƒ±", 3)
    end
})

AimbotGroupBox:AddLabel('Aimbot Tu≈üu'):AddKeyPicker('AimbotKeybind', {
    Default = 'MB2',
    Mode = 'Toggle',
    Text = 'Aimbot Tu≈üu',
    Tooltip = 'Hedeflere kilitlenmek i√ßin tu≈ü ata',
    Callback = function(Value)
        print('[cb] Aimbot Tu≈üu tƒ±klandƒ±!', Value)
    end,
    ChangedCallback = function(New)
        AimbotSettings.Keybind = New
        Library:Notify("Aimbot Tu≈üu " .. tostring(New) .. " olarak deƒüi≈ütirildi", 3)
    end
})

AimbotGroupBox:AddToggle('FOVToggle', {
    Text = 'FOV √áemberini G√∂ster',
    Default = true,
    Tooltip = 'FOV √ßemberi g√∂r√ºn√ºrl√ºƒü√ºn√º a√ß/kapat',
    Callback = function(Value)
        AimbotSettings.FOVVisible = Value
        Library:Notify("FOV √áemberi " .. (Value and "Etkinle≈ütirildi" or "Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±"), 3)
    end
})

AimbotGroupBox:AddSlider('FOVSlider', {
    Text = 'FOV Boyutu',
    Default = 100,
    Min = 10,
    Max = 500,
    Rounding = 0,
    Tooltip = 'FOV √ßemberi boyutunu ayarla',
    Callback = function(Value)
        AimbotSettings.FOV = Value
        Library:Notify("FOV Boyutu " .. Value .. " olarak ayarlandƒ±", 3)
    end
})

AimbotGroupBox:AddSlider('FOVTransparencySlider', {
    Text = 'FOV ≈ûeffaflƒ±ƒüƒ±',
    Default = 0.5,
    Min = 0.1,
    Max = 1,
    Rounding = 2,
    Tooltip = 'FOV √ßemberi ≈üeffaflƒ±ƒüƒ±nƒ± ayarla',
    Callback = function(Value)
        AimbotSettings.FOVTransparency = Value
        Library:Notify("FOV ≈ûeffaflƒ±ƒüƒ± " .. Value .. " olarak ayarlandƒ±", 3)
    end
})

AimbotGroupBox:AddLabel('FOV Rengi'):AddColorPicker('FOVColorPicker', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'FOV Rengi',
    Callback = function(Value)
        AimbotSettings.FOVColor = Value
        Library:Notify("FOV Rengi deƒüi≈ütirildi", 3)
    end
})

AimbotGroupBox:AddSlider('FOVThicknessSlider', {
    Text = 'FOV Kalƒ±nlƒ±ƒüƒ±',
    Default = 1,
    Min = 1,
    Max = 5,
    Rounding = 0,
    Tooltip = 'FOV √ßemberi kalƒ±nlƒ±ƒüƒ±nƒ± ayarla',
    Callback = function(Value)
        AimbotSettings.FOVThickness = Value
        Library:Notify("FOV Kalƒ±nlƒ±ƒüƒ± " .. Value .. " olarak ayarlandƒ±", 3)
    end
})

AimbotGroupBox:AddSlider('FOVNumSidesSlider', {
    Text = 'FOV Kenar Sayƒ±sƒ±',
    Default = 64,
    Min = 12,
    Max = 128,
    Rounding = 0,
    Tooltip = 'FOV √ßemberi yumu≈üaklƒ±ƒüƒ±nƒ± ayarla (daha y√ºksek = daha yumu≈üak)',
    Callback = function(Value)
        AimbotSettings.FOVNumSides = Value
        Library:Notify("FOV Kenar Sayƒ±sƒ± " .. Value .. " olarak ayarlandƒ±", 3)
    end
})

AimbotGroupBox:AddSlider('MaxDistanceSlider', {
    Text = 'Maksimum Mesafe',
    Default = 1000,
    Min = 100,
    Max = 5000,
    Rounding = 0,
    Tooltip = 'Aimbot maksimum mesafesini ayarla',
    Callback = function(Value)
        AimbotSettings.MaxDistance = Value
        Library:Notify("Maksimum Mesafe " .. Value .. " olarak ayarlandƒ±", 3)
    end
})

AimbotGroupBox:AddToggle('WallCheckToggle', {
    Text = 'Duvar Kontrol√º',
    Default = true,
    Tooltip = 'Aimbot i√ßin duvar kontrol√ºn√º a√ß/kapat',
    Callback = function(Value)
        AimbotSettings.WallCheck = Value
        Library:Notify("Duvar Kontrol√º " .. (Value and "Etkinle≈ütirildi" or "Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±"), 3)
    end
})

AimbotGroupBox:AddToggle('VisibleCheckToggle', {
    Text = 'G√∂r√ºn√ºrl√ºk Kontrol√º',
    Default = true,
    Tooltip = 'Aimbot i√ßin g√∂r√ºn√ºrl√ºk kontrol√ºn√º a√ß/kapat',
    Callback = function(Value)
        AimbotSettings.VisibleCheck = Value
        Library:Notify("G√∂r√ºn√ºrl√ºk Kontrol√º " .. (Value and "Etkinle≈ütirildi" or "Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TeamCheckToggle', {
    Text = 'Takƒ±m Kontrol√º',
    Default = true,
    Tooltip = 'Aimbot i√ßin takƒ±m kontrol√ºn√º a√ß/kapat',
    Callback = function(Value)
        AimbotSettings.TeamCheck = Value
        Library:Notify("Takƒ±m Kontrol√º " .. (Value and "Etkinle≈ütirildi" or "Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TargetAimbotToggle', {
    Text = 'Hedef Aimbot',
    Default = false,
    Tooltip = 'Belirli bir oyuncuyu hedeflemeyi a√ß/kapat',
    Callback = function(Value)
        AimbotSettings.TargetAimbot = Value
        if not Value then
            AimbotSettings.TargetPlayer = nil
        end
        Library:Notify("Hedef Aimbot " .. (Value and "Etkinle≈ütirildi" or "Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±"), 3)
    end
})

AimbotGroupBox:AddDropdown('TargetPlayerDropdown', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Hedef Oyuncu',
    Tooltip = 'Hedeflenecek belirli oyuncuyu se√ß',
    Callback = function(Value)
        AimbotSettings.TargetPlayer = Value
        Library:Notify("Hedef Oyuncu " .. Value .. " olarak ayarlandƒ±", 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotToggle', {
    Text = 'Triggerbot\'u Etkinle≈ütir',
    Default = false,
    Tooltip = 'Triggerbot\'u a√ß/kapat',
    Risky = true,
    Callback = function(Value)
        AimbotSettings.Triggerbot = Value
        Library:Notify("Triggerbot " .. (Value and "Etkinle≈ütirildi" or "Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotWallCheckToggle', {
    Text = 'Triggerbot Duvar Kontrol√º',
    Default = true,
    Tooltip = 'Triggerbot i√ßin duvar kontrol√ºn√º a√ß/kapat',
    Callback = function(Value)
        AimbotSettings.TriggerbotWallCheck = Value
        Library:Notify("Triggerbot Duvar Kontrol√º " .. (Value and "Etkinle≈ütirildi" or "Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotVisibleCheckToggle', {
    Text = 'Triggerbot G√∂r√ºn√ºrl√ºk Kontrol√º',
    Default = true,
    Tooltip = 'Triggerbot i√ßin g√∂r√ºn√ºrl√ºk kontrol√ºn√º a√ß/kapat',
    Callback = function(Value)
        AimbotSettings.TriggerbotVisibleCheck = Value
        Library:Notify("Triggerbot G√∂r√ºn√ºrl√ºk Kontrol√º " .. (Value and "Etkinle≈ütirildi" or "Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotTeamCheckToggle', {
    Text = 'Triggerbot Takƒ±m Kontrol√º',
    Default = true,
    Tooltip = 'Triggerbot i√ßin takƒ±m kontrol√ºn√º a√ß/kapat',
    Callback = function(Value)
        AimbotSettings.TriggerbotTeamCheck = Value
        Library:Notify("Triggerbot Takƒ±m Kontrol√º " .. (Value and "Etkinle≈ütirildi" or "Devre Dƒ±≈üƒ± Bƒ±rakƒ±ldƒ±"), 3)
    end
})

AimbotGroupBox:AddDropdown('AimbotBodyPartDropdown', {
    Values = {'Head', 'HumanoidRootPart', 'Torso', 'UpperTorso', 'LowerTorso'},
    Default = 'Head',
    Text = 'Aimbot Hedef V√ºcut Par√ßasƒ±',
    Tooltip = 'Aimbot\'un kitleneceƒüi v√ºcut par√ßasƒ±nƒ± se√ß',
    Callback = function(Value)
        AimbotSettings.AimbotBodyPart = Value
        Library:Notify("Aimbot Hedef V√ºcut Par√ßasƒ± " .. Value .. " olarak ayarlandƒ±", 3)
    end
})

local MenuGroup = Tabs['UI Ayarlarƒ±']:AddLeftGroupbox('Men√º')
MenuGroup:AddToggle("KeybindMenuOpen", {
    Default = Library.KeybindFrame.Visible,
    Text = "Tu≈ü Men√ºs√ºn√º A√ß",
    Callback = function(value) Library.KeybindFrame.Visible = value end
})
MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "√ñzel ƒ∞mle√ß",
    Default = true,
    Callback = function(Value) Library.ShowCustomCursor = Value end
})
MenuGroup:AddDivider()
MenuGroup:AddLabel("Men√º Tu≈üu"):AddKeyPicker("MenuKeybind", {
    Default = "RightShift",
    NoUI = true,
    Text = "Men√º tu≈üu"
})
MenuGroup:AddButton("Kapat", function() Library:Unload() end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')
SaveManager:BuildConfigSection(Tabs['UI Ayarlarƒ±'])
ThemeManager:ApplyToTab(Tabs['UI Ayarlarƒ±'])
SaveManager:LoadAutoloadConfig()

Library:OnUnload(function()
    for player, _ in pairs(ActiveHitboxes) do
        RestoreHitbox(player)
    end
    if OptimizedConn then OptimizedConn:Disconnect() end
    for _, conns in pairs(Connections) do
        if typeof(conns) == "table" then
            for _, conn in ipairs(conns) do
                conn:Disconnect()
            end
        else
            conns:Disconnect()
        end
    end
    Connections = {}
    FOVCircle:Remove()
    CollectionService:RemoveTag(Workspace, HitboxTag)
    print('Kapatƒ±ldƒ±!')
    Library.Unloaded = true
end)

Library:Notify("Ultimate Hitbox Geni≈ületici & Aimbot Ba≈ülatƒ±ldƒ±! T√ºm sorunlar d√ºzeltildi.", 3)

local uiConn = RunService:BindToRenderStep("UIUpdate", Enum.RenderPriority.Camera.Value + 1, function()
    if Library.Unloaded then
        RunService:UnbindFromRenderStep("UIUpdate")
    end
end)
table.insert(Connections, uiConn)

local Event = game:GetService("ReplicatedStorage"):WaitForChild("Event")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- Sol ve saƒü kutular
local VehicleSpawnBox = Tabs.Vehicles:AddLeftGroupbox('üöó Ara√ß Spawn')
local VehicleModBox   = Tabs.Vehicles:AddRightGroupbox('üõ†Ô∏è Ara√ß Modifiye')

-- Se√ßilen ara√ß, SaveManager ile y√ºkle/kaydet
local selectedVehicle = SaveManager:Load("Ara√ßListesi") or "Nero"
VehicleSpawnBox:AddDropdown('Ara√ßListesi', {
    Text    = 'Ara√ß Se√ß',
    Values  = { "Nero", "Rhino", "Nighthawk", "Light Bike", "Thunderbird", "Warhawk", "Buzzard", "Fury" },
    Default = table.find({"Nero","Rhino","Nighthawk","Light Bike","Thunderbird","Warhawk","Buzzard","Fury"}, selectedVehicle) or 1,
    Callback = function(v)
        selectedVehicle = v
        SaveManager:Save("Ara√ßListesi", v)
    end
})

VehicleSpawnBox:AddButton({
    Text = 'üöò Spawnla',
    Func = function()
        if selectedVehicle ~= "" then
            Event:FireServer("SpawnVehicle", selectedVehicle)
        end
    end
})

-- Ortak fonksiyon: her √ßaƒürƒ±ldƒ±ƒüƒ±nda g√ºncel gc tablolarƒ±nda √ßalƒ±≈üƒ±r
local function applyProperties(props)
    for _, obj in pairs(getgc(true)) do
        if type(obj) == "table" then
            for k, v in pairs(props) do
                if rawget(obj, k) ~= nil then
                    obj[k] = v
                end
            end
        end
    end
end

-- Varsayƒ±lan property setleri
local defaults = {
    carProps   = { Sway=60, Torque=10, BrakeForce=4, MaxSpeed=400, TurnSpeed=1.7, DriftVelLerp=0.45, DriftRotLerp=0.12 },
    heliProps  = { Acceleration=3, Deceleration=1, SpeedDecay=0.95, BrakeForce=15, DescentSpeed=2, MaxVerticalTiltAngle=25, VerticalTiltSpeed=0.3, HorizontalRotationSpeed=14, ResponseSpeed=1, MaxSideTilt=20, MinHeightAboveGround=5, MissileCooldown=0, MissileLock=0 },
    ufoProps   = { Acceleration=10, Deceleration=1, MaxSpeed=340, SpeedDecay=0.95, BrakeForce=15, MaxAltitude=640, AscentSpeed=2, DescentSpeed=3, MaxVerticalTiltAngle=25, VerticalTiltSpeed=0.3, HorizontalRotationSpeed=14, ResponseSpeed=1, HideCharacter=true, MaxSideTilt=20, MinHeightAboveGround=5, CameraOffset=40 },
    boatProps  = { Height=1, TurnSpeed=7.5, Torque=5, MaxSpeed=160, BrakeForce=1, SpeedDecay=0.5 },
    planeProps = { Bombs=true, Acceleration=0.6, DampeningAcceleration=0.8, MaxVerticalTilt=10, VerticalTiltUpSpeed=1, VerticalTiltDownSpeed=1, VerticalTiltDampening=0.95, VerticalSpeedLimit=30, HorizontalTiltSpeed=7.2, MaxSideTilt=25, SideTiltSpeed=1.5, SideTiltDampening=0.95, MissileTargetRange=540, MissileCooldown=0, MissileLock=0 },
    ArchProps   = { Acceleration=10,MaxSpeed=270, Deceleration=1, SpeedDecay=0.95, BrakeForce=15, MaxAltitude=640, AscentSpeed=3, DescentSpeed=3, MaxVerticalTiltAngle=25, VerticalTiltSpeed=0.3, HorizontalRotationSpeed=10, ResponseSpeed=1, HideCharacter=true, MaxSideTilt=20, MinHeightAboveGround=5, CameraOffset=40 },
}

-- Modifiye butonlarƒ±
VehicleModBox:AddButton({
    Text = 'üöÄ Araba Modifiye Et',
    Func = function()
        -- √ñnce genel ara√ß ayarlarƒ±nƒ± uygula
        applyProperties(defaults.carProps)

        -- Ara√ß modelini bekle
        local objectSelection = workspace:WaitForChild("ObjectSelection", 5)
        if not objectSelection then return end

        local vehicleName = LocalPlayer.Name .. "'s Vehicle"
        local playerVehicle = objectSelection:WaitForChild(vehicleName, 5)
        if not playerVehicle then return end

        -- CarChassis'i bekle
        local carChassis = playerVehicle:WaitForChild("CarChassis", 5)
        if not carChassis then return end

        -- Boost nesnesini bul veya olu≈ütur
        local boost = carChassis:FindFirstChild("Boost")
        if not boost then
            boost = Instance.new("NumberValue")
            boost.Name = "Boost"
            boost.Parent = carChassis
        end

        -- Deƒüeri ayarla
        boost.Value = 20
    end
})

VehicleModBox:AddButton({ Text='üöÅ Helikopter Modifiye Et', Func=function()
    applyProperties(defaults.heliProps)
end})

VehicleModBox:AddButton({ Text='üõ∏ UFO Modifiye Et', Func=function()
    applyProperties(defaults.ufoProps)
end})

VehicleModBox:AddButton({ Text='üõ∏ ArchAngel Modifiye Et', Func=function()
    applyProperties(defaults.ArchProps)
end})

VehicleModBox:AddButton({ Text='üö§ Tekne Modifiye Et', Func=function()
    applyProperties(defaults.boatProps)
end})

VehicleModBox:AddButton({ Text='‚úàÔ∏è U√ßak Modifiye Et', Func=function()
    applyProperties(defaults.planeProps)
end})

-- Reset d√ºƒümesi
VehicleModBox:AddButton({ Text='üîÑ Modlarƒ± Sƒ±fƒ±rla', Func=function()
    applyProperties(defaults.carProps)
end})

local bombActive = false
local bombInputConn = nil

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local Remote = ReplicatedStorage:WaitForChild("Event")

VehicleSpawnBox:AddToggle('BombToggle', {
    Text = 'üí£ Sonsuz Bombalama (G)',
    Default = false,
    Tooltip = 'G tu≈üuna her bastƒ±ƒüƒ±nda bir bomba bƒ±rakƒ±r. FPS dostu, ultra stabil.',
    Callback = function(state)
        bombActive = state

        if bombActive then
            -- Mevcut baƒülantƒ± varsa kopar (√ßift baƒülanmayƒ± engelle)
            if bombInputConn then
                bombInputConn:Disconnect()
                bombInputConn = nil
            end

            bombInputConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed then return end
                if input.KeyCode == Enum.KeyCode.G then
                    task.defer(function()
                        pcall(function()
                            Remote:FireServer("DropBomb")
                        end)
                    end)
                end
            end)

            Library:Notify("üí£ G tu≈üuyla bombalama aktif!", 2)
        else
            -- Kapatƒ±ldƒ±ƒüƒ±nda baƒülantƒ±yƒ± yok et
            if bombInputConn then
                bombInputConn:Disconnect()
                bombInputConn = nil
            end
            Library:Notify("üõë Bombalama kapatƒ±ldƒ±", 2)
        end
    end
})

local VehicleSpawnBox = Tabs.Vehicles:AddLeftGroupbox('üöó Ara√ß Spawn')
local VehicleModBox = Tabs.Vehicles:AddRightGroupbox('üõ†Ô∏è Ara√ß Modifiye')

VehicleSpawnBox:AddToggle('GlobalUnlockToggle', {
    Text = 'T√ºm Oyuncularƒ±n Ara√ß Kilidini Kapalƒ± Yap',
    Default = false,
    Tooltip = 'A√ßƒ±kken T√ºm Kilitler A√ßƒ±lƒ±r',
    Callback = function(value)
        if value then
            Connections.GlobalUnlockLoop = RunService.Stepped:Connect(function()
                pcall(function()
                    local objectSelection = Workspace:FindFirstChild("ObjectSelection")
                    if objectSelection then
                        for _, pl in ipairs(Players:GetPlayers()) do
                            local veh = objectSelection:FindFirstChild(pl.Name .. "'s Vehicle")
                            if veh then
                                local lock = veh:FindFirstChild("VehicleLock")
                                if lock and lock:IsA("StringValue") then
                                    lock.Value = "OFF"
                                end
                            end
                        end
                    end
                end)
            end)
            Library:Notify("T√ºm Ara√ß Kilidi OFF Aktif (Global Stabil Loop)", 2)
        else
            if Connections.GlobalUnlockLoop then
                Connections.GlobalUnlockLoop:Disconnect()
                Connections.GlobalUnlockLoop = nil
            end
            Library:Notify("T√ºm Ara√ß Kilidi OFF Kapandƒ± (Global)", 2)
        end
    end
})

local selectedTargets = {}
VehicleSpawnBox:AddDropdown('TargetPlayersDropdown', {
    Text = 'Hedef Oyuncular (Multi-Select)',
    Values = {},
    Default = 1,
    Multi = true,
    Searchable = true,
    Callback = function(value)
        selectedTargets = {}
        for key, val in pairs(value) do
            if val then
                selectedTargets[key] = true
            end
        end
        Library:Notify("Hedef Oyuncular G√ºncellendi (" .. #selectedTargets .. " se√ßili)", 2)
    end
})

local function updatePlayerList()
    local values = {}
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer then
            table.insert(values, pl.Name)
        end
    end
    Options.TargetPlayersDropdown:SetValues(values)
end
updatePlayerList()
Players.PlayerAdded:Connect(updatePlayerList)
Players.PlayerRemoving:Connect(updatePlayerList)

VehicleSpawnBox:AddToggle('TargetUnlockToggle', {
    Text = 'üéØ Se√ßili Oyuncularƒ±n Ara√ß Kilidini OFF Yap',
    Default = false,
    Tooltip = 'Toggle a√ßƒ±kken se√ßili hedeflerin VehicleLock\'larƒ± s√ºrekli OFF kalƒ±r (ƒ∞leri Seviye Stabil)',
    Callback = function(value)
        if value then
            Connections.TargetUnlockLoop = RunService.Stepped:Connect(function()
                pcall(function()
                    local objectSelection = Workspace:FindFirstChild("ObjectSelection")
                    if objectSelection then
                        for targetName in pairs(selectedTargets) do
                            local veh = objectSelection:FindFirstChild(targetName .. "'s Vehicle")
                            if veh then
                                local lock = veh:FindFirstChild("VehicleLock")
                                if lock and lock:IsA("StringValue") then
                                    lock.Value = "OFF"
                                end
                            end
                        end
                    end
                end)
            end)
            Library:Notify("Hedef Ara√ß Kilidi OFF Aktif (" .. #selectedTargets .. " hedef)", 2)
        else
            if Connections.TargetUnlockLoop then
                Connections.TargetUnlockLoop:Disconnect()
                Connections.TargetUnlockLoop = nil
            end
            Library:Notify("Hedef Ara√ß Kilidi OFF Kapandƒ±", 2)
        end
    end
})

Library:OnUnload(function()
    if Connections.GlobalUnlockLoop then Connections.GlobalUnlockLoop:Disconnect() end
    if Connections.TargetUnlockLoop then Connections.TargetUnlockLoop:Disconnect() end
end)

VehicleModBox:AddToggle('HoverModeToggle', {
    Text = 'Hover Mode (Local Vehicle)',
    Default = false,
    Tooltip = 'LocalPlayer\'ƒ±n aracƒ±nƒ±n HoverMode\'unu a√ß/kapat (Ultra Stabil & Async)',
    Callback = function(value)
        task.spawn(function()
            local success, err = pcall(function()
                local objectSelection = Workspace:FindFirstChild("ObjectSelection")
                if not objectSelection then
                    Library:Notify("ObjectSelection bulunamadƒ± (Hover Mode)", 2)
                    return
                end
                local vehicleName = LocalPlayer.Name .. "'s Vehicle"
                local vehicle = objectSelection:FindFirstChild(vehicleName)
                if not vehicle or not vehicle.Parent then
                    Library:Notify("Ara√ß bulunamadƒ± (Hover Mode: " .. vehicleName .. ")", 2)
                    return
                end
                local chassis = vehicle:FindFirstChild("CarChassis")
                if not chassis or not chassis.Parent then
                    Library:Notify("CarChassis bulunamadƒ± (Hover Mode)", 2)
                    return
                end
                local hoverMode = chassis:FindFirstChild("HoverMode")
                if not hoverMode or not hoverMode:IsA("BoolValue") then
                    Library:Notify("HoverMode BoolValue bulunamadƒ±", 2)
                    return
                end
                hoverMode.Value = value
                Library:Notify("Hover Mode " .. (value and "A√ßƒ±ldƒ±" or "Kapandƒ±") .. " (" .. LocalPlayer.Name .. "'s Vehicle)", 1)
            end)
            if not success then
                Library:Notify("Hover Mode Hatasƒ±: " .. tostring(err), 3)
            end
        end)
    end
})

VehicleModBox:AddSlider('SuspensionSlider', {
    Text = 'Suspension (Local Vehicle)',
    Default = 0,
    Min = 0,
    Max = 1000,
    Rounding = 0,
    Tooltip = 'LocalPlayer\'ƒ±n aracƒ±nƒ±n Suspension deƒüerini ayarla (0-1000, Ultra Stabil)',
    Callback = function(value)
        task.spawn(function()
            local success, err = pcall(function()
                local objectSelection = Workspace:FindFirstChild("ObjectSelection")
                if not objectSelection then
                    Library:Notify("ObjectSelection bulunamadƒ± (Suspension)", 2)
                    return
                end
                local vehicleName = LocalPlayer.Name .. "'s Vehicle"
                local vehicle = objectSelection:FindFirstChild(vehicleName)
                if not vehicle or not vehicle.Parent then
                    Library:Notify("Ara√ß bulunamadƒ± (Suspension: " .. vehicleName .. ")", 2)
                    return
                end
                local chassis = vehicle:FindFirstChild("CarChassis")
                if not chassis or not chassis.Parent then
                    Library:Notify("CarChassis bulunamadƒ± (Suspension)", 2)
                    return
                end
                local suspension = chassis:FindFirstChild("Suspension")
                if not suspension or not suspension:IsA("NumberValue") then
                    Library:Notify("Suspension NumberValue bulunamadƒ±", 2)
                    return
                end
                suspension.Value = value
                Library:Notify("Suspension: " .. value .. " (" .. LocalPlayer.Name .. "'s Vehicle)", 1)
            end)
            if not success then
                Library:Notify("Suspension Hatasƒ±: " .. tostring(err), 3)
            end
        end)
    end
})

VehicleModBox:AddButton({
    Text = 'Suspension Sƒ±fƒ±rla',
    Func = function()
        Options.SuspensionSlider:SetValue(0)
        task.spawn(function()
            local success, err = pcall(function()
                local objectSelection = Workspace:FindFirstChild("ObjectSelection")
                if not objectSelection then
                    Library:Notify("ObjectSelection bulunamadƒ± (Sƒ±fƒ±rlama)", 2)
                    return
                end
                local vehicleName = LocalPlayer.Name .. "'s Vehicle"
                local vehicle = objectSelection:FindFirstChild(vehicleName)
                if not vehicle or not vehicle.Parent then
                    Library:Notify("Ara√ß bulunamadƒ± (Sƒ±fƒ±rlama: " .. vehicleName .. ")", 2)
                    return
                end
                local chassis = vehicle:FindFirstChild("CarChassis")
                if not chassis or not chassis.Parent then
                    Library:Notify("CarChassis bulunamadƒ± (Sƒ±fƒ±rlama)", 2)
                    return
                end
                local suspension = chassis:FindFirstChild("Suspension")
                if not suspension or not suspension:IsA("NumberValue") then
                    Library:Notify("Suspension NumberValue bulunamadƒ± (Sƒ±fƒ±rlama)", 2)
                    return
                end
                suspension.Value = 0
                Library:Notify("Suspension Sƒ±fƒ±rlandƒ± (Varsayƒ±lan: " .. LocalPlayer.Name .. "'s Vehicle)", 1)
            end)
            if not success then
                Library:Notify("Sƒ±fƒ±rlama Hatasƒ±: " .. tostring(err), 3)
            end
        end)
    end
})

local CombatGroup = Tabs.Combat:AddLeftGroupbox('ESP Ara√ßlarƒ± V2')

-- AYARLAR
local ESPSettings = {
    Enabled = false,
    MaxDistance = 200,
}

local ESPConnections = {}
local PlayerListeners = {}

-- Utility: Baƒülantƒ±larƒ± Temizle
local function cleanupPlayerListeners(player)
    local list = PlayerListeners[player]
    if list then
        for _, conn in ipairs(list) do
            if conn and conn.Disconnect then
                conn:Disconnect()
            end
        end
        PlayerListeners[player] = nil
    end
end

-- NameTag Ayarlarƒ±
local function applyNameTagSettings(nt, isEnabled)
    if not nt then return end
    nt.AlwaysOnTop = isEnabled
    nt.MaxDistance = isEnabled and 10000 or 200
end

-- Oyuncu i√ßin ESP Baƒülantƒ± Kurulumu
local function setupPlayerESP(player, isEnabled)
    cleanupPlayerListeners(player)

    local conns = {}
    PlayerListeners[player] = conns

    local function handleCharacter(char)
        local nt = char:FindFirstChild("NameTag")
        if nt then
            applyNameTagSettings(nt, isEnabled)

            -- NameTag izleme
            table.insert(conns, nt:GetPropertyChangedSignal("AlwaysOnTop"):Connect(function()
                nt.AlwaysOnTop = isEnabled
            end))
            table.insert(conns, nt:GetPropertyChangedSignal("MaxDistance"):Connect(function()
                nt.MaxDistance = isEnabled and 10000 or 200
            end))
        end
    end

    if player.Character then
        handleCharacter(player.Character)
    end

    table.insert(conns, player.CharacterAdded:Connect(function(char)
        char:WaitForChild("NameTag", 2)
        handleCharacter(char)
    end))

    table.insert(conns, player:GetPropertyChangedSignal("Character"):Connect(function()
        if player.Character then
            handleCharacter(player.Character)
        end
    end))
end

-- ESP Ana Fonksiyon
local espLoop
local function toggleESP(enabled)
    ESPSettings.Enabled = enabled
    ESPSettings.MaxDistance = enabled and 10000 or 200

    -- Baƒülantƒ± varsa kapat
    if espLoop then
        espLoop:Disconnect()
        espLoop = nil
    end

    -- T√ºm oyunculara uygula
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            setupPlayerESP(plr, enabled)
        end
    end

    -- Yeni oyuncular eklendik√ße uygula
    local addConn = Players.PlayerAdded:Connect(function(plr)
        if plr ~= LocalPlayer then
            setupPlayerESP(plr, enabled)
        end
    end)
    table.insert(ESPConnections, addConn)

    -- D√∂ng√º: s√ºrekli kontrol
    if enabled then
        espLoop = RunService.Heartbeat:Connect(function()
            local lpChar = LocalPlayer.Character
            if not lpChar or not lpChar:FindFirstChild("HumanoidRootPart") then return end

            local myPos = lpChar.HumanoidRootPart.Position
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (plr.Character.HumanoidRootPart.Position - myPos).Magnitude
                    if dist <= ESPSettings.MaxDistance then
                        local nt = plr.Character:FindFirstChild("NameTag")
                        if nt then
                            applyNameTagSettings(nt, true)
                        end
                    end
                end
            end
        end)
        Library:Notify("ESP Aktif (10000 Max Mesafe, AlwaysOnTop A√ßƒ±k)", 2)
    else
        -- T√ºm oyunculardan baƒülantƒ±larƒ± kaldƒ±r, deƒüerleri sƒ±fƒ±rla
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                local nt = plr.Character:FindFirstChild("NameTag")
                if nt then
                    applyNameTagSettings(nt, false)
                end
            end
            cleanupPlayerListeners(plr)
        end
        Library:Notify("ESP Kapatƒ±ldƒ± (200 Mesafe, AlwaysOnTop Kapalƒ±)", 2)
    end
end

-- UI Toggle
CombatGroup:AddToggle('ESPToggle', {
    Text = 'ESP Etkinle≈ütir)',
    Default = false,
    Tooltip = 'ESP a√ß/kapat (AlwaysOnTop ve Mesafe otomatik ayarlanƒ±r)',
    Callback = function(value)
        toggleESP(value)
    end
})
-- AYARLAR
local BMSettings = {
    MaxDistance = 20000,
    EnabledTargets = {},  -- ["Player1"] = true
    EnabledTeams = {},    -- ["Heroes"] = true
    BaseParts = {
        "Head", "Torso", "HumanoidRootPart",
        "UpperTorso", "LowerTorso",
        "LeftFoot", "RightFoot", "LeftHand", "RightHand",
        "LeftLeg", "RightLeg", "LeftArm", "RightArm"
    }
}

local CachedParts = {}
local GlobalBMRunning = false
local BMConnection = nil

-- PAR√áA CACHELEME
local function CacheParts(player)
    if not player.Character then return end
    local parts = {}
    for _, partName in ipairs(BMSettings.BaseParts) do
        local part = player.Character:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            table.insert(parts, part)
        end
    end
    CachedParts[player] = parts
end

-- TEMƒ∞ZLE
local function ClearCache(player)
    CachedParts[player] = nil
end

-- BM G√ñNDERME
local function BMFire(parts)
    for _, part in ipairs(parts) do
        task.spawn(function()
            pcall(function()
                Event:FireServer("BM", part.Position)
            end)
        end)
    end
end

-- ANA BM LOOP
local function UltraBMLoop()
    if BMConnection then return end

    BMConnection = RunService.Heartbeat:Connect(function()
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end

        local myPos = LocalPlayer.Character.HumanoidRootPart.Position

        for _, plr in ipairs(Players:GetPlayers()) do
            if plr == LocalPlayer then continue end
            if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then continue end
            if not plr.Character:FindFirstChildOfClass("Humanoid") then continue end

            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health <= 0 then continue end

            -- Hedef kontrol√º
            local isTargeted = BMSettings.EnabledTargets[plr.Name]
            local isOnTeam = plr.Team and BMSettings.EnabledTeams[plr.Team.Name]

            if not isTargeted and not isOnTeam then continue end

            -- Menzil kontrol
            local dist = (plr.Character.HumanoidRootPart.Position - myPos).Magnitude
            if dist > BMSettings.MaxDistance then continue end

            -- Cache kontrol
            if not CachedParts[plr] then
                CacheParts(plr)
            end

            -- BM YOLLA
            BMFire(CachedParts[plr])
        end
    end)

    GlobalBMRunning = true
    Library:Notify("üî• Ultimate BM V3 Aktif!", 1)
end

local function StopUltraBM()
    if BMConnection then
        BMConnection:Disconnect()
        BMConnection = nil
    end
    GlobalBMRunning = false
    Library:Notify("üõë Ultimate BM Durduruldu", 1)
end

-- UI OLU≈ûTUR
local BMGroup = Tabs.Combat:AddRightGroupbox("üí£ Auto Kill V2")

-- TAKIM TOGGLES
for _, team in ipairs({"Heroes", "Villains", "Criminals", "Police", "Prisoners"}) do
    BMGroup:AddToggle("BMTeam_" .. team, {
        Text = team,
        Default = false,
        Callback = function(state)
            if state then
                BMSettings.EnabledTeams[team] = true
            else
                BMSettings.EnabledTeams[team] = nil
            end
            if not GlobalBMRunning then UltraBMLoop() end
        end
    })
end

-- OYUNCU DROPDOWN
BMGroup:AddDropdown("BM_Targets", {
    Text = "üéØ Hedef Oyuncular",
    Multi = true,
    Searchable = true,
    Values = {},
    Callback = function(value)
        BMSettings.EnabledTargets = {}
        for name, selected in pairs(value) do
            if selected then
                BMSettings.EnabledTargets[name] = true
            end
        end
        if not GlobalBMRunning then UltraBMLoop() end
    end
})

-- DROPDOWN G√úNCELLEME
local function UpdateDropdown()
    local names = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then table.insert(names, p.Name) end
    end
    if Options.BM_Targets then
        Options.BM_Targets:SetValues(names)
    end
end

UpdateDropdown()
Players.PlayerAdded:Connect(UpdateDropdown)
Players.PlayerRemoving:Connect(function(p)
    ClearCache(p)
    UpdateDropdown()
end)

-- ANA TOGGLE
BMGroup:AddToggle("BM_GlobalToggle", {
    Text = "‚ö° Auto Kill Aktifle≈ütir",
    Default = false,
    Tooltip = "Se√ßilen oyuncu veya takƒ±mlara s√ºrekli Auto Kill yapar",
    Callback = function(state)
        if state then
            UltraBMLoop()
        else
            StopUltraBM()
        end
    end
})

Library:OnUnload(function()
    if espLoop then espLoop:Disconnect() end
    for _, conn in ipairs(ConnectionsESP) do
        if conn then conn:Disconnect() end
    end
    for teamName, conn in pairs(BMConnections) do
        if conn then conn:Disconnect() end
    end
    cachedPlayers = {}
    cachedPositions = {}
end)

local propertyValues = {
    MaxAltitude = 2050,
    MaxSpeed = 1500,
    Acceleration = 10,
    HorizontalTiltSpeed = 10.5,
    Missiles = true,
    Bombs = true,
    Stealth = true,
    MissileCooldown = 0,
    MissileLock = 0,
}

VehicleModBox:AddButton({
    Text = 'SuperFly',
    Func = function()
        task.spawn(function()
            pcall(function()
                for i, v in pairs(getgc(true)) do
                    if type(v) == "table" then
                        for property, value in pairs(propertyValues) do
                            if rawget(v, property) ~= nil then
                                v[property] = value
                            end
                        end
                    end
                end
            end)
        end)
        Library:Notify("SuperFly Uygulandƒ± (Ultra Stabil)", 2)
    end
})

local CombatGroup = Tabs.Combat:AddLeftGroupbox('Takƒ±m Deƒüi≈ütirme')

local RemoteFunction = game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunction")

local function changeTeam(teamName)
    task.spawn(function()
        local success, err = pcall(function()
            local args = {
                [1] = "SetTeam",
                [2] = teamName
            }
            RemoteFunction:InvokeServer(unpack(args))
        end)
        if success then
            Library:Notify("Takƒ±m Deƒüi≈ütirildi: " .. teamName .. " (Stabil)", 2)
        else
            Library:Notify("Takƒ±m Deƒüi≈ütirme Hatasƒ±: " .. tostring(err), 3)
        end
    end)
end

CombatGroup:AddButton({
    Text = 'Police Takƒ±mƒ±',
    Func = function() changeTeam("Police") end
})

CombatGroup:AddButton({
    Text = 'Prisoners Takƒ±mƒ±',
    Func = function() changeTeam("Prisoners") end
})

CombatGroup:AddButton({
    Text = 'Heroes Takƒ±mƒ±',
    Func = function() changeTeam("Heroes") end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Event = ReplicatedStorage:WaitForChild("Event")

local CombatGroup = Tabs.Combat:AddLeftGroupbox('Keycard Exploit')

CombatGroup:AddButton({
    Text = 'Keycard',
    Func = function()
        task.spawn(function()
            local success, err = pcall(function()
                for i = 1, 50 do
                    for _, v in pairs(Players:GetChildren()) do
                        if v and v:IsA("Player") then
                            local args = {
                                [1] = "Pickpocket",
                                [2] = v
                            }
                            Event:FireServer(unpack(args))
                        end
                    end
                end
            end)
            if success then
                Library:Notify("Keycard Tamamlandƒ± (50x All Players, Stabil)", 3)
            else
                Library:Notify("Keycard Hatasƒ±: " .. tostring(err), 3)
            end
        end)
    end
})

local TestTab = Window:AddTab('Test')

local TestGroup = TestTab:AddLeftGroupbox('Test Tools')

TestGroup:AddButton({
    Text = 'Rejoin',
    Func = function()
        task.spawn(function()
            local success, err = pcall(function()
                local TeleportService = game:GetService("TeleportService")
                local StarterGui = game:GetService("StarterGui")
                local placeId = game.PlaceId
                local jobId = game.JobId
                local plr = Players.LocalPlayer
                local maxRetries = 3
                local retryCount = 0
                local retryDelay = 0.2

                local function notify(msg)
                    pcall(function()
                        StarterGui:SetCore("SendNotification", {
                            Title = "Rejoin Script",
                            Text = msg,
                            Duration = 3
                        })
                    end)
                end

                local function rejoin()
                    if retryCount >= maxRetries then
                        notify("Maksimum rejoin denemesi yapƒ±ldƒ±")
                        return
                    end
                    retryCount = retryCount + 1
                    local success, err = pcall(function()
                        TeleportService:TeleportToPlaceInstance(placeId, jobId, plr)
                    end)
                    if not success then
                        local errMsg = tostring(err):lower()
                        if errMsg:find("server is full") or errMsg:find("full") then
                            notify("Sunucu dolu, rejoin yapƒ±lamƒ±yor")
                            return
                        elseif errMsg:find("failed") or errMsg:find("error") then
                            notify("Rejoin ba≈üarƒ±sƒ±z, tekrar deneniyor")
                            task.delay(retryDelay, rejoin)
                            return
                        else
                            notify("Bilinmeyen hata: " .. tostring(err))
                            return
                        end
                    end
                end

                rejoin()
            end)
            if success then
                Library:Notify("Rejoin Ba≈ülatƒ±ldƒ± (Stabil Retry)", 3)
            else
                Library:Notify("Rejoin Hatasƒ±: " .. tostring(err), 3)
            end
        end)
    end
})

TestGroup:AddButton({
    Text = 'Anti-AFK',
    Func = function()
        task.spawn(function()
            local success, err = pcall(function()
                local RunService = game:GetService("RunService")
                local idled = LocalPlayer.Idled
                local getconnections = getconnections or get_signal_cons or nil
                if not getconnections then
                    error("getconnections bulunamadƒ±!")
                end
                for _, conn in pairs(getconnections(idled)) do
                    if conn and conn.Disable then
                        conn:Disable()
                    end
                end
                local lastDisable = 0
                local antiAFKConn = RunService.Heartbeat:Connect(function()
                    if tick() - lastDisable > 60 then
                        if getconnections then
                            for _, conn in pairs(getconnections(idled)) do
                                if conn and conn.Disable then
                                    conn:Disable()
                                end
                            end
                        end
                        lastDisable = tick()
                    end
                end)
                table.insert(Connections, antiAFKConn)
            end)
            if success then
                Library:Notify("Anti-AFK Aktif (Stabil Loop, No Kick)", 3)
            else
                Library:Notify("Anti-AFK Hatasƒ±: " .. tostring(err), 3)
            end
        end)
    end
})

local SilentAimSettings = {
    Enabled = false,
    TargetMode = false,
    TargetPlayers = {},
    BodyPart = "Head",
    Keybind = Enum.UserInputType.MouseButton1,
    FOVVisible = false,
    FOVRadius = 100,
    FOVColor = Color3.fromRGB(255, 0, 0),
    FOVTransparency = 0.5,
    FOVThickness = 2,
    FOVNumSides = 64,
    MultiTarget = false,
    WallCheck = true,
    AggressiveVR = false,
    VRDebounce = 0,
    DebounceTime = 0,
    AggressiveDebounce = 0,
    MaxDistance = 500
}

local SilentAimFOVCircle = Drawing.new("Circle")
SilentAimFOVCircle.Visible = false
SilentAimFOVCircle.Radius = SilentAimSettings.FOVRadius
SilentAimFOVCircle.Thickness = SilentAimSettings.FOVThickness
SilentAimFOVCircle.Color = SilentAimSettings.FOVColor
SilentAimFOVCircle.Transparency = SilentAimSettings.FOVTransparency
SilentAimFOVCircle.Filled = false
SilentAimFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
SilentAimFOVCircle.NumSides = SilentAimSettings.FOVNumSides

local SilentAimConnections = {}
local FOVUpdateConn = nil
local InputConn = nil
local RayParamsCache = RaycastParams.new()
RayParamsCache.FilterType = Enum.RaycastFilterType.Exclude
RayParamsCache.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
RayParamsCache.IgnoreWater = true

local NearbyCache = {}
local CacheTimestamp = 0
local CacheInterval = 0.02

local function IsValidTarget(player)
    if not player or not player.Parent or player == LocalPlayer or player.Name == "MAD_CITYAIMBOTLOL" then return false end
    local character = player.Character
    if not character or not character.Parent then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    return ShouldExpandHitbox(player)
end

local function IsInSilentAimFOV(part)
    if not SilentAimSettings.FOVVisible then return true end
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then return false end
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
    return dist <= SilentAimSettings.FOVRadius
end

local function IsBehindWall(part)
    if not SilentAimSettings.WallCheck then return false end
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin)
    local mag = direction.Magnitude
    if mag <= 1 then return false end
    direction = direction.Unit * mag
    RayParamsCache.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    local result = Workspace:Raycast(origin, direction, RayParamsCache)
    local playerChar = part:FindFirstAncestorOfClass("Model")
    if not result or not result.Instance then return false end
    return not result.Instance:IsDescendantOf(playerChar)
end

local function GetSilentAimTargets()
    local targets = {}
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    for _, player in ipairs(Players:GetPlayers()) do
        if IsValidTarget(player) then
            local part = player.Character:FindFirstChild(SilentAimSettings.BodyPart)
            if part and part:IsA("BasePart") and IsInSilentAimFOV(part) and not IsBehindWall(part) then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    table.insert(targets, {player = player, part = part, dist = screenDist})
                end
            end
        end
    end
    table.sort(targets, function(a, b) return a.dist < b.dist end)
    return targets
end

local function GetCrosshairTarget()
    local mousePos = UserInputService:GetMouseLocation()
    local ray = Camera:ViewportPointToRay(mousePos.X, mousePos.Y)
    local result = Workspace:Raycast(ray.Origin, ray.Direction * 5000, RayParamsCache)
    if result and result.Instance then
        local hitModel = result.Instance:FindFirstAncestorOfClass("Model")
        if hitModel and hitModel:FindFirstChildOfClass("Humanoid") then
            local player = Players:GetPlayerFromCharacter(hitModel)
            if player and IsValidTarget(player) then
                local part = hitModel:FindFirstChild(SilentAimSettings.BodyPart)
                if part and part:IsA("BasePart") and not IsBehindWall(part) then
                    return {{player = player, part = part, dist = 0}}
                end
            end
        end
    end
    return GetSilentAimTargets()
end

local function GetNearbyTargets()
    local now = tick()
    if now - CacheTimestamp < CacheInterval then
        return NearbyCache
    end
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position or Camera.CFrame.Position
    local targets = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if IsValidTarget(player) and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local part = player.Character:FindFirstChild(SilentAimSettings.BodyPart)
            local rootPart = player.Character.HumanoidRootPart
            local dist = (rootPart.Position - myPos).Magnitude
            if dist <= SilentAimSettings.MaxDistance then
                if not IsBehindWall(part) then
                    table.insert(targets, {player = player, part = part, dist = dist})
                end
            end
        end
    end
    table.sort(targets, function(a, b) return a.dist < b.dist end)
    NearbyCache = targets
    CacheTimestamp = now
    return targets
end

local function FireVREvent(targets)
    local now = tick()
    local debounce = SilentAimSettings.AggressiveVR and SilentAimSettings.AggressiveDebounce or SilentAimSettings.DebounceTime
    if now - SilentAimSettings.VRDebounce < debounce then return end
    SilentAimSettings.VRDebounce = now
    for _, t in ipairs(targets) do
        task.spawn(function()
            local part = t.part
            if not part or not part.Parent then return end
            local args = {
                [1] = "VR",
                [2] = part
            }
            pcall(Event.FireServer, Event, unpack(args))
        end)
    end
end

local function ToggleFOVUpdate(enabled)
    if FOVUpdateConn then
        pcall(FOVUpdateConn.Disconnect, FOVUpdateConn)
        FOVUpdateConn = nil
    end
    if enabled and SilentAimSettings.Enabled then
        FOVUpdateConn = RunService.Stepped:Connect(function()
            if not SilentAimSettings.FOVVisible then
                SilentAimFOVCircle.Visible = false
                return
            end
            SilentAimFOVCircle.Radius = SilentAimSettings.FOVRadius
            SilentAimFOVCircle.Color = SilentAimSettings.FOVColor
            SilentAimFOVCircle.Transparency = SilentAimSettings.FOVTransparency
            SilentAimFOVCircle.Thickness = SilentAimSettings.FOVThickness
            SilentAimFOVCircle.NumSides = SilentAimSettings.FOVNumSides
            SilentAimFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            SilentAimFOVCircle.Visible = true
        end)
        table.insert(SilentAimConnections, FOVUpdateConn)
    else
        SilentAimFOVCircle.Visible = false
    end
end

InputConn = UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType ~= SilentAimSettings.Keybind and input.KeyCode ~= SilentAimSettings.Keybind then return end
    if not SilentAimSettings.Enabled and not SilentAimSettings.AggressiveVR then return end
    local targets
    if SilentAimSettings.TargetMode and next(SilentAimSettings.TargetPlayers) then
        targets = {}
        for targetName, _ in pairs(SilentAimSettings.TargetPlayers) do
            local targetPlayer = Players:FindFirstChild(targetName)
            if IsValidTarget(targetPlayer) then
                local part = targetPlayer.Character:FindFirstChild(SilentAimSettings.BodyPart)
                if part and part:IsA("BasePart") and not IsBehindWall(part) then
                    table.insert(targets, {player = targetPlayer, part = part, dist = 0})
                end
            end
        end
    elseif SilentAimSettings.AggressiveVR then
        targets = GetNearbyTargets()
        if not SilentAimSettings.MultiTarget then
            targets = {targets[1]}
        end
    else
        if SilentAimSettings.FOVVisible then
            targets = GetSilentAimTargets()
        else
            targets = GetCrosshairTarget()
        end
        if not SilentAimSettings.MultiTarget then
            targets = {targets[1]}
        end
    end
    if targets and #targets > 0 then
        FireVREvent(targets)
    end
end)
table.insert(SilentAimConnections, InputConn)

local SilentAimBox = Tabs['Silent Aim']:AddLeftGroupbox('Silent Aim')

SilentAimBox:AddToggle('SilentAimEnabled', {
    Text = 'Silent Aim Etkin',
    Default = false,
    Tooltip = 'Standart Silent Aim a√ß/kapat',
    Risky = true,
    Callback = function(value)
        SilentAimSettings.Enabled = value
        if value then
            ToggleFOVUpdate(SilentAimSettings.FOVVisible)
        else
            ToggleFOVUpdate(false)
        end
    end
})

SilentAimBox:AddToggle('TargetModeSilent', {
    Text = 'Sadece Hedef Modu',
    Default = false,
    Tooltip = 'A√ßƒ±k: √áoklu hedeflere VR, Kapalƒ±: FOV/Multi',
    Callback = function(value)
        SilentAimSettings.TargetMode = value
    end
})

SilentAimBox:AddDropdown('TargetPlayerSilent', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Hedef Oyuncular',
    Multi = true,
    Tooltip = '√áoklu se√ß (Sadece Hedef Modu\'nda)',
    Callback = function(value)
        SilentAimSettings.TargetPlayers = value
    end
})

SilentAimBox:AddDropdown('BodyPartSilent', {
    Values = {'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso', 'LeftUpperArm', 'RightUpperArm', 'LeftLowerArm', 'RightLowerArm', 'LeftHand', 'RightHand', 'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerLeg', 'RightLowerLeg', 'LeftFoot', 'RightFoot'},
    Default = 'Head',
    Text = 'V√ºcut Par√ßasƒ±',
    Tooltip = 'VR i√ßin',
    Callback = function(value)
        SilentAimSettings.BodyPart = value
    end
})

SilentAimBox:AddLabel('Tetik Tu≈üu'):AddKeyPicker('SilentAimKey', {
    Default = 'MouseButton1',
    Mode = 'Press',
    Text = 'VR Tu≈üu',
    NoUI = true,
    Tooltip = 'Basƒ±nca VR g√∂nder',
    ChangedCallback = function(newKey)
        SilentAimSettings.Keybind = newKey
    end
})

SilentAimBox:AddDivider()

SilentAimBox:AddToggle('FOVSilentVisible', {
    Text = 'FOV √áemberi',
    Default = false,
    Tooltip = 'FOV g√∂ster (i√ßindekilere VR)',
    Callback = function(value)
        SilentAimSettings.FOVVisible = value
        ToggleFOVUpdate(value)
    end
})

SilentAimBox:AddSlider('FOVRadiusSilent', {
    Text = 'FOV Yarƒ±√ßap',
    Default = 100,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Callback = function(value)
        SilentAimSettings.FOVRadius = value
    end
})

SilentAimBox:AddLabel('FOV Rengi'):AddColorPicker('FOVColorSilent', {
    Default = Color3.fromRGB(255, 0, 0),
    Title = 'FOV Rengi',
    Callback = function(color)
        SilentAimSettings.FOVColor = color
    end
})

SilentAimBox:AddSlider('FOVSidesSilent', {
    Text = 'FOV Kenarlar',
    Default = 64,
    Min = 4,
    Max = 128,
    Rounding = 0,
    Callback = function(value)
        SilentAimSettings.FOVNumSides = value
    end
})

SilentAimBox:AddDivider()

SilentAimBox:AddToggle('MultiTargetSilent', {
    Text = 'Multi Target',
    Default = false,
    Tooltip = 'T√ºm FOV\'ye VR',
    Callback = function(value)
        SilentAimSettings.MultiTarget = value
    end
})

SilentAimBox:AddToggle('WallCheckSilent', {
    Text = 'Duvar Kontrol√º',
    Default = true,
    Tooltip = 'Duvar arkasƒ±na VR g√∂nderme',
    Callback = function(value)
        SilentAimSettings.WallCheck = value
    end
})

SilentAimBox:AddToggle('AggressiveVRSilent', {
    Text = 'Silent Aim AGRESƒ∞F',
    Default = false,
    Tooltip = 'A√ßƒ±k: Yakƒ±ndaki herkese anƒ±nda VR (duvar kontrol√º etkiler, baƒüƒ±msƒ±z √ßalƒ±≈üƒ±r)',
    Risky = true,
    Callback = function(value)
        SilentAimSettings.AggressiveVR = value
    end
})

SilentAimBox:AddSlider('AggressiveDistance', {
    Text = 'AGRESƒ∞F Mesafe',
    Default = 500,
    Min = 100,
    Max = 2000,
    Rounding = 0,
    Callback = function(value)
        SilentAimSettings.MaxDistance = value
    end
})

SilentAimBox:AddSlider('DebounceSilent', {
    Text = 'Normal Debounce (s)',
    Default = 0,
    Min = 0,
    Max = 0.5,
    Rounding = 3,
    Callback = function(value)
        SilentAimSettings.DebounceTime = value
    end
})

SilentAimBox:AddSlider('AggressiveDebounce', {
    Text = 'AGRESƒ∞F Debounce (s)',
    Default = 0,
    Min = 0,
    Max = 0.1,
    Rounding = 3,
    Callback = function(value)
        SilentAimSettings.AggressiveDebounce = value
    end
})

-- Eksik StartAutoVR fonksiyonu (otomatik VR loop'u)
local AutoVRConnections = {}
local AutoVRDebounce = {}
local function StartAutoVR(enabled, targetPlayer)
    if not enabled then
        for _, conn in pairs(AutoVRConnections) do
            if conn then conn:Disconnect() end
        end
        AutoVRConnections = {}
        AutoVRDebounce = {}
        return
    end

    local lastVRTime = 0
    local debounceTime = 0.1 -- Varsayƒ±lan debounce
    local loopConn = RunService.Heartbeat:Connect(function()
        local now = tick()
        if now - lastVRTime < debounceTime then return end
        lastVRTime = now

        local targets = {}
        if targetPlayer then
            local player = Players:FindFirstChild(targetPlayer)
            if IsValidTarget(player) then
                local part = player.Character:FindFirstChild(SilentAimSettings.BodyPart)
                if part then
                    table.insert(targets, {player = player, part = part})
                end
            end
        else
            local nearby = GetNearbyTargets()
            for _, t in ipairs(nearby) do
                table.insert(targets, t)
            end
        end

        if #targets > 0 then
            FireVREvent(targets)
        end
    end)
    table.insert(AutoVRConnections, loopConn)
end

local SelectedTargetPlayer = nil
local SilentAimLeftGroup = Tabs['Silent Aim']:AddLeftGroupbox('Silent Aim Mod√ºlleri')

SilentAimLeftGroup:AddDropdown('TargetPlayerAuto', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Hedef Oyuncu Se√ßimi',
    Tooltip = 'Silent Aim i√ßin belirli bir oyuncuyu hedefleyin',
    Callback = function(value)
        SelectedTargetPlayer = value
    end
})

SilentAimLeftGroup:AddToggle('SilentAimAuto', {
    Text = 'Otomatik Silent Aim (Yakƒ±n Oyuncular)',
    Default = false,
    Tooltip = 'Yakƒ±ndaki oyunculara otomatik Silent Aim uygular (stabil ve g√ºvenli)',
    Callback = function(value)
        StartAutoVR(value, nil)
    end
})

SilentAimLeftGroup:AddToggle('TargetSilentAimAuto', {
    Text = 'Hedefli Silent Aim',
    Default = false,
    Tooltip = 'Se√ßili oyuncuya s√ºrekli Silent Aim uygular (y√ºksek doƒüruluk)',
    Callback = function(value)
        StartAutoVR(value, SelectedTargetPlayer)
    end
})

local SilentAimRightGroup = Tabs['Silent Aim']:AddRightGroupbox('Ara√ß Teker Patlatma')

local WheelParts = {'FrontLeftWheel', 'FrontRightWheel', 'BackLeftWheel', 'BackRightWheel', 'Random'}
local SelectedWheel = 'FrontLeftWheel'

SilentAimRightGroup:AddDropdown('WheelPartDropdown', {
    Values = WheelParts,
    Default = 1,
    Text = 'Teker Par√ßasƒ± Se√ßimi',
    Tooltip = 'Patlatƒ±lacak teker par√ßasƒ±nƒ± se√ßin (Random: Rastgele mevcut teker)',
    Callback = function(Value)
        SelectedWheel = Value
    end
})

local WheelFOVCircle = Drawing.new("Circle")
WheelFOVCircle.Visible = false
WheelFOVCircle.Radius = 100
WheelFOVCircle.Thickness = 2
WheelFOVCircle.Color = Color3.fromRGB(0, 255, 0)
WheelFOVCircle.Transparency = 0.5
WheelFOVCircle.Filled = false
WheelFOVCircle.NumSides = 64
WheelFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

local WheelFOVEnabled = false
local WheelFOVUpdateConn = nil
local WheelShottyCacheTime = 0
local WheelFOVCache = {}
local WheelFOVCacheTime = 0
local WheelFOVCacheInterval = 0.01 -- Throttle artƒ±rdƒ±m, FPS i√ßin
local WheelRayCount = 12

local BlacklistPlayers = {"MAD_CITYAIMBOTLOL", "Emiraganz"}

local function IsBlacklisted(vehName)
    local playerName = vehName:match("^(.-)'s Vehicle$")
    return table.find(BlacklistPlayers, playerName) ~= nil
end

local function GetSmartRandomWheel(veh)
    local availableWheels = {}
    for _, wheelName in ipairs({'FrontLeftWheel', 'FrontRightWheel', 'BackLeftWheel', 'BackRightWheel'}) do
        local wheel = veh:FindFirstChild(wheelName, true)
        if wheel and wheel:IsA("BasePart") and wheel.Parent and wheel.Parent == veh then
            table.insert(availableWheels, wheel)
        end
    end
    if #availableWheels > 0 then
        return availableWheels[math.random(1, #availableWheels)]
    end
    return nil
end

local function FireShottySafe(wheel)
    if wheel and wheel.Parent then
        local args = { [1] = "SHOTTY", [2] = wheel }
        pcall(Event.FireServer, Event, unpack(args))
    end
end

local function ToggleWheelFOV(enabled)
    WheelFOVEnabled = enabled
    if WheelFOVUpdateConn then
        WheelFOVUpdateConn:Disconnect()
        WheelFOVUpdateConn = nil
    end
    if enabled then
        WheelFOVUpdateConn = RunService.RenderStepped:Connect(function()
            if not WheelFOVEnabled then 
                WheelFOVCircle.Visible = false
                return 
            end
            local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            WheelFOVCircle.Position = center
            WheelFOVCircle.Radius = Options.WheelFOVRadius and Options.WheelFOVRadius.Value or 100
            WheelFOVCircle.Color = Options.WheelFOVColor and Options.WheelFOVColor.Value or Color3.fromRGB(0, 255, 0)
            WheelFOVCircle.NumSides = Options.FOVSidesSilent and Options.FOVSidesSilent.Value or 64
            WheelFOVCircle.Visible = true
            
            local now = tick()
            if now - WheelShottyCacheTime < 0.03 then return end
            WheelShottyCacheTime = now
            local cacheHits = 0
            for i = #WheelFOVCache, 1, -1 do
                local hit = WheelFOVCache[i]
                if now - hit.timestamp < 0.1 then
                    if hit.wheel and hit.wheel.Parent then
                        local veh = hit.veh
                        if not IsBlacklisted(veh.Name) then
                            FireShottySafe(hit.wheel)
                            cacheHits = cacheHits + 1
                        end
                    else
                        table.remove(WheelFOVCache, i)
                    end
                else
                    table.remove(WheelFOVCache, i)
                end
            end
            if cacheHits > 0 then return end
            
            if now - WheelFOVCacheTime < WheelFOVCacheInterval then return end
            WheelFOVCacheTime = now
            WheelFOVCache = {}
            
            local mousePos = UserInputService:GetMouseLocation()
            local baseRay = Camera:ViewportPointToRay(mousePos.X, mousePos.Y)
            local fovAngle = math.rad((Options.WheelFOVRadius and Options.WheelFOVRadius.Value or 100) * 0.3)
            local stepAngle = fovAngle / (WheelRayCount - 1)
            
            local objectSelection = workspace:FindFirstChild("ObjectSelection")
            if not objectSelection then return end
            
            for i = 1, WheelRayCount do
                local angleOffset = (i - (WheelRayCount + 1)/2) * stepAngle
                local rot = CFrame.Angles(0, angleOffset, 0)
                local dir = baseRay.Direction * rot
                local ray = Ray.new(baseRay.Origin, dir.Unit * 1000)
                
                local rayParams = RaycastParams.new()
                rayParams.FilterType = Enum.RaycastFilterType.Exclude
                rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
                rayParams.IgnoreWater = true
                local result = Workspace:Raycast(ray.Origin, dir.Unit * 1000, rayParams)
                
                if result and result.Instance then
                    local veh = result.Instance:FindFirstAncestor(function(child)
                        return child:IsA("Model") and child.Name:match(".*'s Vehicle")
                    end)
                    local localVehName = LocalPlayer.Name .. "'s Vehicle"
                    if veh and veh.Name ~= localVehName and not IsBlacklisted(veh.Name) then
                        local wheel = SelectedWheel == 'Random' and GetSmartRandomWheel(veh) or veh:FindFirstChild(SelectedWheel, true)
                        if wheel then
                            FireShottySafe(wheel)
                            table.insert(WheelFOVCache, {veh = veh, wheel = wheel, timestamp = now})
                        end
                    end
                end
            end
        end)
        table.insert(SilentAimConnections, WheelFOVUpdateConn)
    else
        WheelFOVCircle.Visible = false
        WheelFOVCache = {}
    end
end

SilentAimRightGroup:AddToggle('WheelFOVToggle', {
    Text = 'Teker FOV √áemberi',
    Default = false,
    Tooltip = 'FOV i√ßindeki tekerlere otomatik SHOTTY (kendi ve blacklist ara√ßlarƒ± yoksayar)',
    Callback = function(value)
        ToggleWheelFOV(value)
    end
})

SilentAimRightGroup:AddSlider('WheelFOVRadius', {
    Text = 'Teker FOV Yarƒ±√ßapƒ±',
    Default = 100,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Tooltip = 'FOV √ßemberinin boyutunu ayarlayƒ±n (daha b√ºy√ºk = daha geni≈ü kapsama)',
    Callback = function() end
})

SilentAimRightGroup:AddLabel('Teker FOV Rengi'):AddColorPicker('WheelFOVColor', {
    Default = Color3.fromRGB(0, 255, 0),
    Title = 'Teker FOV Rengi',
    Tooltip = 'FOV √ßemberinin rengini √∂zelle≈ütirin',
    Callback = function() end
})

local TekerSilentDebounce = {}
local TekerKeybindConn = nil
local TekerTargetLoop = nil
local SelectedTekerTarget = nil
local NearbyVehCache = {}
local NearbyVehCacheTime = 0
local NearbyVehInterval = 0.01 -- Throttle
local TekerNearbyFOVEnabled = false
local TekerNearbyFOVCircle = Drawing.new("Circle")
TekerNearbyFOVCircle.Visible = false
TekerNearbyFOVCircle.Radius = 120
TekerNearbyFOVCircle.Thickness = 2
TekerNearbyFOVCircle.Color = Color3.fromRGB(255, 165, 0)
TekerNearbyFOVCircle.Transparency = 0.6
TekerNearbyFOVCircle.Filled = false
TekerNearbyFOVCircle.NumSides = 64
TekerNearbyFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

local function GetVehicleRoot(veh)
    local body = veh:FindFirstChild("Body")
    if body and body:IsA("BasePart") then return body end
    local chassis = veh:FindFirstChild("CarChassis") or veh:FindFirstChild("Chassis")
    if chassis and chassis:IsA("BasePart") then return chassis end
    local wheels = {}
    for _, wName in ipairs({'FrontLeftWheel', 'FrontRightWheel', 'BackLeftWheel', 'BackRightWheel'}) do
        local w = veh:FindFirstChild(wName)
        if w and w:IsA("BasePart") then table.insert(wheels, w.Position) end
    end
    if #wheels >= 2 then
        local avgPos = Vector3.new(0,0,0)
        for _, pos in ipairs(wheels) do avgPos = avgPos + pos end
        return {Position = avgPos / #wheels}
    end
    return nil
end

local function GetNearbyVehicles(myPos)
    local now = tick()
    if now - NearbyVehCacheTime < NearbyVehInterval then return NearbyVehCache end
    local objectSelection = workspace:FindFirstChild("ObjectSelection")
    if not objectSelection then return {} end
    local vehicles = {}
    local localVehName = LocalPlayer.Name .. "'s Vehicle"
    for _, obj in ipairs(objectSelection:GetChildren()) do
        if obj.Name:match(".*'s Vehicle") and obj.Name ~= localVehName and not IsBlacklisted(obj.Name) then
            local root = GetVehicleRoot(obj)
            if root then
                local dist = (root.Position - myPos).Magnitude
                if dist <= 400 then
                    table.insert(vehicles, {veh = obj, root = root, dist = dist})
                end
            end
        end
    end
    table.sort(vehicles, function(a, b) return a.dist < b.dist end)
    NearbyVehCache = vehicles
    NearbyVehCacheTime = now
    return vehicles
end

local function IsWheelInNearbyFOV(wheel)
    if not TekerNearbyFOVEnabled then return true end
    local screenPos, onScreen = Camera:WorldToViewportPoint(wheel.Position)
    if not onScreen then return false end
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
    return dist <= TekerNearbyFOVCircle.Radius
end

SilentAimRightGroup:AddDropdown('TekerTargetPlayer', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Teker Hedef Oyuncu',
    Tooltip = 'Belirli bir oyuncunun aracƒ±na SHOTTY g√∂nderin (blacklist hari√ß)',
    Callback = function(value)
        SelectedTekerTarget = value
    end
})

SilentAimRightGroup:AddToggle('TekerSilentTarget', {
    Text = 'Hedefli Teker Patlatma',
    Default = false,
    Tooltip = 'Se√ßili oyuncunun aracƒ±na otomatik SHOTTY (kendi ve blacklist ara√ßlarƒ± yoksayar)',
    Callback = function(value)
        if value and SelectedTekerTarget then
            if TekerTargetLoop then TekerTargetLoop:Disconnect() end
            local lastTekerCheck = 0
            TekerTargetLoop = RunService.RenderStepped:Connect(function()
                if not value or not SelectedTekerTarget then return end
                local now = tick()
                if now - lastTekerCheck < 0.05 then return end
                lastTekerCheck = now
                local objectSelection = workspace:FindFirstChild("ObjectSelection")
                if not objectSelection then return end
                local vehName = SelectedTekerTarget .. "'s Vehicle"
                local localVehName = LocalPlayer.Name .. "'s Vehicle"
                local veh = objectSelection:FindFirstChild(vehName)
                if veh and veh.Name ~= localVehName and not IsBlacklisted(veh.Name) then
                    local wheel = SelectedWheel == 'Random' and GetSmartRandomWheel(veh) or veh:FindFirstChild(SelectedWheel, true)
                    if wheel then
                        local wheelKey = vehName .. "_" .. wheel.Name
                        if now - (TekerSilentDebounce[wheelKey] or 0) > 0.12 then
                            TekerSilentDebounce[wheelKey] = now
                            FireShottySafe(wheel)
                        end
                    end
                end
            end)
            table.insert(SilentAimConnections, TekerTargetLoop)
        else
            if TekerTargetLoop then
                TekerTargetLoop:Disconnect()
                TekerTargetLoop = nil
            end
        end
    end
})

local TekerKeybind = Enum.KeyCode.Q
SilentAimRightGroup:AddLabel('Teker Keybind'):AddKeyPicker('TekerKeybindPicker', {
    Default = 'Q',
    Mode = 'Press',
    Text = 'Yakƒ±n Teker Tetik Tu≈üu',
    NoUI = true,
    Tooltip = 'Yakƒ±ndaki ara√ßlara SHOTTY g√∂ndermek i√ßin tu≈ü atayƒ±n (blacklist hari√ß)',
    ChangedCallback = function(newKey)
        TekerKeybind = newKey
    end
})

SilentAimRightGroup:AddToggle('TekerSilentNearby', {
    Text = 'Yakƒ±n Ara√ß Teker Patlatma',
    Default = false,
    Tooltip = 'Tu≈üa basƒ±nca yakƒ±ndaki ara√ßlara SHOTTY (kendi ve blacklist ara√ßlarƒ± yoksayar, FOV sƒ±nƒ±rlƒ±)',
    Callback = function(value)
        if TekerKeybindConn then
            TekerKeybindConn:Disconnect()
            TekerKeybindConn = nil
        end
        if value then
            TekerKeybindConn = UserInputService.InputBegan:Connect(function(input, processed)
                if processed then return end
                if (input.KeyCode == TekerKeybind or input.UserInputType == TekerKeybind) then
                    local myPos = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position) or Vector3.new(0,0,0)
                    local vehicles = GetNearbyVehicles(myPos)
                    local now = tick()
                    local maxShots = 8
                    local localVehName = LocalPlayer.Name .. "'s Vehicle"
                    for i = 1, math.min(#vehicles, maxShots) do
                        task.spawn(function()
                            local vData = vehicles[i]
                            local veh = vData.veh
                            if veh.Name == localVehName or IsBlacklisted(veh.Name) then return end
                            local vehName = veh.Name
                            local wheel = SelectedWheel == 'Random' and GetSmartRandomWheel(veh) or veh:FindFirstChild(SelectedWheel, true)
                            if wheel and IsWheelInNearbyFOV(wheel) then
                                local wheelKey = vehName .. "_" .. wheel.Name
                                if now - (TekerSilentDebounce[wheelKey] or 0) > 0.1 then
                                    TekerSilentDebounce[wheelKey] = now
                                    FireShottySafe(wheel)
                                end
                            end
                        end)
                    end
                end
            end)
            table.insert(SilentAimConnections, TekerKeybindConn)
        end
    end
})

SilentAimRightGroup:AddToggle('TekerNearbyFOV', {
    Text = 'Yakƒ±n Teker FOV Sƒ±nƒ±rlƒ±',
    Default = false,
    Tooltip = 'Yakƒ±n teker patlatmayƒ± FOV ile sƒ±nƒ±rlayƒ±n (sadece √ßember i√ßindekiler, blacklist hari√ß)',
    Callback = function(value)
        TekerNearbyFOVEnabled = value
        TekerNearbyFOVCircle.Visible = value
        TekerNearbyFOVCircle.Radius = Options.TekerNearbyFOVRadius and Options.TekerNearbyFOVRadius.Value or 120
        TekerNearbyFOVCircle.Color = Options.TekerNearbyFOVColor and Options.TekerNearbyFOVColor.Value or Color3.fromRGB(255, 165, 0)
    end
})

SilentAimRightGroup:AddSlider('TekerNearbyFOVRadius', {
    Text = 'Yakƒ±n Teker FOV Yarƒ±√ßapƒ±',
    Default = 120,
    Min = 50,
    Max = 600,
    Rounding = 0,
    Tooltip = 'Yakƒ±n teker FOV √ßemberinin boyutunu ayarlayƒ±n (daha b√ºy√ºk = daha geni≈ü kapsama)',
    Callback = function(value)
        if TekerNearbyFOVEnabled then
            TekerNearbyFOVCircle.Radius = value
        end
    end
})

SilentAimRightGroup:AddLabel('Yakƒ±n Teker FOV Rengi'):AddColorPicker('TekerNearbyFOVColor', {
    Default = Color3.fromRGB(255, 165, 0),
    Title = 'Yakƒ±n Teker FOV Rengi',
    Tooltip = 'Yakƒ±n teker FOV √ßemberinin rengini √∂zelle≈ütirin',
    Callback = function(color)
        if TekerNearbyFOVEnabled then
            TekerNearbyFOVCircle.Color = color
        end
    end
})

local AutoTekerLoopConn = nil
local AutoTekerCache = {}
local AutoTekerCacheTime = 0
local AutoTekerInterval = 0.01 -- Throttle
local AutoTekerEnabled = false
local AutoTekerTargetPlayer = nil
local AutoTekerMode = 'Random'

SilentAimRightGroup:AddDropdown('AutoTekerMode', {
    Values = {'Random', 'Hepsi'},
    Default = 1,
    Text = 'Otomatik Patlatma Modu',
    Tooltip = 'Random: Rastgele bir teker, Hepsi: T√ºm tekerler birden',
    Callback = function(Value)
        AutoTekerMode = Value
    end
})

SilentAimRightGroup:AddDropdown('AutoTekerTarget', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Otomatik Teker Hedef',
    Tooltip = 'Belirli bir oyuncunun aracƒ±na otomatik SHOTTY (blacklist hari√ß)',
    Callback = function(value)
        AutoTekerTargetPlayer = value
    end
})

SilentAimRightGroup:AddToggle('AutoTekerPatlatici', {
    Text = 'Otomatik Teker Patlatƒ±cƒ±',
    Default = false,
    Tooltip = 'Yakƒ±ndaki veya hedef aracƒ±n tekerlerini otomatik patlatƒ±r (kendi ve blacklist ara√ßlarƒ± yoksayar)',
    Callback = function(value)
        AutoTekerEnabled = value
        if AutoTekerLoopConn then
            AutoTekerLoopConn:Disconnect()
            AutoTekerLoopConn = nil
        end
        if value then
            local lastAutoCheck = 0
            AutoTekerLoopConn = RunService.RenderStepped:Connect(function()
                if not AutoTekerEnabled then return end
                local now = tick()
                if now - lastAutoCheck < 0.01 then return end
                lastAutoCheck = now
                local myPos = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position) or Vector3.new(0,0,0)
                local vehicles = AutoTekerTargetPlayer and {} or GetNearbyVehicles(myPos)
                if AutoTekerTargetPlayer then
                    local objectSelection = workspace:FindFirstChild("ObjectSelection")
                    if objectSelection then
                        local vehName = AutoTekerTargetPlayer .. "'s Vehicle"
                        local localVehName = LocalPlayer.Name .. "'s Vehicle"
                        local veh = objectSelection:FindFirstChild(vehName)
                        if veh and veh.Name ~= localVehName and not IsBlacklisted(veh.Name) then
                            table.insert(vehicles, {veh = veh, dist = 0})
                        end
                    end
                end
                local localVehName = LocalPlayer.Name .. "'s Vehicle"
                for _, vData in ipairs(vehicles) do
                    local veh = vData.veh
                    if veh.Name == localVehName or IsBlacklisted(veh.Name) then continue end
                    local vehName = veh.Name
                    task.spawn(function()
                        if AutoTekerMode == 'Hepsi' then
                            for _, wheelName in ipairs({'FrontLeftWheel', 'FrontRightWheel', 'BackLeftWheel', 'BackRightWheel'}) do
                                local wheel = veh:FindFirstChild(wheelName, true)
                                if wheel then
                                    local wheelKey = vehName .. "_" .. wheelName
                                    if now - (TekerSilentDebounce[wheelKey] or 0) > 0.08 then
                                        TekerSilentDebounce[wheelKey] = now
                                        FireShottySafe(wheel)
                                    end
                                end
                            end
                        else
                            local wheel = GetSmartRandomWheel(veh)
                            if wheel then
                                local wheelKey = vehName .. "_" .. wheel.Name
                                if now - (TekerSilentDebounce[wheelKey] or 0) > 0.09 then
                                    TekerSilentDebounce[wheelKey] = now
                                    FireShottySafe(wheel)
                                end
                            end
                        end
                    end)
                end
            end)
            table.insert(SilentAimConnections, AutoTekerLoopConn)
        end
    end
})

workspace.ChildAdded:Connect(function(child)
    if child.Name:match(".*'s Vehicle") then
        NearbyVehCacheTime = 0
        WheelFOVCacheTime = 0
        AutoTekerCacheTime = 0
    end
end)

Library:OnUnload(function()
    for player, _ in pairs(ActiveHitboxes) do
        RestoreHitbox(player)
    end
    if OptimizedConn then OptimizedConn:Disconnect() end
    for _, conns in pairs(Connections) do
        if typeof(conns) == "table" then
            for _, conn in ipairs(conns) do
                pcall(conn.Disconnect, conn)
            end
        else
            pcall(conns.Disconnect, conns)
        end
    end
    Connections = {}
    if FOVCircle then FOVCircle:Remove() end
    if SilentAimFOVCircle then SilentAimFOVCircle:Remove() end
    if WheelFOVCircle then WheelFOVCircle:Remove() end
    if TekerNearbyFOVCircle then TekerNearbyFOVCircle:Remove() end
    for _, conn in pairs(AutoVRConnections) do
        if conn then pcall(conn.Disconnect, conn) end
    end
    for _, conn in pairs(SilentAimConnections) do
        if conn then pcall(conn.Disconnect, conn) end
    end
    CollectionService:RemoveTag(Workspace, HitboxTag)
    print('Kapatƒ±ldƒ±!')
    Library.Unloaded = true
end)

Library:Notify("Wia Men√º V2 Beta", 3)

local uiConn = RunService:BindToRenderStep("UIUpdate", Enum.RenderPriority.Camera.Value + 1, function()
    if Library.Unloaded then
        RunService:UnbindFromRenderStep("UIUpdate")
    end
end)
table.insert(Connections, uiConn)

-- ULTRA MAX POWER Silent Aim (Executor Uyumlu Fix ‚Äì 0 Delay, En Geli≈ümi≈ü)
local SilentAimSettings = {
    Enabled = false,
    TargetMode = false,
    TargetPlayers = {},
    BodyPart = "Head",
    Keybind = Enum.UserInputType.MouseButton1,
    FOVVisible = false,
    FOVRadius = 100,
    FOVColor = Color3.fromRGB(255, 0, 0),
    FOVTransparency = 0.5,
    FOVThickness = 2,
    FOVNumSides = 64,
    MultiTarget = false,
    WallCheck = true,
    AggressiveVR = false,
    VRDebounce = 0,
    DebounceTime = 0,
    AggressiveDebounce = 0,
    MaxDistance = 10000
}

-- Pooled Raycast
local RayParamsPool = RaycastParams.new()
RayParamsPool.FilterType = Enum.RaycastFilterType.Exclude
RayParamsPool.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
RayParamsPool.IgnoreWater = true

local SilentAimFOVCircle = Drawing.new("Circle")
SilentAimFOVCircle.Visible = false
SilentAimFOVCircle.Radius = SilentAimSettings.FOVRadius
SilentAimFOVCircle.Thickness = SilentAimSettings.FOVThickness
SilentAimFOVCircle.Color = SilentAimSettings.FOVColor
SilentAimFOVCircle.Transparency = SilentAimSettings.FOVTransparency
SilentAimFOVCircle.Filled = false
SilentAimFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
SilentAimFOVCircle.NumSides = SilentAimSettings.FOVNumSides

local SilentAimConnections = {}
local FOVUpdateConn = nil
local InputConn = nil

-- Cache'ler
local NearbyCache = {}
local CacheTimestamp = 0
local WallCheckCache = {}
local WallCacheTTL = 0.05

local AutoVRDebouncePool = {}

local BodyPartsPool = {'Head', 'UpperTorso', 'LowerTorso', 'HumanoidRootPart', 'LeftUpperArm', 'RightUpperArm', 'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerArm', 'RightLowerArm'}

local function IsValidTarget(player)
    return player and player.Parent and player ~= LocalPlayer and player.Name ~= "MAD_CITYAIMBOTLOL" and
           player.Character and player.Character.Parent and
           player.Character:FindFirstChildOfClass("Humanoid") and player.Character:FindFirstChildOfClass("Humanoid").Health > 0 and
           ShouldExpandHitbox(player)
end

local function UpdateSpatialCache()
    local now = tick()
    CacheTimestamp = now
    
    NearbyCache = {}
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position or Camera.CFrame.Position
    
    for _, player in ipairs(Players:GetPlayers()) do
        if IsValidTarget(player) then
            local rootPart = player.Character.HumanoidRootPart
            local dist = (rootPart.Position - myPos).Magnitude
            if dist <= SilentAimSettings.MaxDistance then
                for _, partName in ipairs(BodyPartsPool) do
                    local part = player.Character:FindFirstChild(partName)
                    if part and part:IsA("BasePart") then
                        local cacheKey = player.Name .. "_" .. partName
                        local isWallData = WallCheckCache[cacheKey]
                        local wallValue = true  -- Default to true if no data
                        if isWallData and type(isWallData) == "table" and (now - isWallData.timestamp <= WallCacheTTL) then
                            wallValue = isWallData.value
                        else
                            -- Recalc only if needed
                            RayParamsPool.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
                            local origin = Camera.CFrame.Position
                            local direction = (part.Position - origin).Unit * (part.Position - origin).Magnitude
                            local result = Workspace:Raycast(origin, direction, RayParamsPool)
                            local playerChar = part:FindFirstAncestorOfClass("Model")
                            wallValue = result and result.Instance and not result.Instance:IsDescendantOf(playerChar)
                            WallCheckCache[cacheKey] = {value = wallValue, timestamp = now}
                        end
                        if not SilentAimSettings.WallCheck or not wallValue then
                            table.insert(NearbyCache, {player = player, part = part, dist = dist})
                        end
                    end
                end
            end
        end
    end
    
    -- Insertion sort
    for i = 2, #NearbyCache do
        local j = i
        while j > 1 and NearbyCache[j].dist < NearbyCache[j-1].dist do
            local temp = NearbyCache[j]
            NearbyCache[j] = NearbyCache[j-1]
            NearbyCache[j-1] = temp
            j = j - 1
        end
    end
end

local function GetRandomBodyPart(player)
    local char = player.Character
    if not char then return "Head" end
    local randIndex = math.random(1, #BodyPartsPool)
    local randPartName = BodyPartsPool[randIndex]
    local part = char:FindFirstChild(randPartName)
    return part and randPartName or "Head"
end

local function FireVRMaxPower(targets)
    local now = tick()
    for _, t in ipairs(targets) do
        local playerName = t.player.Name
        if now - (AutoVRDebouncePool[playerName] or 0) < 0 then continue end
        AutoVRDebouncePool[playerName] = now
        
        task.spawn(function()
            local part = t.part
            if part and part.Parent then
                local args = {[1] = "VR", [2] = part}
                pcall(function()
                    Event:FireServer(unpack(args))
                end)
            end
        end)
    end
end

local function StartAutoVR(enabled, targetPlayer)
    if not enabled then
        for _, conn in pairs(AutoVRConnections) do
            if conn then pcall(conn.Disconnect, conn) end
        end
        AutoVRConnections = {}
        AutoVRDebouncePool = {}
        NearbyCache = {}
        WallCheckCache = {}
        return
    end
    
    local maxTargets = Options.MaxTargets.Value or 50
    
    local loopConn = RunService.Heartbeat:Connect(function()
        local now = tick()
        UpdateSpatialCache()
        
        local targets = {}
        if targetPlayer then
            local player = Players:FindFirstChild(targetPlayer)
            if IsValidTarget(player) then
                local bodyPart = GetRandomBodyPart(player)
                local part = player.Character:FindFirstChild(bodyPart)
                if part and part:IsA("BasePart") then
                    local cacheKey = player.Name .. "_" .. bodyPart
                    local isWallData = WallCheckCache[cacheKey]
                    local wallValue = true
                    if isWallData and type(isWallData) == "table" and (now - isWallData.timestamp <= WallCacheTTL) then
                        wallValue = isWallData.value
                    else
                        RayParamsPool.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
                        local origin = Camera.CFrame.Position
                        local direction = (part.Position - origin).Unit * (part.Position - origin).Magnitude
                        local result = Workspace:Raycast(origin, direction, RayParamsPool)
                        local playerChar = part:FindFirstAncestorOfClass("Model")
                        wallValue = result and result.Instance and not result.Instance:IsDescendantOf(playerChar)
                        WallCheckCache[cacheKey] = {value = wallValue, timestamp = now}
                    end
                    if not Toggles.AutoWallCheck.Value or not wallValue then
                        table.insert(targets, {player = player, part = part, dist = 0})
                    end
                end
            end
        else
            -- Auto mod fix: Force update and slice
            UpdateSpatialCache()  -- Double call for reliability
            for i = 1, math.min(#NearbyCache, maxTargets) do
                table.insert(targets, NearbyCache[i])
            end
        end
        
        if #targets > 0 then
            FireVRMaxPower(targets)
        end
    end)
    table.insert(AutoVRConnections, loopConn)
    
    local playerAddedConn = Players.PlayerAdded:Connect(function() NearbyCache = {}; CacheTimestamp = 0 end)
    local playerRemovingConn = Players.PlayerRemoving:Connect(function() NearbyCache = {}; CacheTimestamp = 0 end)
    table.insert(AutoVRConnections, playerAddedConn)
    table.insert(AutoVRConnections, playerRemovingConn)
    
    Options.AutoVRDistance.OnChanged:Connect(function() CacheTimestamp = 0 end)
    Options.MaxTargets.OnChanged:Connect(function() end)
    Options.AutoVRDebounce.OnChanged:Connect(function() end)
    Toggles.RandomBodyPart.OnChanged:Connect(function() end)
    Toggles.AutoWallCheck.OnChanged:Connect(function() WallCheckCache = {} end)
end

-- Sol Group UI
local SilentAimLeftGroup = Tabs['Silent Aim']:AddLeftGroupbox('Silent Aim Mod√ºlleri (MAX POWER)')

local SelectedTargetPlayer = nil
SilentAimLeftGroup:AddDropdown('TargetPlayerAuto', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Hedef Oyuncu Se√ßimi',
    Tooltip = 'Max power hedef (0 delay + multi-body)',
    Callback = function(value)
        SelectedTargetPlayer = value
        CacheTimestamp = 0
    end
})

SilentAimLeftGroup:AddToggle('SilentAimAuto', {
    Text = 'Otomatik Silent Aim (0 Delay Full)',
    Default = false,
    Tooltip = 'Yakƒ±n full scan + VR (fixed double update, 50 targets)',
    Risky = true,
    Callback = function(value)
        StartAutoVR(value, nil)
    end
})

SilentAimLeftGroup:AddToggle('TargetSilentAimAuto', {
    Text = 'Hedefli Silent Aim (0 Delay)',
    Default = false,
    Tooltip = 'Se√ßili hedefe full spam VR (pcall safe, table check)',
    Risky = true,
    Callback = function(value)
        if value and not SelectedTargetPlayer then
            Toggles.TargetSilentAimAuto:SetValue(false)
            return
        end
        StartAutoVR(value, SelectedTargetPlayer)
    end
})

SilentAimLeftGroup:AddDivider()

SilentAimLeftGroup:AddSlider('AutoVRDistance', {
    Text = 'Yakƒ±n Mesafe (Studs)',
    Default = 10000,
    Min = 50,
    Max = 20000,
    Rounding = 0,
    Tooltip = 'Full scan (fixed cache boolean index error)',
    Callback = function(value)
        SilentAimSettings.MaxDistance = value
        CacheTimestamp = 0
    end
})

SilentAimLeftGroup:AddSlider('MaxTargets', {
    Text = 'Max Hedef Sayƒ±sƒ±',
    Default = 50,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Tooltip = 'Spam batch (insertion fast, auto fix)',
    Callback = function() end
})

SilentAimLeftGroup:AddSlider('AutoVRDebounce', {
    Text = 'Per-Target Delay (s)',
    Default = 0,
    Min = 0,
    Max = 0.05,
    Rounding = 3,
    Tooltip = '0 = full spam (pool safe, no global)',
    Callback = function() end
})

SilentAimLeftGroup:AddToggle('RandomBodyPart', {
    Text = 'Multi-Body Hit (10 Pool)',
    Default = true,
    Tooltip = 'Random body (power + safe)',
    Callback = function(value) end
})

SilentAimLeftGroup:AddToggle('AutoWallCheck', {
    Text = 'Wall Check (Pooled)',
    Default = false,
    Tooltip = 'Optional (off for 0 delay, fixed table check)',
    Callback = function(value)
        SilentAimSettings.WallCheck = value
        if value then WallCheckCache = {} end
    end
})

local Tab = Window:AddTab("Performance")
local PerfGroup = Tab:AddLeftGroupbox("Optimization Settings")

-- =====================================
-- 1. LIGHTING OPTIMIZATION
-- =====================================
PerfGroup:AddToggle("LightingOptimization", {
    Text = "üß† Lighting Optimization",
    Default = false,
    Tooltip = "Disables heavy lighting effects for smoother gameplay.",
    Callback = function(state)
        if not state then return end
        task.spawn(function()
            local Lighting = game:GetService("Lighting")
            Lighting.GlobalShadows = false
            if Lighting.Technology ~= Enum.Technology.Compatibility then
                Lighting.Technology = Enum.Technology.Compatibility
            end

            local function destroyIfExists(className)
                for _, obj in ipairs(Lighting:GetChildren()) do
                    if obj.ClassName == className then
                        pcall(function() obj:Destroy() end)
                    end
                end
            end

            destroyIfExists("Atmosphere")
            destroyIfExists("Sky")

            for _, obj in ipairs(Lighting:GetChildren()) do
                if obj:IsA("BloomEffect") or obj:IsA("BlurEffect") or obj:IsA("ColorCorrectionEffect")
                or obj:IsA("DepthOfFieldEffect") or obj:IsA("SunRaysEffect") then
                    pcall(function() obj.Enabled = false end)
                end
            end

            local children = Lighting:GetChildren()
            for _, i in ipairs({7,8}) do
                local obj = children[i]
                if obj and obj.Enabled ~= nil then
                    pcall(function() obj.Enabled = false end)
                end
            end
        end)
    end
})

-- =====================================
-- 2. LIGHTING APPEARANCE (AUTO REFRESH)
-- =====================================
local FogLoop = nil
PerfGroup:AddToggle("LightingAppearance", {
    Text = "üå´Ô∏è Lighting Appearance (Auto Refresh)",
    Default = false,
    Tooltip = "Simplifies fog and lighting every 120 seconds automatically.",
    Callback = function(state)
        if FogLoop then
            FogLoop:Disconnect()
            FogLoop = nil
        end
        if state then
            local function applyFogSettings()
                local Lighting = game:GetService("Lighting")
                local targetColor = Color3.fromRGB(84, 84, 84)
                Lighting.Ambient = targetColor
                Lighting.ColorShift_Bottom = targetColor
                Lighting.ColorShift_Top = targetColor
                Lighting.OutdoorAmbient = targetColor
                Lighting.FogColor = targetColor
                Lighting.FogStart = 1e9
                Lighting.FogEnd = 1e10
            end

            applyFogSettings()
            FogLoop = game:GetService("RunService").Heartbeat:Connect(function()
                if not Library.Toggles.LightingAppearance.Value then
                    FogLoop:Disconnect()
                    FogLoop = nil
                end
            end)

            -- Yenileme d√∂ng√ºs√º (120 saniyede bir)
            task.spawn(function()
                while Library.Toggles.LightingAppearance.Value do
                    applyFogSettings()
                    task.wait(120)
                end
            end)
        end
    end
})

-- =====================================
-- 3. MATERIAL OPTIMIZATION
-- =====================================
PerfGroup:AddToggle("MaterialOptimization", {
    Text = "üß± Material Optimization",
    Default = false,
    Tooltip = "Applies SmoothPlastic for parts & uses 2022 materials safely.",
    Callback = function(state)
        if not state then return end
        task.defer(function()
            local MaterialService = game:GetService("MaterialService")
            MaterialService.Use2022Materials = true
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("BasePart") then
                    obj.Material = Enum.Material.SmoothPlastic
                end
            end
        end)
    end
})

-- ==============================
-- SECURITY TAB (ADVANCED THREAT DETECTION)
-- ==============================

local SecurityTab = Window:AddTab('Security')
local SecurityGroup = SecurityTab:AddLeftGroupbox('Threat Protection')

-- Varsayƒ±lan a√ßƒ±k toggle
SecurityGroup:AddToggle('EnableThreatDetection', {
    Text = 'Enable Threat Detection',
    Default = true,
    Tooltip = 'Automatically monitors and removes known threats.',
    Callback = function(state)
        if state then
            StartThreatDetection()
        end
    end
})

-- ==============================
-- THREAT DETECTION SYSTEM (WiaKorumaV1)
-- ==============================

-- Tehlikeli kullanƒ±cƒ± listesi (UserId -> ƒ∞sim)
local Watchlist = {
    [373061764] = "Laci2800",
    [721771859] = "ZeroBlueHawk",
    [83641955] = "Enphixo",
    [146462043] = "DJPelta",
    [966027914] = "CraftiCookie",
    [958389997] = "ofetark",
    [94467335] = "OmegaAnoobis",
    [70556831] = "DarkAgeSky",
    [430348004] = "nic10telf",
    [16161864] = "Gemini_II",
    [4610703127] = "MadCityUploader",
    [62346773] = "PixelatedCandy",
    [59967] = "taymaster",
    [28995792] = "TacticalFrostyy",
    [17897891] = "FamedChris",
    [116481933] = "Rootie_DaHoodie",
    [4426328480] = "AlreadyPrototype",
    [127514028] = "GohMaxPro",
    [1933300649] = "BornYeti",
    [371367028] = "odavido123",
    [33219560] = "peepguyx",
    [50549672] = "cjchurcher",
    [122673807] = "DatBrian",
    [870905642] = "Sushy647",
    [132717362] = "ZDMD",
    [983056393] = "TheRealConlord",
    [7750807951] = "LuiseNinja25",
    [1316039944] = "Itsakile",
    [9551275] = "ItsMeKlc",
    [3461560666] = "VesuIka",
    [3715956963] = "MadCityVigilante",
    [28962045] = "JennyBeanRose",
    [1647502388] = "M34T5",
    [3183391648] = "TatendaOtobon",
    [225259944] = "Dxmaqe",
    [731501956] = "Blackfyro",
    [146493490] = "JackSkywalker_JA",
    [608027295] = "Kryfist",
    [2678001507] = "SpyderSammy",
    [35479046] = "theloudscream",
    [211222858] = "atomikatz",
    [58387889] = "ilyannna",
    [191803941] = "BasicRobo",
    [30944240] = "TheHyb",
    [75151198] = "Lucid_Gemini",
    [92812719] = "KristjanSyc",
    [702252975] = "wilkkugod",
    [1131551308] = "yeahhhaaron",
    [153343142] = "MarioSonic2987",
    [24883415] = "i5k",
    [1805793503] = "Camjango",
    [749064269] = "AbsoluteDays",
    [1084171270] = "puggy_gaming123",
    [1169232379] = "NoodleGamingTV",
    [974223821] = "GHUZY",
    [109225997] = "EndoExternal",
    [74810618] = "1QueenOfAwesomeness",
    [885920088] = "Daijon_03",
    [68728334] = "Perhapz",
    [13629636] = "PointlessDoovid",
    [1216109201] = "Ender_III",
    [72579861] = "DarkAssassin860",
    [134262088] = "Drrakw",
    [943911395] = "FrostyTheNewbie",
    [157180286] = "sk3tchyt",
    [18394351] = "endlessfun",
}

-- Grup ID'si (√∂rnek olarak Mad City grubu)
local GROUP_ID = 3642592

local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local LocalPlayer = Players.LocalPlayer

-- Grup rol√ºn√º g√ºvenli ≈üekilde al
local function SafeGetGroupRole(player)
    if not GROUP_ID then return "Bilinmiyor" end
    local success, role = pcall(function()
        return player:GetRoleInGroup(GROUP_ID)
    end)
    return (success and role ~= "") and role or "Bilinmiyor"
end

-- Tehdit kontrol√º
local function HandleThreat(player)
    local role = SafeGetGroupRole(player)
    local name = player.Name
    local message = string.format("‚ö†Ô∏è Tehlike Tespit Edildi: %s (%s)", role, name)

    -- Uyarƒ± bildirimi
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = "WiaKorumaV1",
            Text = message,
            Duration = 8
        })
    end)

    -- Oyuncuyu at
    LocalPlayer:Kick(message)
end

-- Ana sistem
function StartThreatDetection()
    -- ≈ûimdiki oyuncularƒ± kontrol et
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and Watchlist[player.UserId] then
            HandleThreat(player)
        end
    end

    -- Yeni gelenleri izle
    Players.PlayerAdded:Connect(function(player)
        if Watchlist[player.UserId] then
            HandleThreat(player)
        end
    end)
end

-- UI a√ßƒ±lƒ±r a√ßƒ±lmaz aktif et (Varsayƒ±lan aktif toggle)
task.defer(function()
    if Toggles.EnableThreatDetection and Toggles.EnableThreatDetection.Value then
        StartThreatDetection()
    end
end)

local CombatTab = Window:AddTab('Bypass')
local CombatGroup = CombatTab:AddLeftGroupbox('Kamera Bypass')

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local cam = workspace.CurrentCamera
local plr = Players.LocalPlayer

local CameraLoopConnection = nil -- D√∂ng√º baƒülantƒ±sƒ±

-- Kamera karaktere kilitli kalsƒ±n fonksiyonu
local function StartCameraLock()
    -- √ñnce eski baƒülantƒ±yƒ± temizle
    if CameraLoopConnection then
        CameraLoopConnection:Disconnect()
        CameraLoopConnection = nil
    end

    -- Yeni baƒülantƒ± ba≈ülat
    CameraLoopConnection = RunService.RenderStepped:Connect(function()
        local char = plr.Character
        if not char then return end

        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid and cam.CameraSubject ~= humanoid then
            cam.CameraSubject = humanoid
        end
    end)
end

-- Toggle ekle
CombatGroup:AddToggle('LockCameraToCharacter', {
    Text = 'Kamera karaktere kilitli kalsƒ±n',
    Default = true,
    Tooltip = 'Kameranƒ±n karakterinizde sabit kalmasƒ±nƒ± saƒülar.',
    Callback = function(state)
        if state then
            StartCameraLock()
        elseif CameraLoopConnection then
            CameraLoopConnection:Disconnect()
            CameraLoopConnection = nil
        end
    end
})

-- UI a√ßƒ±ldƒ±ƒüƒ±nda toggle aktifse otomatik ba≈ülat
task.defer(function()
    if Toggles.LockCameraToCharacter and Toggles.LockCameraToCharacter.Value then
        StartCameraLock()
    end
end)

local PerfGroup = Tab:AddRightGroupbox("Optimization Settings")

PerfGroup:AddButton({
    Text = "Optimize Workspace (Silme)",
    Tooltip = "FPS artƒ±rmak i√ßin belirli objeleri g√ºvenli ≈üekilde siler.",
    Func = function()
        local Workspace = game:GetService("Workspace")
        local deletedObjects = {}
        local failedToDelete = {}

        -- G√ºvenli silinebilir yollar (sadece gerekli objeler)
        local objectPaths = {
            "Heists.JewelryStore.JewelryStore.Jewlery.Lasers",
            "Heists.JewelryStore.JewelryStore.SlideLaser",
            "Heists.JewelryStore.JewelryStore.SpinLaser",
            "Heists.JewelryStore.JewelryStore.SpinLaser3",
            "Heists.JewelryStore.JewelryStore.SpinLaser4",
            "Heists.JewelryStore.JewelryStore.SpinLaser5",
            "Heists.JewelryStore.EssentialParts.JewelryVent.Laser",
            "Heists.Bank.EssentialParts.Lasers",
            "Heists.Casino.EssentialParts.CasinoDoor.SpinLaser1",
            "Heists.Casino.EssentialParts.CasinoDoor.SpinLaser3",
            "Heists.Casino.Interior.Lasers",
            "Heists.Mall.Lasers",
            "CargoPlaneInterior.Parts.LaserLights",
            "CargoPlaneInterior.Parts.SpinLaser",
            "CargoPlaneInterior.Parts.SpinLaser2",
            "CargoPlaneInterior.Parts.SpinLaser3",
            "CargoPlaneInterior.Parts.Bomb",
            "ComputerStore.Lasers",
            "Ignore.WorldObjects.FireTrap",
            "Ignore.WorldObjects.SpikeSwing",
            "Ignore.WorldObjects.SpikeTrap",
            "Ignore.WorldObjects.Walls",
            "Ignore.WorldObjects.PrisonBarricade",
            "Club.DeathLights",
            "Destructibles.Folder",
            "Destructibles.Beach Chairs",
            "Destructibles.BeachLights",
            "Destructibles.Benches",
            "Destructibles.Boardwalk Lights",
            "Destructibles.Cacti",
            "Destructibles.Cones",
            "Destructibles.FireHydrants",
            "Destructibles.PalmTrees",
            "Destructibles.Patios",
            "Destructibles.StopSigns",
            "Destructibles.Streetlights",
            "Destructibles.mailboxes",
            "City.Foliage",
            "City.HouseRobbery",
            "City.Structures.bus station quack",
            "City.Waterfall",
            "Extra Builds",
            "Ignore.SurveillanceCamera",
            "LightningSpawns",
            "Light",
            "Guard",
            "GasStation.TreeWall",
            "GasStation.Structures",
            "GasStation.Pump",
            "GasStation.Barriers",
            "Furniture",
            "Futuristic Building1",
            "FoodSpawns",
            "FloorLight",
            "FerrisWheel.Rotate",
            "FakeTrain",
            "Dummy",
            "DanceParts",
            "CrimBaseIgnore",
            "Cluckers2",
            "Building Top Neon",
            "Blimp",
            "GlobalSounds",
            "Schwifty Studios",
            "Prison.Alarms"
        }

        local function destroyByPath(path)
            local current = Workspace
            for segment in string.gmatch(path, "[^%.]+") do
                current = current and current:FindFirstChild(segment)
                if not current then break end
            end
            if current and current:IsA("Instance") then
                local success, err = pcall(function()
                    current:Destroy()
                end)
                if success then
                    table.insert(deletedObjects, path)
                else
                    table.insert(failedToDelete, path)
                end
            else
                table.insert(failedToDelete, path)
            end
        end

        for _, path in ipairs(objectPaths) do
            destroyByPath(path)
        end

        Library:Notify(("‚úÖ %d obje silindi. ‚ö†Ô∏è %d silinemedi."):format(#deletedObjects, #failedToDelete), 8)

        -- ƒ∞stersen konsola yaz
        print("==‚úîÔ∏è Silinenler==")
        for _, obj in ipairs(deletedObjects) do
            print("‚úîÔ∏è", obj)
        end

        if #failedToDelete > 0 then
            warn("==‚ùå Silinemeyenler==")
            for _, obj in ipairs(failedToDelete) do
                warn("‚ùå", obj)
            end
        end
    end
})
