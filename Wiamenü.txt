local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local MarketplaceService = game:GetService("MarketplaceService")
local Camera = Workspace.CurrentCamera
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Event = ReplicatedStorage:WaitForChild("Event")

local LocalPlayer = Players.LocalPlayer
local Options = Library.Options
local Toggles = Library.Toggles

Library.ShowToggleFrameInKeybinds = true
Library.ShowCustomCursor = true
Library.NotifySide = "Left"

local gameName = MarketplaceService:GetProductInfo(game.PlaceId).Name
local Window = Library:CreateWindow({
    Title = 'ðŸ”¥ ' .. gameName .. ' ðŸ”¥',
    Center = true,
    AutoShow = true,
    Resizable = true,
    ShowCustomCursor = false,
    UnlockMouseWhileOpen = true,
    NotifySide = "Left",
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Hitbox = Window:AddTab('Hitbox'),
    Aimbot = Window:AddTab('Aimbot'),
    Combat = Window:AddTab('VisualðŸŽ¨'),
    ['Silent Aim'] = Window:AddTab('Silent Aim'),
    Vehicles = Window:AddTab('ðŸš— AraÃ§'),
    ['UI AyarlarÄ±'] = Window:AddTab('UI AyarlarÄ±'),
}

Library:SetWatermarkVisibility(false)

local HitboxSettings = {
    Enabled = false,
    Size = 8,
    Transparency = 0.7,
    BodyPart = "Head",
    Optimized = false,
}

local AimbotSettings = {
    Enabled = false,
    Mode = "Hold",
    Keybind = Enum.UserInputType.MouseButton2,
    FOV = 100,
    FOVVisible = true,
    FOVTransparency = 0.5,
    FOVColor = Color3.fromRGB(255, 255, 255),
    FOVThickness = 1,
    FOVNumSides = 64,
    MaxDistance = 1000,
    WallCheck = true,
    VisibleCheck = true,
    TeamCheck = true,
    TargetAimbot = false,
    TargetPlayer = nil,
    Triggerbot = false,
    TriggerbotWallCheck = true,
    TriggerbotVisibleCheck = true,
    TriggerbotTeamCheck = true,
    AimbotBodyPart = "Head",
}

local ActiveHitboxes = {}
local IgnoredPlayerName = "MAD_CITYAIMBOTLOL"
local Connections = {}
local HitboxTag = "HitboxExpanded"
local AimbotLocked = false
local AimbotTarget = nil
local FixedTargetPart = nil
local TriggerbotDebounce = false
local OptimizedConn = nil

local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Radius = AimbotSettings.FOV
FOVCircle.Thickness = AimbotSettings.FOVThickness
FOVCircle.Color = AimbotSettings.FOVColor
FOVCircle.Transparency = AimbotSettings.FOVTransparency
FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
FOVCircle.NumSides = AimbotSettings.FOVNumSides

local function ShouldExpandHitbox(player)
    if not player or player == LocalPlayer or player.Name == IgnoredPlayerName then
        return false
    end
    if not player.Team or not LocalPlayer.Team then
        return true
    end
    local playerTeam = player.Team.Name
    local localTeam = LocalPlayer.Team.Name
    if localTeam == "Prisoners" or localTeam == "Criminals" or localTeam == "Villains" then
        return playerTeam == "Police" or playerTeam == "Heroes"
    elseif localTeam == "Police" or localTeam == "Heroes" then
        return playerTeam == "Prisoners" or playerTeam == "Criminals" or playerTeam == "Villains"
    end
    return false
end

local function IsPlayerVisible(player, part)
    if not AimbotSettings.VisibleCheck or not part or not player or not player.Character then
        return true
    end
    local ignoreList = {LocalPlayer.Character, Camera}
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = ignoreList
    raycastParams.IgnoreWater = true
    raycastParams.RespectCanCollide = true
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin)
    local result = Workspace:Raycast(origin, direction, raycastParams)
    return result and result.Instance and result.Instance:IsDescendantOf(player.Character) and result.Instance.Transparency <= HitboxSettings.Transparency
end

local function IsPlayerBehindWall(player, part)
    if not AimbotSettings.WallCheck or not part or not player or not player.Character then
        return false
    end
    local ignoreList = {LocalPlayer.Character, Camera}
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = ignoreList
    raycastParams.IgnoreWater = true
    raycastParams.RespectCanCollide = true
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin)
    local result = Workspace:Raycast(origin, direction, raycastParams)
    return not (result and result.Instance and result.Instance:IsDescendantOf(player.Character))
end

local function IsWithinFOV(part)
    if not part or not AimbotSettings.FOVVisible then
        return true
    end
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then
        return false
    end
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local distance = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
    return distance <= AimbotSettings.FOV
end

local function IsInView(player)
    if not player or not player.Character then return false end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    local part = player.Character:FindFirstChild(HitboxSettings.BodyPart)
    if not humanoid or humanoid.Health <= 0 or not part then return false end
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then return false end
    local distance = (part.Position - Camera.CFrame.Position).Magnitude
    if distance > AimbotSettings.MaxDistance then return false end
    return true
end

local function GetClosestPlayer()
    if AimbotSettings.TargetAimbot and AimbotSettings.TargetPlayer then
        local player = Players:FindFirstChild(AimbotSettings.TargetPlayer)
        if player and player.Character and player.Character:IsDescendantOf(Workspace) then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local part = player.Character:FindFirstChild(AimbotSettings.AimbotBodyPart)
            if humanoid and humanoid.Health > 0 and part and part:IsA("BasePart") then
                if (not AimbotSettings.TeamCheck or ShouldExpandHitbox(player)) and
                   IsWithinFOV(part) and
                   not IsPlayerBehindWall(player, part) and
                   IsPlayerVisible(player, part) then
                    return player, part
                end
            end
        end
        return nil, nil
    end

    local closestPlayer, closestPart, closestDistance = nil, nil, math.huge
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName and player.Character and player.Character:IsDescendantOf(Workspace) then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local part = player.Character:FindFirstChild(AimbotSettings.AimbotBodyPart)
            if humanoid and humanoid.Health > 0 and part and part:IsA("BasePart") then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    local worldDist = (Camera.CFrame.Position - part.Position).Magnitude
                    if worldDist <= AimbotSettings.MaxDistance and screenDist < closestDistance and
                       (not AimbotSettings.TeamCheck or ShouldExpandHitbox(player)) and
                       IsWithinFOV(part) and
                       not IsPlayerBehindWall(player, part) and
                       IsPlayerVisible(player, part) then
                        closestPlayer, closestPart, closestDistance = player, part, screenDist
                    end
                end
            end
        end
    end
    return closestPlayer, closestPart
end

local function ApplyHitbox(player)
    if not HitboxSettings.Enabled or not ShouldExpandHitbox(player) or not player then
        return
    end
    local character = player.Character
    if not character or not character:IsDescendantOf(Workspace) then
        return
    end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        return
    end
    local part = character:FindFirstChild(HitboxSettings.BodyPart)
    if part and part:IsA("BasePart") and not ActiveHitboxes[player] then
        ActiveHitboxes[player] = {
            part = part,
            originalSize = part.Size,
            originalMassless = part.Massless,
            originalTransparency = part.Transparency,
            originalCanCollide = part.CanCollide
        }
        part.Size = Vector3.new(HitboxSettings.Size, HitboxSettings.Size, HitboxSettings.Size)
        part.Transparency = HitboxSettings.Transparency
        part.CanCollide = false
        part.Massless = true
        CollectionService:AddTag(part, HitboxTag)
    end
end

local function RestoreHitbox(player)
    if ActiveHitboxes[player] then
        local data = ActiveHitboxes[player]
        local part = data.part
        if part and part:IsA("BasePart") and part:IsDescendantOf(Workspace) then
            part.Size = data.originalSize
            part.Transparency = data.originalTransparency
            part.CanCollide = data.originalCanCollide
            part.Massless = data.originalMassless
            CollectionService:RemoveTag(part, HitboxTag)
        end
        ActiveHitboxes[player] = nil
    end
end

local function UpdateAllHitboxes()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName then
            RestoreHitbox(player)
            if HitboxSettings.Enabled and ShouldExpandHitbox(player) then
                ApplyHitbox(player)
            end
        end
    end
end

local function UpdateVisibleHitboxes()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName then
            if HitboxSettings.Enabled and ShouldExpandHitbox(player) and IsInView(player) then
                ApplyHitbox(player)
            else
                RestoreHitbox(player)
            end
        end
    end
end

local function ToggleOptimized(value)
    HitboxSettings.Optimized = value
    if value then
        if OptimizedConn then OptimizedConn:Disconnect() end
        OptimizedConn = RunService.Heartbeat:Connect(UpdateVisibleHitboxes)
        Library:Notify("Optimized Hitbox Modu EtkinleÅŸtirildi", 3)
    else
        if OptimizedConn then
            OptimizedConn:Disconnect()
            OptimizedConn = nil
        end
        UpdateAllHitboxes()
        Library:Notify("Optimized Hitbox Modu Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±", 3)
    end
end

local function SetupPlayer(player)
    if not player or player == LocalPlayer or player.Name == IgnoredPlayerName then
        return
    end
    Connections[player] = Connections[player] or {}

    local charAddedConn = player.CharacterAdded:Connect(function(character)
        if not HitboxSettings.Enabled or not ShouldExpandHitbox(player) then
            return
        end
        task.spawn(function()
            local timeout = tick() + 2
            while not character:IsDescendantOf(Workspace) or not character:FindFirstChild(HitboxSettings.BodyPart) or not character:FindFirstChildOfClass("Humanoid") do
                if tick() > timeout then
                    return
                end
                task.wait()
            end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                if not HitboxSettings.Optimized or IsInView(player) then
                    ApplyHitbox(player)
                end
            end
        end)
    end)
    table.insert(Connections[player], charAddedConn)

    if player.Character then
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local healthConn = humanoid.HealthChanged:Connect(function(health)
                if health > 0 and HitboxSettings.Enabled and ShouldExpandHitbox(player) then
                    if not HitboxSettings.Optimized or IsInView(player) then
                        task.defer(ApplyHitbox, player)
                    end
                else
                    RestoreHitbox(player)
                end
            end)
            table.insert(Connections[player], healthConn)

            local diedConn = humanoid.Died:Connect(function()
                RestoreHitbox(player)
            end)
            table.insert(Connections[player], diedConn)

            local stateConn = humanoid.StateChanged:Connect(function(_, newState)
                if newState == Enum.HumanoidStateType.Running and HitboxSettings.Enabled and ShouldExpandHitbox(player) then
                    if not HitboxSettings.Optimized or IsInView(player) then
                        task.defer(ApplyHitbox, player)
                    end
                end
            end)
            table.insert(Connections[player], stateConn)
        end

        local ancestryConn = player.Character.AncestryChanged:Connect(function()
            if player.Character and player.Character:IsDescendantOf(Workspace) and HitboxSettings.Enabled and ShouldExpandHitbox(player) then
                if not HitboxSettings.Optimized or IsInView(player) then
                    task.defer(ApplyHitbox, player)
                end
            end
        end)
        table.insert(Connections[player], ancestryConn)
    end

    if player.Character and player.Character:IsDescendantOf(Workspace) then
        if not HitboxSettings.Optimized or IsInView(player) then
            ApplyHitbox(player)
        end
    end

    local watchdogConn = RunService.Heartbeat:Connect(function()
        if not HitboxSettings.Enabled or not ShouldExpandHitbox(player) or not player:IsDescendantOf(game) then
            return
        end
        local character = player.Character
        if character and character:IsDescendantOf(Workspace) and character:FindFirstChildOfClass("Humanoid") and not ActiveHitboxes[player] then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                if not HitboxSettings.Optimized or IsInView(player) then
                    task.defer(ApplyHitbox, player)
                end
            end
        end
    end)
    table.insert(Connections[player], watchdogConn)
end

Players.PlayerAdded:Connect(function(player)
    SetupPlayer(player)
end)

Players.PlayerRemoving:Connect(function(player)
    RestoreHitbox(player)
    if Connections[player] then
        for _, conn in ipairs(Connections[player]) do
            conn:Disconnect()
        end
        Connections[player] = nil
    end
    if AimbotSettings.TargetPlayer == player.Name then
        AimbotSettings.TargetPlayer = nil
        AimbotLocked = false
        AimbotTarget = nil
        FixedTargetPart = nil
    end
end)

Workspace.ChildAdded:Connect(function(child)
    if child:IsA("Model") and child:FindFirstChildOfClass("Humanoid") then
        local player = Players:GetPlayerFromCharacter(child)
        if player and player ~= LocalPlayer and player.Name ~= IgnoredPlayerName and HitboxSettings.Enabled and ShouldExpandHitbox(player) then
            if not HitboxSettings.Optimized or IsInView(player) then
                task.defer(ApplyHitbox, player)
            end
        end
    end
end)

Workspace.ChildRemoved:Connect(function(child)
    if child:IsA("Model") then
        local player = Players:GetPlayerFromCharacter(child)
        if player then
            RestoreHitbox(player)
        end
    end
end)

local teamConn = LocalPlayer:GetPropertyChangedSignal("Team"):Connect(function()
    task.defer(function()
        if HitboxSettings.Optimized then
            UpdateVisibleHitboxes()
        else
            UpdateAllHitboxes()
        end
        Library:Notify("TakÄ±m " .. (LocalPlayer.Team and LocalPlayer.Team.Name or "Yok") .. " olarak deÄŸiÅŸtirildi, hitbox'lar gÃ¼ncellendi!", 3)
    end)
end)
table.insert(Connections, teamConn)

local aimbotConn = RunService.RenderStepped:Connect(function()
    if not AimbotSettings.Enabled then
        AimbotTarget = nil
        FixedTargetPart = nil
        FOVCircle.Visible = false
        return
    end

    FOVCircle.Radius = AimbotSettings.FOV
    FOVCircle.Transparency = AimbotSettings.FOVTransparency
    FOVCircle.Color = AimbotSettings.FOVColor
    FOVCircle.Thickness = AimbotSettings.FOVThickness
    FOVCircle.NumSides = AimbotSettings.FOVNumSides
    FOVCircle.Visible = AimbotSettings.FOVVisible
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    if not AimbotLocked then
        AimbotTarget = nil
        FixedTargetPart = nil
        return
    end

    if AimbotSettings.Mode == "Toggle" then
        if not FixedTargetPart or not FixedTargetPart.Parent or not FixedTargetPart:IsDescendantOf(Workspace) then
            local _, part = GetClosestPlayer()
            FixedTargetPart = part
        end
        AimbotTarget = FixedTargetPart
    else
        local _, part = GetClosestPlayer()
        AimbotTarget = part
    end

    if AimbotTarget then
        local player = Players:GetPlayerFromCharacter(AimbotTarget.Parent)
        local humanoid = AimbotTarget.Parent:FindFirstChildOfClass("Humanoid")
        if not player or not humanoid or humanoid.Health <= 0 or not IsWithinFOV(AimbotTarget) or IsPlayerBehindWall(player, AimbotTarget) or not IsPlayerVisible(player, AimbotTarget) then
            AimbotLocked = false
            FixedTargetPart = nil
            AimbotTarget = nil
            Library:Notify("Hedef geÃ§ersiz, aimbot kilidi aÃ§Ä±ldÄ±!", 3)
            return
        end
    else
        return
    end

    if AimbotTarget then
        local targetPos = AimbotTarget.Position
        local currentPos = Camera.CFrame.Position
        local newCFrame = CFrame.new(currentPos, targetPos)
        Camera.CFrame = newCFrame
    end

    if AimbotSettings.Triggerbot and not TriggerbotDebounce then
        TriggerbotDebounce = true
        local mousePos = UserInputService:GetMouseLocation()
        local ray = Camera:ViewportPointToRay(mousePos.X, mousePos.Y)
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
        local result = Workspace:Raycast(ray.Origin, ray.Direction * AimbotSettings.MaxDistance, raycastParams)
        if result and result.Instance and CollectionService:HasTag(result.Instance, HitboxTag) then
            local player = Players:GetPlayerFromCharacter(result.Instance.Parent)
            if player and (not AimbotSettings.TriggerbotTeamCheck or ShouldExpandHitbox(player)) and
               (not AimbotSettings.TriggerbotWallCheck or not IsPlayerBehindWall(player, result.Instance)) and
               (not AimbotSettings.TriggerbotVisibleCheck or IsPlayerVisible(player, result.Instance)) then
                if mouse1press and mouse1release then
                    mouse1press()
                    task.wait(0)
                    mouse1release()
                else
                    Library:Notify("Triggerbot bu executor'da desteklenmiyor!", 3)
                end
            end
        end
        task.delay(0.01, function() TriggerbotDebounce = false end)
    end
end)
table.insert(Connections, aimbotConn)

local inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or not AimbotSettings.Enabled then
        return
    end
    local isKeybind = (input.UserInputType == AimbotSettings.Keybind) or (input.KeyCode == AimbotSettings.Keybind)
    if isKeybind then
        if AimbotSettings.Mode == "Hold" then
            AimbotLocked = true
        elseif AimbotSettings.Mode == "Toggle" then
            AimbotLocked = not AimbotLocked
            if AimbotLocked then
                local _, part = GetClosestPlayer()
                FixedTargetPart = part
            else
                FixedTargetPart = nil
            end
            Library:Notify("Aimbot " .. (AimbotLocked and "Kilitlendi" or "Kilidi AÃ§Ä±ldÄ±"), 3)
        end
    end
end)
table.insert(Connections, inputConn)

local inputEndConn = UserInputService.InputEnded:Connect(function(input)
    if AimbotSettings.Mode == "Hold" then
        local isKeybind = (input.UserInputType == AimbotSettings.Keybind) or (input.KeyCode == AimbotSettings.Keybind)
        if isKeybind then
            AimbotLocked = false
            AimbotTarget = nil
        end
    end
end)
table.insert(Connections, inputEndConn)

for _, player in ipairs(Players:GetPlayers()) do
    SetupPlayer(player)
end

local LeftGroupBox = Tabs.Hitbox:AddLeftGroupbox('Hitbox Kontrolleri')

LeftGroupBox:AddToggle('HitboxToggle', {
    Text = 'Hitbox GeniÅŸleticiyi EtkinleÅŸtir',
    Default = false,
    Tooltip = 'Hitbox geniÅŸletmeyi aÃ§/kapat',
    Risky = true,
    Callback = function(Value)
        HitboxSettings.Enabled = Value
        if Value then
            if HitboxSettings.Optimized then
                ToggleOptimized(true)
            else
                UpdateAllHitboxes()
            end
        else
            for _, p in ipairs(Players:GetPlayers()) do
                RestoreHitbox(p)
            end
        end
        Library:Notify("Hitbox GeniÅŸletici " .. (Value and "EtkinleÅŸtirildi" or "Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±"), 3)
    end
})

LeftGroupBox:AddToggle('OptimizedHitboxToggle', {
    Text = 'Optimized Hitbox Modu',
    Default = false,
    Tooltip = 'YalnÄ±zca kameradaki oyunculara hitbox uygula (FPS optimizasyonu)',
    Callback = function(Value)
        ToggleOptimized(Value)
    end
})

LeftGroupBox:AddDropdown('BodyPartDropdown', {
    Values = {'Head', 'HumanoidRootPart'},
    Default = 'Head',
    Text = 'VÃ¼cut ParÃ§asÄ± SeÃ§',
    Tooltip = 'GeniÅŸletilecek vÃ¼cut parÃ§asÄ±nÄ± seÃ§',
    Callback = function(Value)
        for player, _ in pairs(ActiveHitboxes) do
            RestoreHitbox(player)
        end
        HitboxSettings.BodyPart = Value
        if HitboxSettings.Optimized then
            UpdateVisibleHitboxes()
        else
            UpdateAllHitboxes()
        end
        Library:Notify("VÃ¼cut ParÃ§asÄ± " .. Value .. " olarak ayarlandÄ±", 3)
    end
})

LeftGroupBox:AddSlider('HitboxSizeSlider', {
    Text = 'Hitbox Boyutu',
    Default = 8,
    Min = 5,
    Max = 10,
    Rounding = 1,
    Tooltip = 'Hitbox boyutunu ayarla',
    Callback = function(Value)
        HitboxSettings.Size = Value
        if HitboxSettings.Optimized then
            UpdateVisibleHitboxes()
        else
            UpdateAllHitboxes()
        end
        Library:Notify("Hitbox Boyutu " .. Value .. " olarak ayarlandÄ±", 3)
    end
})

LeftGroupBox:AddSlider('HitboxTransparencySlider', {
    Text = 'Hitbox ÅžeffaflÄ±ÄŸÄ±',
    Default = 0.7,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Tooltip = 'Hitbox ÅŸeffaflÄ±ÄŸÄ±nÄ± ayarla (0 = tamamen gÃ¶rÃ¼nmez)',
    Callback = function(Value)
        HitboxSettings.Transparency = Value
        if HitboxSettings.Optimized then
            UpdateVisibleHitboxes()
        else
            UpdateAllHitboxes()
        end
        Library:Notify("Hitbox ÅžeffaflÄ±ÄŸÄ± " .. Value .. " olarak ayarlandÄ±", 3)
    end
})

local AimbotGroupBox = Tabs.Aimbot:AddLeftGroupbox('Aimbot Kontrolleri')

AimbotGroupBox:AddToggle('AimbotToggle', {
    Text = 'Aimbot\'u EtkinleÅŸtir',
    Default = false,
    Tooltip = 'Aimbot fonksiyonunu aÃ§/kapat',
    Risky = true,
    Callback = function(Value)
        AimbotSettings.Enabled = Value
        AimbotLocked = false
        AimbotTarget = nil
        FixedTargetPart = nil
        Library:Notify("Aimbot " .. (Value and "EtkinleÅŸtirildi" or "Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±"), 3)
    end
})

AimbotGroupBox:AddDropdown('AimbotMode', {
    Values = {'Hold', 'Toggle'},
    Default = 'Hold',
    Text = 'Aimbot Modu',
    Tooltip = 'Aimbot modu seÃ§ (Hold veya Toggle)',
    Callback = function(Value)
        AimbotSettings.Mode = Value
        AimbotLocked = false
        AimbotTarget = nil
        FixedTargetPart = nil
        Library:Notify("Aimbot Modu " .. Value .. " olarak ayarlandÄ±", 3)
    end
})

AimbotGroupBox:AddLabel('Aimbot TuÅŸu'):AddKeyPicker('AimbotKeybind', {
    Default = 'MB2',
    Mode = 'Toggle',
    Text = 'Aimbot TuÅŸu',
    Tooltip = 'Hedeflere kilitlenmek iÃ§in tuÅŸ ata',
    Callback = function(Value)
        print('[cb] Aimbot TuÅŸu tÄ±klandÄ±!', Value)
    end,
    ChangedCallback = function(New)
        AimbotSettings.Keybind = New
        Library:Notify("Aimbot TuÅŸu " .. tostring(New) .. " olarak deÄŸiÅŸtirildi", 3)
    end
})

AimbotGroupBox:AddToggle('FOVToggle', {
    Text = 'FOV Ã‡emberini GÃ¶ster',
    Default = true,
    Tooltip = 'FOV Ã§emberi gÃ¶rÃ¼nÃ¼rlÃ¼ÄŸÃ¼nÃ¼ aÃ§/kapat',
    Callback = function(Value)
        AimbotSettings.FOVVisible = Value
        Library:Notify("FOV Ã‡emberi " .. (Value and "EtkinleÅŸtirildi" or "Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±"), 3)
    end
})

AimbotGroupBox:AddSlider('FOVSlider', {
    Text = 'FOV Boyutu',
    Default = 100,
    Min = 10,
    Max = 500,
    Rounding = 0,
    Tooltip = 'FOV Ã§emberi boyutunu ayarla',
    Callback = function(Value)
        AimbotSettings.FOV = Value
        Library:Notify("FOV Boyutu " .. Value .. " olarak ayarlandÄ±", 3)
    end
})

AimbotGroupBox:AddSlider('FOVTransparencySlider', {
    Text = 'FOV ÅžeffaflÄ±ÄŸÄ±',
    Default = 0.5,
    Min = 0.1,
    Max = 1,
    Rounding = 2,
    Tooltip = 'FOV Ã§emberi ÅŸeffaflÄ±ÄŸÄ±nÄ± ayarla',
    Callback = function(Value)
        AimbotSettings.FOVTransparency = Value
        Library:Notify("FOV ÅžeffaflÄ±ÄŸÄ± " .. Value .. " olarak ayarlandÄ±", 3)
    end
})

AimbotGroupBox:AddLabel('FOV Rengi'):AddColorPicker('FOVColorPicker', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'FOV Rengi',
    Callback = function(Value)
        AimbotSettings.FOVColor = Value
        Library:Notify("FOV Rengi deÄŸiÅŸtirildi", 3)
    end
})

AimbotGroupBox:AddSlider('FOVThicknessSlider', {
    Text = 'FOV KalÄ±nlÄ±ÄŸÄ±',
    Default = 1,
    Min = 1,
    Max = 5,
    Rounding = 0,
    Tooltip = 'FOV Ã§emberi kalÄ±nlÄ±ÄŸÄ±nÄ± ayarla',
    Callback = function(Value)
        AimbotSettings.FOVThickness = Value
        Library:Notify("FOV KalÄ±nlÄ±ÄŸÄ± " .. Value .. " olarak ayarlandÄ±", 3)
    end
})

AimbotGroupBox:AddSlider('FOVNumSidesSlider', {
    Text = 'FOV Kenar SayÄ±sÄ±',
    Default = 64,
    Min = 12,
    Max = 128,
    Rounding = 0,
    Tooltip = 'FOV Ã§emberi yumuÅŸaklÄ±ÄŸÄ±nÄ± ayarla (daha yÃ¼ksek = daha yumuÅŸak)',
    Callback = function(Value)
        AimbotSettings.FOVNumSides = Value
        Library:Notify("FOV Kenar SayÄ±sÄ± " .. Value .. " olarak ayarlandÄ±", 3)
    end
})

AimbotGroupBox:AddSlider('MaxDistanceSlider', {
    Text = 'Maksimum Mesafe',
    Default = 1000,
    Min = 100,
    Max = 5000,
    Rounding = 0,
    Tooltip = 'Aimbot maksimum mesafesini ayarla',
    Callback = function(Value)
        AimbotSettings.MaxDistance = Value
        Library:Notify("Maksimum Mesafe " .. Value .. " olarak ayarlandÄ±", 3)
    end
})

AimbotGroupBox:AddToggle('WallCheckToggle', {
    Text = 'Duvar KontrolÃ¼',
    Default = true,
    Tooltip = 'Aimbot iÃ§in duvar kontrolÃ¼nÃ¼ aÃ§/kapat',
    Callback = function(Value)
        AimbotSettings.WallCheck = Value
        Library:Notify("Duvar KontrolÃ¼ " .. (Value and "EtkinleÅŸtirildi" or "Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('VisibleCheckToggle', {
    Text = 'GÃ¶rÃ¼nÃ¼rlÃ¼k KontrolÃ¼',
    Default = true,
    Tooltip = 'Aimbot iÃ§in gÃ¶rÃ¼nÃ¼rlÃ¼k kontrolÃ¼nÃ¼ aÃ§/kapat',
    Callback = function(Value)
        AimbotSettings.VisibleCheck = Value
        Library:Notify("GÃ¶rÃ¼nÃ¼rlÃ¼k KontrolÃ¼ " .. (Value and "EtkinleÅŸtirildi" or "Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TeamCheckToggle', {
    Text = 'TakÄ±m KontrolÃ¼',
    Default = true,
    Tooltip = 'Aimbot iÃ§in takÄ±m kontrolÃ¼nÃ¼ aÃ§/kapat',
    Callback = function(Value)
        AimbotSettings.TeamCheck = Value
        Library:Notify("TakÄ±m KontrolÃ¼ " .. (Value and "EtkinleÅŸtirildi" or "Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TargetAimbotToggle', {
    Text = 'Hedef Aimbot',
    Default = false,
    Tooltip = 'Belirli bir oyuncuyu hedeflemeyi aÃ§/kapat',
    Callback = function(Value)
        AimbotSettings.TargetAimbot = Value
        if not Value then
            AimbotSettings.TargetPlayer = nil
        end
        Library:Notify("Hedef Aimbot " .. (Value and "EtkinleÅŸtirildi" or "Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±"), 3)
    end
})

AimbotGroupBox:AddDropdown('TargetPlayerDropdown', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Hedef Oyuncu',
    Tooltip = 'Hedeflenecek belirli oyuncuyu seÃ§',
    Callback = function(Value)
        AimbotSettings.TargetPlayer = Value
        Library:Notify("Hedef Oyuncu " .. Value .. " olarak ayarlandÄ±", 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotToggle', {
    Text = 'Triggerbot\'u EtkinleÅŸtir',
    Default = false,
    Tooltip = 'Triggerbot\'u aÃ§/kapat',
    Risky = true,
    Callback = function(Value)
        AimbotSettings.Triggerbot = Value
        Library:Notify("Triggerbot " .. (Value and "EtkinleÅŸtirildi" or "Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotWallCheckToggle', {
    Text = 'Triggerbot Duvar KontrolÃ¼',
    Default = true,
    Tooltip = 'Triggerbot iÃ§in duvar kontrolÃ¼nÃ¼ aÃ§/kapat',
    Callback = function(Value)
        AimbotSettings.TriggerbotWallCheck = Value
        Library:Notify("Triggerbot Duvar KontrolÃ¼ " .. (Value and "EtkinleÅŸtirildi" or "Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotVisibleCheckToggle', {
    Text = 'Triggerbot GÃ¶rÃ¼nÃ¼rlÃ¼k KontrolÃ¼',
    Default = true,
    Tooltip = 'Triggerbot iÃ§in gÃ¶rÃ¼nÃ¼rlÃ¼k kontrolÃ¼nÃ¼ aÃ§/kapat',
    Callback = function(Value)
        AimbotSettings.TriggerbotVisibleCheck = Value
        Library:Notify("Triggerbot GÃ¶rÃ¼nÃ¼rlÃ¼k KontrolÃ¼ " .. (Value and "EtkinleÅŸtirildi" or "Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotTeamCheckToggle', {
    Text = 'Triggerbot TakÄ±m KontrolÃ¼',
    Default = true,
    Tooltip = 'Triggerbot iÃ§in takÄ±m kontrolÃ¼nÃ¼ aÃ§/kapat',
    Callback = function(Value)
        AimbotSettings.TriggerbotTeamCheck = Value
        Library:Notify("Triggerbot TakÄ±m KontrolÃ¼ " .. (Value and "EtkinleÅŸtirildi" or "Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±"), 3)
    end
})

AimbotGroupBox:AddDropdown('AimbotBodyPartDropdown', {
    Values = {'Head', 'HumanoidRootPart', 'Torso', 'UpperTorso', 'LowerTorso'},
    Default = 'Head',
    Text = 'Aimbot Hedef VÃ¼cut ParÃ§asÄ±',
    Tooltip = 'Aimbot\'un kitleneceÄŸi vÃ¼cut parÃ§asÄ±nÄ± seÃ§',
    Callback = function(Value)
        AimbotSettings.AimbotBodyPart = Value
        Library:Notify("Aimbot Hedef VÃ¼cut ParÃ§asÄ± " .. Value .. " olarak ayarlandÄ±", 3)
    end
})

local MenuGroup = Tabs['UI AyarlarÄ±']:AddLeftGroupbox('MenÃ¼')
MenuGroup:AddToggle("KeybindMenuOpen", {
    Default = Library.KeybindFrame.Visible,
    Text = "TuÅŸ MenÃ¼sÃ¼nÃ¼ AÃ§",
    Callback = function(value) Library.KeybindFrame.Visible = value end
})
MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "Ã–zel Ä°mleÃ§",
    Default = false,
    Callback = function(Value) Library.ShowCustomCursor = Value end
})
MenuGroup:AddDivider()
MenuGroup:AddLabel("MenÃ¼ TuÅŸu"):AddKeyPicker("MenuKeybind", {
    Default = "RightShift",
    NoUI = true,
    Text = "MenÃ¼ tuÅŸu"
})
MenuGroup:AddButton("Kapat", function() Library:Unload() end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')
SaveManager:BuildConfigSection(Tabs['UI AyarlarÄ±'])
ThemeManager:ApplyToTab(Tabs['UI AyarlarÄ±'])
SaveManager:LoadAutoloadConfig()

local CombatGroup = Tabs.Combat:AddLeftGroupbox('ESP AraÃ§larÄ±')

local function setNameTagForPlayer(player, alwaysOnTop, maxDistance)
    local function apply(char)
        local nt = char:FindFirstChild("NameTag")
        if nt then
            nt.AlwaysOnTop = alwaysOnTop
            nt.MaxDistance = maxDistance
        end
    end

    if player.Character then
        apply(player.Character)
    end

    player.CharacterAdded:Connect(function(char)
        char:WaitForChild("NameTag", 10)
        apply(char)
        local nt = char:FindFirstChild("NameTag")
        if nt then
            nt:GetPropertyChangedSignal("AlwaysOnTop"):Connect(function()
                nt.AlwaysOnTop = alwaysOnTop
            end)
        end
    end)
end

CombatGroup:AddButton('ESP AÃ§', function()
    local Players = game:GetService("Players")
    for _, pl in ipairs(Players:GetPlayers()) do
        setNameTagForPlayer(pl, true, 10000)
    end
    Players.PlayerAdded:Connect(function(pl)
        setNameTagForPlayer(pl, true, 10000)
    end)
end)

CombatGroup:AddButton('ESP Kapat', function()
    local Players = game:GetService("Players")
    for _, pl in ipairs(Players:GetPlayers()) do
        setNameTagForPlayer(pl, false, 200)
    end
    Players.PlayerAdded:Connect(function(pl)
        setNameTagForPlayer(pl, false, 200)
    end)
end)

-- Silent Aim Tab
local SilentAimSettings = {
    Enabled = false,
    TargetMode = false,
    TargetPlayers = {},
    BodyPart = "Head",
    Keybind = Enum.UserInputType.MouseButton1,
    FOVVisible = false,
    FOVRadius = 100,
    FOVColor = Color3.fromRGB(255, 0, 0),
    FOVTransparency = 0.5,
    FOVThickness = 2,
    FOVNumSides = 64,
    MultiTarget = false,
    WallCheck = true,
    AggressiveVR = false,
    VRDebounce = 0,
    DebounceTime = 0,
    AggressiveDebounce = 0,
    MaxDistance = 500
}

local SilentAimFOVCircle = Drawing.new("Circle")
SilentAimFOVCircle.Visible = false
SilentAimFOVCircle.Radius = SilentAimSettings.FOVRadius
SilentAimFOVCircle.Thickness = SilentAimSettings.FOVThickness
SilentAimFOVCircle.Color = SilentAimSettings.FOVColor
SilentAimFOVCircle.Transparency = SilentAimSettings.FOVTransparency
SilentAimFOVCircle.Filled = false
SilentAimFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
SilentAimFOVCircle.NumSides = SilentAimSettings.FOVNumSides

local SilentAimConnections = {}
local FOVUpdateConn = nil
local InputConn = nil
local RayParamsCache = RaycastParams.new()
RayParamsCache.FilterType = Enum.RaycastFilterType.Exclude
RayParamsCache.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
RayParamsCache.IgnoreWater = true

local NearbyCache = {}
local CacheTimestamp = 0
local CacheInterval = 0.02

local function IsValidTarget(player)
    if not player or not player.Parent or player == LocalPlayer or player.Name == "MAD_CITYAIMBOTLOL" then return false end
    local character = player.Character
    if not character or not character.Parent then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    return ShouldExpandHitbox(player)
end

local function IsInSilentAimFOV(part)
    if not SilentAimSettings.FOVVisible then return true end
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then return false end
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
    return dist <= SilentAimSettings.FOVRadius
end

local function IsBehindWall(part)
    if not SilentAimSettings.WallCheck then return false end
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin)
    local mag = direction.Magnitude
    if mag <= 1 then return false end
    direction = direction.Unit * mag
    RayParamsCache.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    local result = Workspace:Raycast(origin, direction, RayParamsCache)
    local playerChar = part:FindFirstAncestorOfClass("Model")
    if not result or not result.Instance then return false end
    return not result.Instance:IsDescendantOf(playerChar)
end

local function GetSilentAimTargets()
    local targets = {}
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    for _, player in ipairs(Players:GetPlayers()) do
        if IsValidTarget(player) then
            local part = player.Character:FindFirstChild(SilentAimSettings.BodyPart)
            if part and part:IsA("BasePart") and IsInSilentAimFOV(part) and not IsBehindWall(part) then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    table.insert(targets, {player = player, part = part, dist = screenDist})
                end
            end
        end
    end
    table.sort(targets, function(a, b) return a.dist < b.dist end)
    return targets
end

local function GetCrosshairTarget()
    local mousePos = UserInputService:GetMouseLocation()
    local ray = Camera:ViewportPointToRay(mousePos.X, mousePos.Y)
    local result = Workspace:Raycast(ray.Origin, ray.Direction * 5000, RayParamsCache)
    if result and result.Instance then
        local hitModel = result.Instance:FindFirstAncestorOfClass("Model")
        if hitModel and hitModel:FindFirstChildOfClass("Humanoid") then
            local player = Players:GetPlayerFromCharacter(hitModel)
            if player and IsValidTarget(player) then
                local part = hitModel:FindFirstChild(SilentAimSettings.BodyPart)
                if part and part:IsA("BasePart") and not IsBehindWall(part) then
                    return {{player = player, part = part, dist = 0}}
                end
            end
        end
    end
    return GetSilentAimTargets()
end

local function GetNearbyTargets()
    local now = tick()
    if now - CacheTimestamp < CacheInterval then
        return NearbyCache
    end
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position or Camera.CFrame.Position
    local targets = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if IsValidTarget(player) and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local part = player.Character:FindFirstChild(SilentAimSettings.BodyPart)
            local rootPart = player.Character.HumanoidRootPart
            local dist = (rootPart.Position - myPos).Magnitude
            if dist <= SilentAimSettings.MaxDistance then
                if not IsBehindWall(part) then
                    table.insert(targets, {player = player, part = part, dist = dist})
                end
            end
        end
    end
    table.sort(targets, function(a, b) return a.dist < b.dist end)
    NearbyCache = targets
    CacheTimestamp = now
    return targets
end

local function FireVREvent(targets)
    local now = tick()
    local debounce = SilentAimSettings.AggressiveVR and SilentAimSettings.AggressiveDebounce or SilentAimSettings.DebounceTime
    if now - SilentAimSettings.VRDebounce < debounce then return end
    SilentAimSettings.VRDebounce = now
    for _, t in ipairs(targets) do
        task.spawn(function()
            local part = t.part
            if not part or not part.Parent then return end
            local args = {
                [1] = "VR",
                [2] = part
            }
            pcall(Event.FireServer, Event, unpack(args))
        end)
    end
end

local function ToggleFOVUpdate(enabled)
    if FOVUpdateConn then
        pcall(FOVUpdateConn.Disconnect, FOVUpdateConn)
        FOVUpdateConn = nil
    end
    if enabled and SilentAimSettings.Enabled then
        FOVUpdateConn = RunService.Stepped:Connect(function()
            if not SilentAimSettings.FOVVisible then
                SilentAimFOVCircle.Visible = false
                return
            end
            SilentAimFOVCircle.Radius = SilentAimSettings.FOVRadius
            SilentAimFOVCircle.Color = SilentAimSettings.FOVColor
            SilentAimFOVCircle.Transparency = SilentAimSettings.FOVTransparency
            SilentAimFOVCircle.Thickness = SilentAimSettings.FOVThickness
            SilentAimFOVCircle.NumSides = SilentAimSettings.FOVNumSides
            SilentAimFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            SilentAimFOVCircle.Visible = true
        end)
        table.insert(SilentAimConnections, FOVUpdateConn)
    else
        SilentAimFOVCircle.Visible = false
    end
end

InputConn = UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType ~= SilentAimSettings.Keybind and input.KeyCode ~= SilentAimSettings.Keybind then return end
    if not SilentAimSettings.Enabled and not SilentAimSettings.AggressiveVR then return end
    local targets
    if SilentAimSettings.TargetMode and next(SilentAimSettings.TargetPlayers) then
        targets = {}
        for targetName, _ in pairs(SilentAimSettings.TargetPlayers) do
            local targetPlayer = Players:FindFirstChild(targetName)
            if IsValidTarget(targetPlayer) then
                local part = targetPlayer.Character:FindFirstChild(SilentAimSettings.BodyPart)
                if part and part:IsA("BasePart") and not IsBehindWall(part) then
                    table.insert(targets, {player = targetPlayer, part = part, dist = 0})
                end
            end
        end
    elseif SilentAimSettings.AggressiveVR then
        targets = GetNearbyTargets()
        if not SilentAimSettings.MultiTarget then
            targets = {targets[1]}
        end
    else
        if SilentAimSettings.FOVVisible then
            targets = GetSilentAimTargets()
        else
            targets = GetCrosshairTarget()
        end
        if not SilentAimSettings.MultiTarget then
            targets = {targets[1]}
        end
    end
    if targets and #targets > 0 then
        FireVREvent(targets)
    end
end)
table.insert(SilentAimConnections, InputConn)

local SilentAimBox = Tabs['Silent Aim']:AddLeftGroupbox('Silent Aim')

SilentAimBox:AddToggle('SilentAimEnabled', {
    Text = 'Silent Aim Etkin',
    Default = false,
    Tooltip = 'Standart Silent Aim aÃ§/kapat',
    Risky = true,
    Callback = function(value)
        SilentAimSettings.Enabled = value
        if value then
            ToggleFOVUpdate(SilentAimSettings.FOVVisible)
        else
            ToggleFOVUpdate(false)
        end
    end
})

SilentAimBox:AddToggle('TargetModeSilent', {
    Text = 'Sadece Hedef Modu',
    Default = false,
    Tooltip = 'AÃ§Ä±k: Ã‡oklu hedeflere VR, KapalÄ±: FOV/Multi',
    Callback = function(value)
        SilentAimSettings.TargetMode = value
    end
})

SilentAimBox:AddDropdown('TargetPlayerSilent', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Hedef Oyuncular',
    Multi = true,
    Tooltip = 'Ã‡oklu seÃ§ (Sadece Hedef Modu\'nda)',
    Callback = function(value)
        SilentAimSettings.TargetPlayers = value
    end
})

SilentAimBox:AddDropdown('BodyPartSilent', {
    Values = {'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso', 'LeftUpperArm', 'RightUpperArm', 'LeftLowerArm', 'RightLowerArm', 'LeftHand', 'RightHand', 'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerLeg', 'RightLowerLeg', 'LeftFoot', 'RightFoot'},
    Default = 'Head',
    Text = 'VÃ¼cut ParÃ§asÄ±',
    Tooltip = 'VR iÃ§in',
    Callback = function(value)
        SilentAimSettings.BodyPart = value
    end
})

SilentAimBox:AddLabel('Tetik TuÅŸu'):AddKeyPicker('SilentAimKey', {
    Default = 'MouseButton1',
    Mode = 'Press',
    Text = 'VR TuÅŸu',
    NoUI = true,
    Tooltip = 'BasÄ±nca VR gÃ¶nder',
    ChangedCallback = function(newKey)
        SilentAimSettings.Keybind = newKey
    end
})

SilentAimBox:AddDivider()

SilentAimBox:AddToggle('FOVSilentVisible', {
    Text = 'FOV Ã‡emberi',
    Default = false,
    Tooltip = 'FOV gÃ¶ster (iÃ§indekilere VR)',
    Callback = function(value)
        SilentAimSettings.FOVVisible = value
        ToggleFOVUpdate(value)
    end
})

SilentAimBox:AddSlider('FOVRadiusSilent', {
    Text = 'FOV YarÄ±Ã§ap',
    Default = 100,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Callback = function(value)
        SilentAimSettings.FOVRadius = value
    end
})

SilentAimBox:AddLabel('FOV Rengi'):AddColorPicker('FOVColorSilent', {
    Default = Color3.fromRGB(255, 0, 0),
    Title = 'FOV Rengi',
    Callback = function(color)
        SilentAimSettings.FOVColor = color
    end
})

SilentAimBox:AddSlider('FOVSidesSilent', {
    Text = 'FOV Kenarlar',
    Default = 64,
    Min = 4,
    Max = 128,
    Rounding = 0,
    Callback = function(value)
        SilentAimSettings.FOVNumSides = value
    end
})

SilentAimBox:AddDivider()

SilentAimBox:AddToggle('MultiTargetSilent', {
    Text = 'Multi Target',
    Default = false,
    Tooltip = 'TÃ¼m FOV\'ye VR',
    Callback = function(value)
        SilentAimSettings.MultiTarget = value
    end
})

SilentAimBox:AddToggle('WallCheckSilent', {
    Text = 'Duvar KontrolÃ¼',
    Default = true,
    Tooltip = 'Duvar arkasÄ±na VR gÃ¶nderme',
    Callback = function(value)
        SilentAimSettings.WallCheck = value
    end
})

SilentAimBox:AddToggle('AggressiveVRSilent', {
    Text = 'Silent Aim AGRESÄ°F',
    Default = false,
    Tooltip = 'AÃ§Ä±k: YakÄ±ndaki herkese anÄ±nda VR (duvar kontrolÃ¼ etkiler, baÄŸÄ±msÄ±z Ã§alÄ±ÅŸÄ±r)',
    Risky = true,
    Callback = function(value)
        SilentAimSettings.AggressiveVR = value
    end
})

SilentAimBox:AddSlider('AggressiveDistance', {
    Text = 'AGRESÄ°F Mesafe',
    Default = 500,
    Min = 100,
    Max = 2000,
    Rounding = 0,
    Callback = function(value)
        SilentAimSettings.MaxDistance = value
    end
})

SilentAimBox:AddSlider('DebounceSilent', {
    Text = 'Normal Debounce (s)',
    Default = 0,
    Min = 0,
    Max = 0.5,
    Rounding = 3,
    Callback = function(value)
        SilentAimSettings.DebounceTime = value
    end
})

SilentAimBox:AddSlider('AggressiveDebounce', {
    Text = 'AGRESÄ°F Debounce (s)',
    Default = 0,
    Min = 0,
    Max = 0.1,
    Rounding = 3,
    Callback = function(value)
        SilentAimSettings.AggressiveDebounce = value
    end
})

-- Eksik StartAutoVR fonksiyonu (otomatik VR loop'u)
local AutoVRConnections = {}
local AutoVRDebounce = {}
local function StartAutoVR(enabled, targetPlayer)
    if not enabled then
        for _, conn in pairs(AutoVRConnections) do
            if conn then conn:Disconnect() end
        end
        AutoVRConnections = {}
        AutoVRDebounce = {}
        return
    end

    local lastVRTime = 0
    local debounceTime = 0.1 -- VarsayÄ±lan debounce
    local loopConn = RunService.Heartbeat:Connect(function()
        local now = tick()
        if now - lastVRTime < debounceTime then return end
        lastVRTime = now

        local targets = {}
        if targetPlayer then
            local player = Players:FindFirstChild(targetPlayer)
            if IsValidTarget(player) then
                local part = player.Character:FindFirstChild(SilentAimSettings.BodyPart)
                if part then
                    table.insert(targets, {player = player, part = part})
                end
            end
        else
            local nearby = GetNearbyTargets()
            for _, t in ipairs(nearby) do
                table.insert(targets, t)
            end
        end

        if #targets > 0 then
            FireVREvent(targets)
        end
    end)
    table.insert(AutoVRConnections, loopConn)
end

local SelectedTargetPlayer = nil
local SilentAimLeftGroup = Tabs['Silent Aim']:AddLeftGroupbox('Silent Aim ModÃ¼lleri')

SilentAimLeftGroup:AddDropdown('TargetPlayerAuto', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Hedef Oyuncu SeÃ§imi',
    Tooltip = 'Silent Aim iÃ§in belirli bir oyuncuyu hedefleyin',
    Callback = function(value)
        SelectedTargetPlayer = value
    end
})

SilentAimLeftGroup:AddToggle('SilentAimAuto', {
    Text = 'Otomatik Silent Aim (YakÄ±n Oyuncular)',
    Default = false,
    Tooltip = 'YakÄ±ndaki oyunculara otomatik Silent Aim uygular (stabil ve gÃ¼venli)',
    Callback = function(value)
        StartAutoVR(value, nil)
    end
})

SilentAimLeftGroup:AddToggle('TargetSilentAimAuto', {
    Text = 'Hedefli Silent Aim',
    Default = false,
    Tooltip = 'SeÃ§ili oyuncuya sÃ¼rekli Silent Aim uygular (yÃ¼ksek doÄŸruluk)',
    Callback = function(value)
        StartAutoVR(value, SelectedTargetPlayer)
    end
})

local SilentAimRightGroup = Tabs['Silent Aim']:AddRightGroupbox('AraÃ§ Teker Patlatma')

local WheelParts = {'FrontLeftWheel', 'FrontRightWheel', 'BackLeftWheel', 'BackRightWheel', 'Random'}
local SelectedWheel = 'FrontLeftWheel'

SilentAimRightGroup:AddDropdown('WheelPartDropdown', {
    Values = WheelParts,
    Default = 1,
    Text = 'Teker ParÃ§asÄ± SeÃ§imi',
    Tooltip = 'PatlatÄ±lacak teker parÃ§asÄ±nÄ± seÃ§in (Random: Rastgele mevcut teker)',
    Callback = function(Value)
        SelectedWheel = Value
    end
})

local WheelFOVCircle = Drawing.new("Circle")
WheelFOVCircle.Visible = false
WheelFOVCircle.Radius = 100
WheelFOVCircle.Thickness = 2
WheelFOVCircle.Color = Color3.fromRGB(0, 255, 0)
WheelFOVCircle.Transparency = 0.5
WheelFOVCircle.Filled = false
WheelFOVCircle.NumSides = 64
WheelFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

local WheelFOVEnabled = false
local WheelFOVUpdateConn = nil
local WheelShottyCacheTime = 0
local WheelFOVCache = {}
local WheelFOVCacheTime = 0
local WheelFOVCacheInterval = 0.01 -- Throttle artÄ±rdÄ±m, FPS iÃ§in
local WheelRayCount = 12

local BlacklistPlayers = {"MAD_CITYAIMBOTLOL", "Emiraganz"}

local function IsBlacklisted(vehName)
    local playerName = vehName:match("^(.-)'s Vehicle$")
    return table.find(BlacklistPlayers, playerName) ~= nil
end

local function GetSmartRandomWheel(veh)
    local availableWheels = {}
    for _, wheelName in ipairs({'FrontLeftWheel', 'FrontRightWheel', 'BackLeftWheel', 'BackRightWheel'}) do
        local wheel = veh:FindFirstChild(wheelName, true)
        if wheel and wheel:IsA("BasePart") and wheel.Parent and wheel.Parent == veh then
            table.insert(availableWheels, wheel)
        end
    end
    if #availableWheels > 0 then
        return availableWheels[math.random(1, #availableWheels)]
    end
    return nil
end

local function FireShottySafe(wheel)
    if wheel and wheel.Parent then
        local args = { [1] = "SHOTTY", [2] = wheel }
        pcall(Event.FireServer, Event, unpack(args))
    end
end

local function ToggleWheelFOV(enabled)
    WheelFOVEnabled = enabled
    if WheelFOVUpdateConn then
        WheelFOVUpdateConn:Disconnect()
        WheelFOVUpdateConn = nil
    end
    if enabled then
        WheelFOVUpdateConn = RunService.RenderStepped:Connect(function()
            if not WheelFOVEnabled then 
                WheelFOVCircle.Visible = false
                return 
            end
            local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            WheelFOVCircle.Position = center
            WheelFOVCircle.Radius = Options.WheelFOVRadius and Options.WheelFOVRadius.Value or 100
            WheelFOVCircle.Color = Options.WheelFOVColor and Options.WheelFOVColor.Value or Color3.fromRGB(0, 255, 0)
            WheelFOVCircle.NumSides = Options.FOVSidesSilent and Options.FOVSidesSilent.Value or 64
            WheelFOVCircle.Visible = true
            
            local now = tick()
            if now - WheelShottyCacheTime < 0.03 then return end
            WheelShottyCacheTime = now
            local cacheHits = 0
            for i = #WheelFOVCache, 1, -1 do
                local hit = WheelFOVCache[i]
                if now - hit.timestamp < 0.1 then
                    if hit.wheel and hit.wheel.Parent then
                        local veh = hit.veh
                        if not IsBlacklisted(veh.Name) then
                            FireShottySafe(hit.wheel)
                            cacheHits = cacheHits + 1
                        end
                    else
                        table.remove(WheelFOVCache, i)
                    end
                else
                    table.remove(WheelFOVCache, i)
                end
            end
            if cacheHits > 0 then return end
            
            if now - WheelFOVCacheTime < WheelFOVCacheInterval then return end
            WheelFOVCacheTime = now
            WheelFOVCache = {}
            
            local mousePos = UserInputService:GetMouseLocation()
            local baseRay = Camera:ViewportPointToRay(mousePos.X, mousePos.Y)
            local fovAngle = math.rad((Options.WheelFOVRadius and Options.WheelFOVRadius.Value or 100) * 0.3)
            local stepAngle = fovAngle / (WheelRayCount - 1)
            
            local objectSelection = workspace:FindFirstChild("ObjectSelection")
            if not objectSelection then return end
            
            for i = 1, WheelRayCount do
                local angleOffset = (i - (WheelRayCount + 1)/2) * stepAngle
                local rot = CFrame.Angles(0, angleOffset, 0)
                local dir = baseRay.Direction * rot
                local ray = Ray.new(baseRay.Origin, dir.Unit * 1000)
                
                local rayParams = RaycastParams.new()
                rayParams.FilterType = Enum.RaycastFilterType.Exclude
                rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
                rayParams.IgnoreWater = true
                local result = Workspace:Raycast(ray.Origin, dir.Unit * 1000, rayParams)
                
                if result and result.Instance then
                    local veh = result.Instance:FindFirstAncestor(function(child)
                        return child:IsA("Model") and child.Name:match(".*'s Vehicle")
                    end)
                    local localVehName = LocalPlayer.Name .. "'s Vehicle"
                    if veh and veh.Name ~= localVehName and not IsBlacklisted(veh.Name) then
                        local wheel = SelectedWheel == 'Random' and GetSmartRandomWheel(veh) or veh:FindFirstChild(SelectedWheel, true)
                        if wheel then
                            FireShottySafe(wheel)
                            table.insert(WheelFOVCache, {veh = veh, wheel = wheel, timestamp = now})
                        end
                    end
                end
            end
        end)
        table.insert(SilentAimConnections, WheelFOVUpdateConn)
    else
        WheelFOVCircle.Visible = false
        WheelFOVCache = {}
    end
end

SilentAimRightGroup:AddToggle('WheelFOVToggle', {
    Text = 'Teker FOV Ã‡emberi',
    Default = false,
    Tooltip = 'FOV iÃ§indeki tekerlere otomatik SHOTTY (kendi ve blacklist araÃ§larÄ± yoksayar)',
    Callback = function(value)
        ToggleWheelFOV(value)
    end
})

SilentAimRightGroup:AddSlider('WheelFOVRadius', {
    Text = 'Teker FOV YarÄ±Ã§apÄ±',
    Default = 100,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Tooltip = 'FOV Ã§emberinin boyutunu ayarlayÄ±n (daha bÃ¼yÃ¼k = daha geniÅŸ kapsama)',
    Callback = function() end
})

SilentAimRightGroup:AddLabel('Teker FOV Rengi'):AddColorPicker('WheelFOVColor', {
    Default = Color3.fromRGB(0, 255, 0),
    Title = 'Teker FOV Rengi',
    Tooltip = 'FOV Ã§emberinin rengini Ã¶zelleÅŸtirin',
    Callback = function() end
})

local TekerSilentDebounce = {}
local TekerKeybindConn = nil
local TekerTargetLoop = nil
local SelectedTekerTarget = nil
local NearbyVehCache = {}
local NearbyVehCacheTime = 0
local NearbyVehInterval = 0.01 -- Throttle
local TekerNearbyFOVEnabled = false
local TekerNearbyFOVCircle = Drawing.new("Circle")
TekerNearbyFOVCircle.Visible = false
TekerNearbyFOVCircle.Radius = 120
TekerNearbyFOVCircle.Thickness = 2
TekerNearbyFOVCircle.Color = Color3.fromRGB(255, 165, 0)
TekerNearbyFOVCircle.Transparency = 0.6
TekerNearbyFOVCircle.Filled = false
TekerNearbyFOVCircle.NumSides = 64
TekerNearbyFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

local function GetVehicleRoot(veh)
    local body = veh:FindFirstChild("Body")
    if body and body:IsA("BasePart") then return body end
    local chassis = veh:FindFirstChild("CarChassis") or veh:FindFirstChild("Chassis")
    if chassis and chassis:IsA("BasePart") then return chassis end
    local wheels = {}
    for _, wName in ipairs({'FrontLeftWheel', 'FrontRightWheel', 'BackLeftWheel', 'BackRightWheel'}) do
        local w = veh:FindFirstChild(wName)
        if w and w:IsA("BasePart") then table.insert(wheels, w.Position) end
    end
    if #wheels >= 2 then
        local avgPos = Vector3.new(0,0,0)
        for _, pos in ipairs(wheels) do avgPos = avgPos + pos end
        return {Position = avgPos / #wheels}
    end
    return nil
end

local function GetNearbyVehicles(myPos)
    local now = tick()
    if now - NearbyVehCacheTime < NearbyVehInterval then return NearbyVehCache end
    local objectSelection = workspace:FindFirstChild("ObjectSelection")
    if not objectSelection then return {} end
    local vehicles = {}
    local localVehName = LocalPlayer.Name .. "'s Vehicle"
    for _, obj in ipairs(objectSelection:GetChildren()) do
        if obj.Name:match(".*'s Vehicle") and obj.Name ~= localVehName and not IsBlacklisted(obj.Name) then
            local root = GetVehicleRoot(obj)
            if root then
                local dist = (root.Position - myPos).Magnitude
                if dist <= 400 then
                    table.insert(vehicles, {veh = obj, root = root, dist = dist})
                end
            end
        end
    end
    table.sort(vehicles, function(a, b) return a.dist < b.dist end)
    NearbyVehCache = vehicles
    NearbyVehCacheTime = now
    return vehicles
end

local function IsWheelInNearbyFOV(wheel)
    if not TekerNearbyFOVEnabled then return true end
    local screenPos, onScreen = Camera:WorldToViewportPoint(wheel.Position)
    if not onScreen then return false end
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
    return dist <= TekerNearbyFOVCircle.Radius
end

SilentAimRightGroup:AddDropdown('TekerTargetPlayer', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Teker Hedef Oyuncu',
    Tooltip = 'Belirli bir oyuncunun aracÄ±na SHOTTY gÃ¶nderin (blacklist hariÃ§)',
    Callback = function(value)
        SelectedTekerTarget = value
    end
})

SilentAimRightGroup:AddToggle('TekerSilentTarget', {
    Text = 'Hedefli Teker Patlatma',
    Default = false,
    Tooltip = 'SeÃ§ili oyuncunun aracÄ±na otomatik SHOTTY (kendi ve blacklist araÃ§larÄ± yoksayar)',
    Callback = function(value)
        if value and SelectedTekerTarget then
            if TekerTargetLoop then TekerTargetLoop:Disconnect() end
            local lastTekerCheck = 0
            TekerTargetLoop = RunService.RenderStepped:Connect(function()
                if not value or not SelectedTekerTarget then return end
                local now = tick()
                if now - lastTekerCheck < 0.05 then return end
                lastTekerCheck = now
                local objectSelection = workspace:FindFirstChild("ObjectSelection")
                if not objectSelection then return end
                local vehName = SelectedTekerTarget .. "'s Vehicle"
                local localVehName = LocalPlayer.Name .. "'s Vehicle"
                local veh = objectSelection:FindFirstChild(vehName)
                if veh and veh.Name ~= localVehName and not IsBlacklisted(veh.Name) then
                    local wheel = SelectedWheel == 'Random' and GetSmartRandomWheel(veh) or veh:FindFirstChild(SelectedWheel, true)
                    if wheel then
                        local wheelKey = vehName .. "_" .. wheel.Name
                        if now - (TekerSilentDebounce[wheelKey] or 0) > 0.12 then
                            TekerSilentDebounce[wheelKey] = now
                            FireShottySafe(wheel)
                        end
                    end
                end
            end)
            table.insert(SilentAimConnections, TekerTargetLoop)
        else
            if TekerTargetLoop then
                TekerTargetLoop:Disconnect()
                TekerTargetLoop = nil
            end
        end
    end
})

local TekerKeybind = Enum.KeyCode.Q
SilentAimRightGroup:AddLabel('Teker Keybind'):AddKeyPicker('TekerKeybindPicker', {
    Default = 'Q',
    Mode = 'Press',
    Text = 'YakÄ±n Teker Tetik TuÅŸu',
    NoUI = true,
    Tooltip = 'YakÄ±ndaki araÃ§lara SHOTTY gÃ¶ndermek iÃ§in tuÅŸ atayÄ±n (blacklist hariÃ§)',
    ChangedCallback = function(newKey)
        TekerKeybind = newKey
    end
})

SilentAimRightGroup:AddToggle('TekerSilentNearby', {
    Text = 'YakÄ±n AraÃ§ Teker Patlatma',
    Default = false,
    Tooltip = 'TuÅŸa basÄ±nca yakÄ±ndaki araÃ§lara SHOTTY (kendi ve blacklist araÃ§larÄ± yoksayar, FOV sÄ±nÄ±rlÄ±)',
    Callback = function(value)
        if TekerKeybindConn then
            TekerKeybindConn:Disconnect()
            TekerKeybindConn = nil
        end
        if value then
            TekerKeybindConn = UserInputService.InputBegan:Connect(function(input, processed)
                if processed then return end
                if (input.KeyCode == TekerKeybind or input.UserInputType == TekerKeybind) then
                    local myPos = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position) or Vector3.new(0,0,0)
                    local vehicles = GetNearbyVehicles(myPos)
                    local now = tick()
                    local maxShots = 8
                    local localVehName = LocalPlayer.Name .. "'s Vehicle"
                    for i = 1, math.min(#vehicles, maxShots) do
                        task.spawn(function()
                            local vData = vehicles[i]
                            local veh = vData.veh
                            if veh.Name == localVehName or IsBlacklisted(veh.Name) then return end
                            local vehName = veh.Name
                            local wheel = SelectedWheel == 'Random' and GetSmartRandomWheel(veh) or veh:FindFirstChild(SelectedWheel, true)
                            if wheel and IsWheelInNearbyFOV(wheel) then
                                local wheelKey = vehName .. "_" .. wheel.Name
                                if now - (TekerSilentDebounce[wheelKey] or 0) > 0.1 then
                                    TekerSilentDebounce[wheelKey] = now
                                    FireShottySafe(wheel)
                                end
                            end
                        end)
                    end
                end
            end)
            table.insert(SilentAimConnections, TekerKeybindConn)
        end
    end
})

SilentAimRightGroup:AddToggle('TekerNearbyFOV', {
    Text = 'YakÄ±n Teker FOV SÄ±nÄ±rlÄ±',
    Default = false,
    Tooltip = 'YakÄ±n teker patlatmayÄ± FOV ile sÄ±nÄ±rlayÄ±n (sadece Ã§ember iÃ§indekiler, blacklist hariÃ§)',
    Callback = function(value)
        TekerNearbyFOVEnabled = value
        TekerNearbyFOVCircle.Visible = value
        TekerNearbyFOVCircle.Radius = Options.TekerNearbyFOVRadius and Options.TekerNearbyFOVRadius.Value or 120
        TekerNearbyFOVCircle.Color = Options.TekerNearbyFOVColor and Options.TekerNearbyFOVColor.Value or Color3.fromRGB(255, 165, 0)
    end
})

SilentAimRightGroup:AddSlider('TekerNearbyFOVRadius', {
    Text = 'YakÄ±n Teker FOV YarÄ±Ã§apÄ±',
    Default = 120,
    Min = 50,
    Max = 600,
    Rounding = 0,
    Tooltip = 'YakÄ±n teker FOV Ã§emberinin boyutunu ayarlayÄ±n (daha bÃ¼yÃ¼k = daha geniÅŸ kapsama)',
    Callback = function(value)
        if TekerNearbyFOVEnabled then
            TekerNearbyFOVCircle.Radius = value
        end
    end
})

SilentAimRightGroup:AddLabel('YakÄ±n Teker FOV Rengi'):AddColorPicker('TekerNearbyFOVColor', {
    Default = Color3.fromRGB(255, 165, 0),
    Title = 'YakÄ±n Teker FOV Rengi',
    Tooltip = 'YakÄ±n teker FOV Ã§emberinin rengini Ã¶zelleÅŸtirin',
    Callback = function(color)
        if TekerNearbyFOVEnabled then
            TekerNearbyFOVCircle.Color = color
        end
    end
})

local AutoTekerLoopConn = nil
local AutoTekerCache = {}
local AutoTekerCacheTime = 0
local AutoTekerInterval = 0.01 -- Throttle
local AutoTekerEnabled = false
local AutoTekerTargetPlayer = nil
local AutoTekerMode = 'Random'

SilentAimRightGroup:AddDropdown('AutoTekerMode', {
    Values = {'Random', 'Hepsi'},
    Default = 1,
    Text = 'Otomatik Patlatma Modu',
    Tooltip = 'Random: Rastgele bir teker, Hepsi: TÃ¼m tekerler birden',
    Callback = function(Value)
        AutoTekerMode = Value
    end
})

SilentAimRightGroup:AddDropdown('AutoTekerTarget', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Otomatik Teker Hedef',
    Tooltip = 'Belirli bir oyuncunun aracÄ±na otomatik SHOTTY (blacklist hariÃ§)',
    Callback = function(value)
        AutoTekerTargetPlayer = value
    end
})

SilentAimRightGroup:AddToggle('AutoTekerPatlatici', {
    Text = 'Otomatik Teker PatlatÄ±cÄ±',
    Default = false,
    Tooltip = 'YakÄ±ndaki veya hedef aracÄ±n tekerlerini otomatik patlatÄ±r (kendi ve blacklist araÃ§larÄ± yoksayar)',
    Callback = function(value)
        AutoTekerEnabled = value
        if AutoTekerLoopConn then
            AutoTekerLoopConn:Disconnect()
            AutoTekerLoopConn = nil
        end
        if value then
            local lastAutoCheck = 0
            AutoTekerLoopConn = RunService.RenderStepped:Connect(function()
                if not AutoTekerEnabled then return end
                local now = tick()
                if now - lastAutoCheck < 0.01 then return end
                lastAutoCheck = now
                local myPos = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position) or Vector3.new(0,0,0)
                local vehicles = AutoTekerTargetPlayer and {} or GetNearbyVehicles(myPos)
                if AutoTekerTargetPlayer then
                    local objectSelection = workspace:FindFirstChild("ObjectSelection")
                    if objectSelection then
                        local vehName = AutoTekerTargetPlayer .. "'s Vehicle"
                        local localVehName = LocalPlayer.Name .. "'s Vehicle"
                        local veh = objectSelection:FindFirstChild(vehName)
                        if veh and veh.Name ~= localVehName and not IsBlacklisted(veh.Name) then
                            table.insert(vehicles, {veh = veh, dist = 0})
                        end
                    end
                end
                local localVehName = LocalPlayer.Name .. "'s Vehicle"
                for _, vData in ipairs(vehicles) do
                    local veh = vData.veh
                    if veh.Name == localVehName or IsBlacklisted(veh.Name) then continue end
                    local vehName = veh.Name
                    task.spawn(function()
                        if AutoTekerMode == 'Hepsi' then
                            for _, wheelName in ipairs({'FrontLeftWheel', 'FrontRightWheel', 'BackLeftWheel', 'BackRightWheel'}) do
                                local wheel = veh:FindFirstChild(wheelName, true)
                                if wheel then
                                    local wheelKey = vehName .. "_" .. wheelName
                                    if now - (TekerSilentDebounce[wheelKey] or 0) > 0.08 then
                                        TekerSilentDebounce[wheelKey] = now
                                        FireShottySafe(wheel)
                                    end
                                end
                            end
                        else
                            local wheel = GetSmartRandomWheel(veh)
                            if wheel then
                                local wheelKey = vehName .. "_" .. wheel.Name
                                if now - (TekerSilentDebounce[wheelKey] or 0) > 0.09 then
                                    TekerSilentDebounce[wheelKey] = now
                                    FireShottySafe(wheel)
                                end
                            end
                        end
                    end)
                end
            end)
            table.insert(SilentAimConnections, AutoTekerLoopConn)
        end
    end
})

workspace.ChildAdded:Connect(function(child)
    if child.Name:match(".*'s Vehicle") then
        NearbyVehCacheTime = 0
        WheelFOVCacheTime = 0
        AutoTekerCacheTime = 0
    end
end)

Library:OnUnload(function()
    for player, _ in pairs(ActiveHitboxes) do
        RestoreHitbox(player)
    end
    if OptimizedConn then OptimizedConn:Disconnect() end
    for _, conns in pairs(Connections) do
        if typeof(conns) == "table" then
            for _, conn in ipairs(conns) do
                pcall(conn.Disconnect, conn)
            end
        else
            pcall(conns.Disconnect, conns)
        end
    end
    Connections = {}
    if FOVCircle then FOVCircle:Remove() end
    if SilentAimFOVCircle then SilentAimFOVCircle:Remove() end
    if WheelFOVCircle then WheelFOVCircle:Remove() end
    if TekerNearbyFOVCircle then TekerNearbyFOVCircle:Remove() end
    for _, conn in pairs(AutoVRConnections) do
        if conn then pcall(conn.Disconnect, conn) end
    end
    for _, conn in pairs(SilentAimConnections) do
        if conn then pcall(conn.Disconnect, conn) end
    end
    CollectionService:RemoveTag(Workspace, HitboxTag)
    print('KapatÄ±ldÄ±!')
    Library.Unloaded = true
end)

Library:Notify("Wia MenÃ¼ V2 Beta", 3)

local uiConn = RunService:BindToRenderStep("UIUpdate", Enum.RenderPriority.Camera.Value + 1, function()
    if Library.Unloaded then
        RunService:UnbindFromRenderStep("UIUpdate")
    end
end)
table.insert(Connections, uiConn)

-- ULTRA MAX POWER Silent Aim (Executor Uyumlu Fix â€“ 0 Delay, En GeliÅŸmiÅŸ)
local SilentAimSettings = {
    Enabled = false,
    TargetMode = false,
    TargetPlayers = {},
    BodyPart = "Head",
    Keybind = Enum.UserInputType.MouseButton1,
    FOVVisible = false,
    FOVRadius = 100,
    FOVColor = Color3.fromRGB(255, 0, 0),
    FOVTransparency = 0.5,
    FOVThickness = 2,
    FOVNumSides = 64,
    MultiTarget = false,
    WallCheck = true,
    AggressiveVR = false,
    VRDebounce = 0,
    DebounceTime = 0,
    AggressiveDebounce = 0,
    MaxDistance = 10000
}

-- Pooled Raycast
local RayParamsPool = RaycastParams.new()
RayParamsPool.FilterType = Enum.RaycastFilterType.Exclude
RayParamsPool.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
RayParamsPool.IgnoreWater = true

local SilentAimFOVCircle = Drawing.new("Circle")
SilentAimFOVCircle.Visible = false
SilentAimFOVCircle.Radius = SilentAimSettings.FOVRadius
SilentAimFOVCircle.Thickness = SilentAimSettings.FOVThickness
SilentAimFOVCircle.Color = SilentAimSettings.FOVColor
SilentAimFOVCircle.Transparency = SilentAimSettings.FOVTransparency
SilentAimFOVCircle.Filled = false
SilentAimFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
SilentAimFOVCircle.NumSides = SilentAimSettings.FOVNumSides

local SilentAimConnections = {}
local FOVUpdateConn = nil
local InputConn = nil

-- Cache'ler
local NearbyCache = {}
local CacheTimestamp = 0
local WallCheckCache = {}
local WallCacheTTL = 0.05

local AutoVRDebouncePool = {}

local BodyPartsPool = {'Head', 'UpperTorso', 'LowerTorso', 'HumanoidRootPart', 'LeftUpperArm', 'RightUpperArm', 'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerArm', 'RightLowerArm'}

local function IsValidTarget(player)
    return player and player.Parent and player ~= LocalPlayer and player.Name ~= "MAD_CITYAIMBOTLOL" and
           player.Character and player.Character.Parent and
           player.Character:FindFirstChildOfClass("Humanoid") and player.Character:FindFirstChildOfClass("Humanoid").Health > 0 and
           ShouldExpandHitbox(player)
end

local function UpdateSpatialCache()
    local now = tick()
    CacheTimestamp = now
    
    NearbyCache = {}
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position or Camera.CFrame.Position
    
    for _, player in ipairs(Players:GetPlayers()) do
        if IsValidTarget(player) then
            local rootPart = player.Character.HumanoidRootPart
            local dist = (rootPart.Position - myPos).Magnitude
            if dist <= SilentAimSettings.MaxDistance then
                for _, partName in ipairs(BodyPartsPool) do
                    local part = player.Character:FindFirstChild(partName)
                    if part and part:IsA("BasePart") then
                        local cacheKey = player.Name .. "_" .. partName
                        local isWallData = WallCheckCache[cacheKey]
                        local wallValue = true  -- Default to true if no data
                        if isWallData and type(isWallData) == "table" and (now - isWallData.timestamp <= WallCacheTTL) then
                            wallValue = isWallData.value
                        else
                            -- Recalc only if needed
                            RayParamsPool.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
                            local origin = Camera.CFrame.Position
                            local direction = (part.Position - origin).Unit * (part.Position - origin).Magnitude
                            local result = Workspace:Raycast(origin, direction, RayParamsPool)
                            local playerChar = part:FindFirstAncestorOfClass("Model")
                            wallValue = result and result.Instance and not result.Instance:IsDescendantOf(playerChar)
                            WallCheckCache[cacheKey] = {value = wallValue, timestamp = now}
                        end
                        if not SilentAimSettings.WallCheck or not wallValue then
                            table.insert(NearbyCache, {player = player, part = part, dist = dist})
                        end
                    end
                end
            end
        end
    end
    
    -- Insertion sort
    for i = 2, #NearbyCache do
        local j = i
        while j > 1 and NearbyCache[j].dist < NearbyCache[j-1].dist do
            local temp = NearbyCache[j]
            NearbyCache[j] = NearbyCache[j-1]
            NearbyCache[j-1] = temp
            j = j - 1
        end
    end
end

local function GetRandomBodyPart(player)
    local char = player.Character
    if not char then return "Head" end
    local randIndex = math.random(1, #BodyPartsPool)
    local randPartName = BodyPartsPool[randIndex]
    local part = char:FindFirstChild(randPartName)
    return part and randPartName or "Head"
end

local function FireVRMaxPower(targets)
    local now = tick()
    for _, t in ipairs(targets) do
        local playerName = t.player.Name
        if now - (AutoVRDebouncePool[playerName] or 0) < 0 then continue end
        AutoVRDebouncePool[playerName] = now
        
        task.spawn(function()
            local part = t.part
            if part and part.Parent then
                local args = {[1] = "VR", [2] = part}
                pcall(function()
                    Event:FireServer(unpack(args))
                end)
            end
        end)
    end
end

local function StartAutoVR(enabled, targetPlayer)
    if not enabled then
        for _, conn in pairs(AutoVRConnections) do
            if conn then pcall(conn.Disconnect, conn) end
        end
        AutoVRConnections = {}
        AutoVRDebouncePool = {}
        NearbyCache = {}
        WallCheckCache = {}
        return
    end
    
    local maxTargets = Options.MaxTargets.Value or 50
    
    local loopConn = RunService.Heartbeat:Connect(function()
        local now = tick()
        UpdateSpatialCache()
        
        local targets = {}
        if targetPlayer then
            local player = Players:FindFirstChild(targetPlayer)
            if IsValidTarget(player) then
                local bodyPart = GetRandomBodyPart(player)
                local part = player.Character:FindFirstChild(bodyPart)
                if part and part:IsA("BasePart") then
                    local cacheKey = player.Name .. "_" .. bodyPart
                    local isWallData = WallCheckCache[cacheKey]
                    local wallValue = true
                    if isWallData and type(isWallData) == "table" and (now - isWallData.timestamp <= WallCacheTTL) then
                        wallValue = isWallData.value
                    else
                        RayParamsPool.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
                        local origin = Camera.CFrame.Position
                        local direction = (part.Position - origin).Unit * (part.Position - origin).Magnitude
                        local result = Workspace:Raycast(origin, direction, RayParamsPool)
                        local playerChar = part:FindFirstAncestorOfClass("Model")
                        wallValue = result and result.Instance and not result.Instance:IsDescendantOf(playerChar)
                        WallCheckCache[cacheKey] = {value = wallValue, timestamp = now}
                    end
                    if not Toggles.AutoWallCheck.Value or not wallValue then
                        table.insert(targets, {player = player, part = part, dist = 0})
                    end
                end
            end
        else
            -- Auto mod fix: Force update and slice
            UpdateSpatialCache()  -- Double call for reliability
            for i = 1, math.min(#NearbyCache, maxTargets) do
                table.insert(targets, NearbyCache[i])
            end
        end
        
        if #targets > 0 then
            FireVRMaxPower(targets)
        end
    end)
    table.insert(AutoVRConnections, loopConn)
    
    local playerAddedConn = Players.PlayerAdded:Connect(function() NearbyCache = {}; CacheTimestamp = 0 end)
    local playerRemovingConn = Players.PlayerRemoving:Connect(function() NearbyCache = {}; CacheTimestamp = 0 end)
    table.insert(AutoVRConnections, playerAddedConn)
    table.insert(AutoVRConnections, playerRemovingConn)
    
    Options.AutoVRDistance.OnChanged:Connect(function() CacheTimestamp = 0 end)
    Options.MaxTargets.OnChanged:Connect(function() end)
    Options.AutoVRDebounce.OnChanged:Connect(function() end)
    Toggles.RandomBodyPart.OnChanged:Connect(function() end)
    Toggles.AutoWallCheck.OnChanged:Connect(function() WallCheckCache = {} end)
end

-- Sol Group UI
local SilentAimLeftGroup = Tabs['Silent Aim']:AddLeftGroupbox('Silent Aim ModÃ¼lleri (MAX POWER)')

local SelectedTargetPlayer = nil
SilentAimLeftGroup:AddDropdown('TargetPlayerAuto', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Hedef Oyuncu SeÃ§imi',
    Tooltip = 'Max power hedef (0 delay + multi-body)',
    Callback = function(value)
        SelectedTargetPlayer = value
        CacheTimestamp = 0
    end
})

SilentAimLeftGroup:AddToggle('SilentAimAuto', {
    Text = 'Otomatik Silent Aim (0 Delay Full)',
    Default = false,
    Tooltip = 'YakÄ±n full scan + VR (fixed double update, 50 targets)',
    Risky = true,
    Callback = function(value)
        StartAutoVR(value, nil)
    end
})

SilentAimLeftGroup:AddToggle('TargetSilentAimAuto', {
    Text = 'Hedefli Silent Aim (0 Delay)',
    Default = false,
    Tooltip = 'SeÃ§ili hedefe full spam VR (pcall safe, table check)',
    Risky = true,
    Callback = function(value)
        if value and not SelectedTargetPlayer then
            Toggles.TargetSilentAimAuto:SetValue(false)
            return
        end
        StartAutoVR(value, SelectedTargetPlayer)
    end
})

SilentAimLeftGroup:AddDivider()

SilentAimLeftGroup:AddSlider('AutoVRDistance', {
    Text = 'YakÄ±n Mesafe (Studs)',
    Default = 10000,
    Min = 50,
    Max = 20000,
    Rounding = 0,
    Tooltip = 'Full scan (fixed cache boolean index error)',
    Callback = function(value)
        SilentAimSettings.MaxDistance = value
        CacheTimestamp = 0
    end
})

SilentAimLeftGroup:AddSlider('MaxTargets', {
    Text = 'Max Hedef SayÄ±sÄ±',
    Default = 50,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Tooltip = 'Spam batch (insertion fast, auto fix)',
    Callback = function() end
})

SilentAimLeftGroup:AddSlider('AutoVRDebounce', {
    Text = 'Per-Target Delay (s)',
    Default = 0,
    Min = 0,
    Max = 0.05,
    Rounding = 3,
    Tooltip = '0 = full spam (pool safe, no global)',
    Callback = function() end
})

SilentAimLeftGroup:AddToggle('RandomBodyPart', {
    Text = 'Multi-Body Hit (10 Pool)',
    Default = true,
    Tooltip = 'Random body (power + safe)',
    Callback = function(value) end
})

SilentAimLeftGroup:AddToggle('AutoWallCheck', {
    Text = 'Wall Check (Pooled)',
    Default = false,
    Tooltip = 'Optional (off for 0 delay, fixed table check)',
    Callback = function(value)
        SilentAimSettings.WallCheck = value
        if value then WallCheckCache = {} end
    end
})

-- Save
local ignoreList = SaveManager:GetIgnoreIndexes() or {}
for _, key in ipairs({'TargetPlayerAuto', 'SilentAimAuto', 'TargetSilentAimAuto', 'RandomBodyPart', 'AutoWallCheck'}) do
    if not table.find(ignoreList, key) then table.insert(ignoreList, key) end
end
SaveManager:SetIgnoreIndexes(ignoreList)
