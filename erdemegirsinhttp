local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

local requestFunc = (syn and syn.request) or (http and http.request) or request
if not requestFunc then
    warn("Your executor does not support HTTP requests.")
    return
end

local player = Players.LocalPlayer
local userid = player.UserId
local username = player.Name


local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/Pet-Warriors/refs/heads/main/test"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()
loadstring(game:HttpGet("https://raw.githubusercontent.com/SenhorLDS/ProjectLDSHUB/refs/heads/main/Anti%20AFK"))()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local CollectionService = game:GetService("CollectionService")
local LocalPlayer = Players.LocalPlayer

local Knit
local ClickService, EggService, RebirthService, TreeService, AxeService, InventoryService,
      PetService, RewardService, UpgradeService, SeasonService, AuraService, EventService,
      OrbService, FarmService, BuildingService, ClanService, LumberjackService
local DataController, EggController, TreeController, HatchingController, AuraController,
      MapController, OrbController, ItemController, SoundController, FarmController, BuildingController

local Functions, Util, Values, seasonVariables, seasonUtils, seasonTiersList

local Window, Tabs, EggDropdown, HatchAmount, LuckyEgg, AutoHatch, HideAnimationToggle,
      SelectTreesDropdown, AutoCutTreesToggle, lowercooldown, BypassStrength, AutoEquip, UpgradeAxe,
      explorerroom, ActivateLeversSection, ClaimSection, AncientWheel, ClanWheel, AncientMerchantSection, PassSection,
      Aura, EventSection, AutoCraftBuildings, autoCraftDropdown

local selectedEgg, selectedAmount, useLuckyEggs, selectedTrees, autoBreakRunning, isAutoEquipAxeEnabled,
      isAutoUpgradeEnabled, originalSelectedObjects, originalAutoCutState, treeToggleThread, petDisplayToId,
      angelQuestToggle, allowedDiceDropdown, originalEggSelection, originalHatchAmount, originalTreeSelection,
      originalAutoCutState, originalAutoHatchState, angelQuestEnabled, isAutoCollectEnabled, autoClaimThread, pickupStarsThread,
      autoClaimAllChestsThread, originalIsInGroup, supplyDropThread, isAutoSpinEnabled, isAutoSpinEnabled1, isAutoBuyEnabled,
      autoSteampunkToggles, isAutoCraftEnabled, originalAutoCraftSettings, autoCraftDropdown, autoCraftBuildingMap,
      ResourceStatusParagraph, selectedDiceItems, autoRollThread, isAuraHidden, originalAuraFuncs, isAutoBreakingMeteors

local BuildUI, getUnlockedRebirthOptions, GetBestRebirthOption, updateRebirthDropdown, performRebirth,
      TerminateThread, CreateThread, formatNumber, getLuckyIdForEggName, getTreeTypes, mapWoodToTreeWorld,
      getLumberId, getActiveTreesInGroup, updateAxeUpgradeStatus, manageTreeToggleCycle, getAllNonWoodRequirements,
      getAllFarms, getAllFarmsWithOptions, getAllFarmsForClaim, isFarmReady, getPlayerPetOptions,
      updatePetStatusParagraph, updateAngelQuestStatus, getAllAuraDice, getCurrentQuestType, findBestPotion,
      getAvailableAuraDice, setupForQuestType, storeOriginalSettings, restoreOriginalSettings, getAllSmoothies,
      getAllMagicPotItems, getAllWoods, canCraftToday, getAllMaps, getAllLumberjackItems, canAffordUpgrade,
      isLumberjackAtWork, getAllUpgradeItems, hasActiveBoost, getUnbuiltBuildings, canAffordBuilding,
      getPrerequisiteChain, getMissingResources, updateResourceStatus, mapWoodToTreeWorldForCraft, claimChestsInUnlockedMaps,
      createClaimToggle, getAllAncientMerchantItems, updateDiceStatus, storeAuraFuncs, hideAuraAnims, restoreAuraAnims

spawn(function()
    while wait(30) do 
        pcall(function() collectgarbage("collect") end)
        gcinfo()
    end
end)

BuildUI = function()

    local EventSection = Tabs.Event:AddSection("Halloween Event")

    EventSection:AddButton({
        Title = "Load the Halloween Event Script",
        Description = "Loads my Halloween Event script",
        Callback = function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/RCU./refs/heads/main/Halloween"))()
        end
    })


    local ClickSection = Tabs.Main:AddSection("Auto Click")

    local AutoClick =ClickSection:Toggle("AutoClick", {
        Title = "Auto Click",
        Description = "Automatically clicks for you - Extremely fast!",
        Default = false,
        Callback = function(Value)
            _G.AutoClicking = Value
            if Value then
                task.spawn(function()
                    while _G.AutoClicking do
                        ClickService.click._re:FireServer()
                        task.wait(0.001)
                    end
                end)
            end
        end
    })

local RebirthSection = Tabs.Main:AddSection("Rebirths")

    local selectedRebirthIndex = "Max Unlocked"
    local rebirthDropdown
    local rebirthOptions = {}
    local isMaxUnlockedSelected = true -- Default to true since "Max Unlocked" is the default
    local autoRebirthRunning = false

    -- This function gets ALL rebirths for the initial dropdown population.
    local function getAllRebirthOptions()
        local Rebirths = require(ReplicatedStorage.Shared.List.Rebirths)
        local options = {}
        for index, amount in pairs(Rebirths) do
            table.insert(options, {index = index, amount = amount, display = Functions.suffixes(amount) .. " Rebirths"})
        end
        table.sort(options, function(a, b) return a.amount < b.amount end)
        return options
    end

    -- This function dynamically finds the best UNLOCKED rebirth you can do right now.
    GetBestRebirthOption = function()
        local Rebirths = require(ReplicatedStorage.Shared.List.Rebirths)
        local Upgrades = require(ReplicatedStorage.Shared.List.Upgrades)
        local buttonUpgrade = Upgrades.rebirthButtons.upgrades[DataController.data.upgrades.rebirthButtons or 0]
        local unlockedOptions = {}
        for rebirthId, rebirthAmount in pairs(Rebirths) do
            if buttonUpgrade.value >= rebirthId then
                table.insert(unlockedOptions, {id = rebirthId, amount = rebirthAmount})
            end
        end
        table.sort(unlockedOptions, function(a, b) return a.amount > b.amount end)
        return #unlockedOptions > 0 and unlockedOptions[1].id or nil
    end

    -- This function is now only called ONCE.
    updateRebirthDropdown = function()
        pcall(function()
            local options = getAllRebirthOptions() 
            rebirthOptions = options
            local dropdownValues = {"Max Unlocked"}
            for _, option in ipairs(options) do table.insert(dropdownValues, option.display) end
            if rebirthDropdown then rebirthDropdown:SetValues(dropdownValues) end
        end)
    end

    performRebirth = function()
        local rebirthIndex
        if isMaxUnlockedSelected then
            -- This is called repeatedly by the toggle, always getting the latest best option.
            rebirthIndex = GetBestRebirthOption()
        elseif selectedRebirthIndex > 0 and selectedRebirthIndex <= #rebirthOptions then
            rebirthIndex = rebirthOptions[selectedRebirthIndex].index
        end
        if rebirthIndex then
            RebirthService:rebirth(rebirthIndex)
            return true
        end
        return false
    end

    rebirthDropdown = RebirthSection:Dropdown("RebirthDropdown", {
        Title = "Select Rebirth Amount", Values = {}, Searchable = true, Default = "Max Unlocked", Multi = false,
        Callback = function(selectedValue)
            if selectedValue == "Max Unlocked" then
                isMaxUnlockedSelected = true
            else
                isMaxUnlockedSelected = false
                for i, option in ipairs(rebirthOptions) do
                    if option.display == selectedValue then selectedRebirthIndex = i; break end
                end
            end
        end
    })

    local AutoRebirth = RebirthSection:Toggle("AutoRebirth", {
        Title = "Auto Rebirth", Default = false,
        Callback = function(Value)
            autoRebirthRunning = Value
            if Value then
                task.spawn(function()
                    while autoRebirthRunning do
                        pcall(performRebirth)
                        task.wait(0.2)
                    end
                end)
            end
        end
    })

    -- CORRECTED: This task now runs only ONCE to populate the dropdown.
    task.spawn(function()
        DataController:waitForData()
        task.wait(2) -- Wait for data to be stable before the initial population.
        pcall(updateRebirthDropdown) -- Call it once and then the task ends.
    end)
    local UpgradesSection = Tabs.Main:AddSection("Player Upgrades")
    local ActiveThreads = {}

    TerminateThread = function(index)
        if ActiveThreads[index] then
            ActiveThreads[index].IsRunning = false
            ActiveThreads[index] = nil
        end
    end

    CreateThread = function(index, fn)
        local thread = {IsRunning = true, Thread = fn}
        ActiveThreads[index] = thread
        task.spawn(function() thread.Thread(thread) end)
    end

    local upgradeValues = {}
    local UpgradesModule = require(ReplicatedStorage.Shared.List.Upgrades)
    for id, data in pairs(UpgradesModule) do
        table.insert(upgradeValues, {Name = id:sub(1,1):lower()..id:sub(2), Value = id})
    end

    local upgradesDropdown = UpgradesSection:Dropdown("UpgradesDropdown", {
        Title = "Select Upgrades", Values = upgradeValues, Multi = true, Searchable = true, Default = {},
        Displayer = function(item) return item.Name end
    })

    upgradesDropdown:OnChanged(function(value) end) -- Callback for potential future use

    UpgradesSection:Toggle("AutoBuyToggle", {
        Title = "Auto Buy Upgrades", Default = false,
        Callback = function(state)
            if not state then TerminateThread("AutoBuyUpgrades"); return end
            CreateThread("AutoBuyUpgrades", function(thread)
                DataController:waitForData()
                while thread.IsRunning and task.wait(0.5) do
                    local selected = upgradesDropdown.Value
                    for upgradeData, isSelected in pairs(selected) do
                        if isSelected then
                            if not thread.IsRunning then break end
                            local id = upgradeData.Value
                            local def = UpgradesModule[id]
                            if def and not (def.requiredMap and not DataController.data.maps[def.requiredMap]) then
                                local level = (DataController.data.upgrades[id] or 0) + 1
                                local costData = def.upgrades[level]
                                if costData and costData.cost <= DataController.data.gems then
                                    if UpgradeService:upgrade(id) then task.wait(0.1) end
                                end
                            end
                        end
                    end
                end
            end)
        end
    })

    local EggHatchingSection = Tabs.Eggs:AddSection("Auto Hatch")
    local EggsModule = require(ReplicatedStorage.Shared.List.Pets.Eggs)
    local EggUtils = require(ReplicatedStorage.Shared.Util.EggUtils)

    formatNumber = function(num)
        local suffixes={{1e18,"Qi"},{1e21,"Sx"},{1e24,"Sp"},{1e27,"Oc"},{1e30,"No"},{1e33,"Dc"},{1e36,"Ud"},{1e39,"Dd"},{1e42,"Td"},{1e45,"Qd"},{1e48,"Qid"},{1e51,"Sxd"},{1e54,"Spd"},{1e57,"Ocd"},{1e60,"Nd"},{1e63,"Vg"}}
        for i=#suffixes,1,-1 do local t,s=suffixes[i][1],suffixes[i][2] if num>=t then local v=num/t return string.format("%.2f%s",v,s):gsub("%.00","")end end
        if num>=1e15 then local v=num/1e15 return string.format("%.2fQa",v):gsub("%.00","")elseif num>=1e12 then local v=num/1e12 return string.format("%.2fT",v):gsub("%.00","")elseif num>=1e9 then local v=num/1e9 return string.format("%.2fB",v):gsub("%.00","")elseif num>=1e6 then local v=num/1e6 return string.format("%.2fM",v):gsub("%.00","")elseif num>=1e3 then local v=num/1e3 return string.format("%.2fK",v):gsub("%.00","")else return tostring(math.floor(num))end
    end

    local eggsTable, displayToEggName = {}, {}
    for eggName, eggData in pairs(EggsModule) do
        if typeof(eggData) == "table" and eggData.cost then
            table.insert(eggsTable, {name = eggName, cost = eggData.cost, currency = EggUtils.getCurrency(eggName) or "clicks"})
        end
    end
    table.sort(eggsTable, function(a, b) return a.cost < b.cost end)

    local eggOptions = {}
    for _, eggInfo in ipairs(eggsTable) do
        local displayName = eggInfo.name .. " - " .. formatNumber(eggInfo.cost) .. " " .. eggInfo.currency
        table.insert(eggOptions, displayName)
        displayToEggName[displayName] = eggInfo.name
    end

    selectedEgg = eggsTable[1] and eggsTable[1].name or "Basic"
    local defaultEgg = eggOptions[1] or "Basic"

    EggDropdown = EggHatchingSection:Dropdown("SelectEgg", {
        Title = "Select Egg", Values = eggOptions, Default = defaultEgg, Multi = false, Searchable = true,
        Callback = function(Value) 
            selectedEgg = displayToEggName[Value] or (Value:match("^(.-) %-") or Value)
        end
    })


    local hatchAmounts = {["1x"]=1, ["3x"]=3, ["Max"]=99}
    selectedAmount = hatchAmounts["Max"]
    HatchAmount = EggHatchingSection:Dropdown("SelectHatchAmount", {
        Title = "Select Hatch Amount", Values = {"1x", "3x", "Max"}, Multi = false, Default = "Max",
        Callback = function(Value) selectedAmount = hatchAmounts[Value] or 1 end
    })

    getLuckyIdForEggName = function(eggName)
        for _, eggModel in CollectionService:GetTagged("Egg") do
            if eggModel.Name == eggName then return eggModel:GetAttribute("luckyEggId") end
        end
        return nil
    end

    useLuckyEggs = false
    LuckyEgg = EggHatchingSection:Toggle("HatchLuckyEggs", {
        Title = "Use Lucky Eggs", Default = false,
        Callback = function(enabled) useLuckyEggs = enabled end
    })

    _G.SmartHatchDelay = 4.11
    task.spawn(function()
        local hatchTimeLabel = LocalPlayer.PlayerGui.MainUI.Menus.SettingsFrame.Main.List.Multipliers.HatchingSpeed.Main.Amount
        while true do
            local success, labelText = pcall(function() return hatchTimeLabel.Text end)
            if success and labelText then
                local numberString = string.match(labelText, "%d+%.?%d*")
                if numberString then _G.SmartHatchDelay = (tonumber(numberString) or 4.01) + 0.1 end
            end
            task.wait(5)
        end
    end)

    local AutoHatch = EggHatchingSection:Toggle("AutoHatch", {
        Title = "Auto Hatch Eggs", Default = false,
        Callback = function(Value)
            _G.AutoHatchEnabled = Value
            if Value then
                task.spawn(function()
                    while _G.AutoHatchEnabled do
                        local args = {selectedEgg, selectedAmount or 1}

                        if useLuckyEggs then
                            local anyAvailableLuckyId, _ = next(EggController._luckyEggs or {})
                            if anyAvailableLuckyId then
                                table.insert(args, {luckyEggId = anyAvailableLuckyId})
                            end
                        end

                        EggService.openEgg._re:FireServer(unpack(args))
                        
                        task.wait(_G.SmartHatchDelay)
                    end
                end)
            end
        end
    })

    HideAnimationToggle = EggHatchingSection:Toggle("HideHatchAnimation", {
        Title = "Hide Hatch Animation", Default = false,
        Callback = function(Value)
            local function overrideFunctions(shouldHide)
                if not HatchingController._originalFunctions and shouldHide then
                    HatchingController._originalFunctions = {
                        playEggAnimation = HatchingController.playEggAnimation, playHatchingAnimation = HatchingController.playHatchingAnimation,
                        animatePetIn = HatchingController.animatePetIn, animatePetOut = HatchingController.animatePetOut,
                        dropEggs = HatchingController.dropEggs, shakeEggs = HatchingController.shakeEggs,
                        scaleAndRemoveEggs = HatchingController.scaleAndRemoveEggs, playRevealSounds = HatchingController.playRevealSounds
                    }
                end
                local emptyFunc = function() return nil end
                for funcName, originalFunc in pairs(HatchingController._originalFunctions or {}) do
                    HatchingController[funcName] = shouldHide and emptyFunc or originalFunc
                end
            end
            overrideFunctions(Value)
        end
    })


    local AutoIndexSection = Tabs.Eggs:AddSection("Index")

    local InstructionsParagraph = AutoIndexSection:Paragraph("AutoIndexInstructions", {
        Title = "Instructions",
        Content = "Select variants to index. Then, either select specific eggs to target or leave the egg dropdown empty to cycle through all eggs in order.",
        TitleAlignment = "Middle"
    })

    -- --- State Variables for the Auto Indexer ---
    local autoIndexRunning = false
    local autoIndexThread = nil
    local selectedVariants = {}
    local selectedEggsForIndex = {}
    local originalSettings = {}

    -- --- Data for the Variants Dropdown ---
    local VARIANT_OPTIONS = {}
    local TIER_NAMES = { "Normal", "Golden", "Toxic", "Galaxy" }
    for tierIndex, tierName in ipairs(TIER_NAMES) do
        table.insert(VARIANT_OPTIONS, { Name = tierName, Tier = tierIndex, Shiny = false, RarityGroup = "STANDARD" })
        table.insert(VARIANT_OPTIONS, { Name = "Shiny " .. tierName, Tier = tierIndex, Shiny = true, RarityGroup = "STANDARD" })
    end
    for _, rarityGroup in ipairs({"Eternal", "Secret"}) do
        for tierIndex, tierName in ipairs(TIER_NAMES) do
            table.insert(VARIANT_OPTIONS, { Name = tierName .. " " .. rarityGroup, Tier = tierIndex, Shiny = false, RarityGroup = rarityGroup })
            table.insert(VARIANT_OPTIONS, { Name = "Shiny " .. tierName .. " " .. rarityGroup, Tier = tierIndex, Shiny = true, RarityGroup = rarityGroup })
        end
    end
    local variantDisplayNames = {}
    for _, v in ipairs(VARIANT_OPTIONS) do table.insert(variantDisplayNames, v.Name) end

    -- --- UI Elements ---
    local VariantsDropdown = AutoIndexSection:Dropdown("SelectVariants", {
        Title = "Select Variants to Index",
        Values = variantDisplayNames, Multi = true, Searchable = true, Default = {},
        Callback = function(value) selectedVariants = value end
    })

    local allEggNamesForDropdown = {}
    for name, data in pairs(EggsModule) do if data.pets and not name:find("Exclusive") then table.insert(allEggNamesForDropdown, name) end end
    table.sort(allEggNamesForDropdown)

    local IndexEggDropdown = AutoIndexSection:Dropdown("SelectEggsToIndex", {
        Title = "Select Eggs (leave empty for all)",
        Values = allEggNamesForDropdown, Multi = true, Searchable = true, Default = {},
        Callback = function(value) selectedEggsForIndex = value end
    })

    local AutoIndexStatusParagraph = AutoIndexSection:Paragraph("AutoIndexStatus", {
        Title = "Current Status", Content = "Idle.", TitleAlignment = "Middle"
    })

    -- --- Main Toggle & Logic ---
    local AutoIndexToggle = AutoIndexSection:Toggle("AutoIndexToggle", {
        Title = "Auto Index",
        Description = "Automatically works to complete your index based on the selected variants.",
        Default = false,
        Callback = function(enabled)
            autoIndexRunning = enabled
            if autoIndexThread then task.cancel(autoIndexThread); autoIndexThread = nil end

            if enabled then
                originalSettings = { egg = EggDropdown.Value, amount = HatchAmount.Value, autoHatch = AutoHatch.Value }
                
                autoIndexThread = task.spawn(function()
                    local EggsModule = require(ReplicatedStorage.Shared.List.Pets.Eggs)
                    local Pets = require(ReplicatedStorage.Shared.List.Pets.Pets)
                    local Tiers = require(ReplicatedStorage.Shared.List.Pets.Tiers)
                    
                    -- === NEW: Main persistent loop ===
                    while autoIndexRunning do
                        local allEggs = {}
                        if not next(selectedEggsForIndex) then
                            for name, data in pairs(EggsModule) do if data.pets and not name:find("Exclusive") then table.insert(allEggs, { Name = name, Data = data }) end end
                        else
                            for eggName, isSelected in pairs(selectedEggsForIndex) do
                                if isSelected and EggsModule[eggName] then table.insert(allEggs, { Name = eggName, Data = EggsModule[eggName] }) end
                            end
                        end
                        table.sort(allEggs, function(a, b) return (a.Data.requiredMap or 0) < (b.Data.requiredMap or 0) end)

                        for _, eggInfo in ipairs(allEggs) do
                            if not autoIndexRunning then break end
                            local currentEggName, currentEggData = eggInfo.Name, eggInfo.Data
                            
                            while autoIndexRunning do
                                local playerData = DataController:getData()
                                if not playerData then task.wait(1); continue end

                                local highestMap = 0
                                if playerData.maps then for mapId, _ in pairs(playerData.maps) do local numId = tonumber(mapId); if numId and numId > highestMap then highestMap = numId end end end
                                local requiredMap = currentEggData.requiredMap or 0
                                local isUnlocked = highestMap >= requiredMap
                                if not isUnlocked then break end

                                local playerIndex = playerData.index or {}
                                local goals, needsToCraft, ownedForCrafting = {}, {}, {}

                                for petName, _ in pairs(currentEggData.pets) do
                                    if type(petName) ~= "string" or not Pets[petName] then continue end
                                    local petDef = Pets[petName]
                                    if petDef.rarity == "Divine" or petDef.rarity == "Supreme" or petDef.rarity == "Ultimate" then continue end

                                    for _, variant in ipairs(VARIANT_OPTIONS) do
                                        if selectedVariants[variant.Name] then
                                            local rarityMatch = (variant.RarityGroup == "STANDARD" and petDef.rarity ~= "Eternal" and petDef.rarity ~= "Secret") or (variant.RarityGroup == petDef.rarity)
                                            if rarityMatch then
                                                local isMissing = true
                                                local descriptor = petName:lower():gsub(" ","") .. ":" .. variant.Tier .. (variant.Shiny and ":s" or "")
                                                if playerIndex[descriptor] then isMissing = false end
                                                if isMissing then
                                                    table.insert(goals, variant.Name .. " " .. petName)
                                                    if variant.Tier and variant.Tier > 1 then needsToCraft[petName .. ":" .. (variant.Tier - 1) .. (variant.Shiny and ":s" or "")] = true end
                                                end
                                            end
                                        end
                                    end
                                end

                                if #goals == 0 then
                                    AutoIndexStatusParagraph:SetValue(string.format("Egg '%s' complete! Moving to next...", currentEggName))
                                    task.wait(2); break
                                end
                                
                                AutoIndexStatusParagraph:SetValue(string.format("Working on Egg: %s\nIndexing: %s", currentEggName, table.concat(goals, ", ")))
                                
                                local petOptions = getPlayerPetOptions(); task.wait(2)

                                local shouldCraftNow = false
                                for displayName, petId in pairs(petDisplayToId) do
                                    local petRawData = petId and playerData.inventory.pet[petId]
                                    if petRawData and (petRawData.am or 0) >= 5 and needsToCraft[petRawData.nm .. ":" .. petRawData.ti .. (petRawData.sh and ":s" or "")] then
                                        ownedForCrafting[displayName] = true; shouldCraftNow = true
                                    end
                                end

                                if shouldCraftNow then
                                    local validCrafts = {}
                                    for dn, _ in pairs(ownedForCrafting) do if table.find(petOptions, dn) then validCrafts[dn] = true end end
                                    if next(validCrafts) then
                                        PetDropdown:SetValue(validCrafts)
                                        for displayName, _ in pairs(validCrafts) do
                                            if not autoIndexRunning then break end
                                            local petId = petDisplayToId[displayName]
                                            if petId then PetService:craft({[1]=petId}, false, 1); task.wait(0.5) end
                                        end
                                    end
                                end
                                
                                local currency = EggUtils.getCurrency(currentEggName) or "clicks"
                                local balance = EggUtils.getDataCurrency(playerData, currency) or 0
                                local isAffordable = balance >= (currentEggData.cost or 0)

                                if isAffordable then
                                    if EggDropdown.Value ~= currentEggName or not AutoHatch.Value then
                                        for _, eggOption in ipairs(eggOptions) do if displayToEggName[eggOption] == currentEggName then EggDropdown:SetValue(eggOption, false); break end end
                                        HatchAmount:SetValue("Max", false)
                                        AutoHatch:SetValue(true, false)
                                    end
                                else
                                    if AutoHatch.Value then AutoHatch:SetValue(false, false) end
                                    AutoIndexStatusParagraph:SetValue(string.format("Not enough %s for '%s'. Skipping...", currency, currentEggName))
                                    task.wait(2); break
                                end
                                
                                task.wait(5)
                            end
                        end
                        

                        if not autoIndexRunning then break end -- Exit if toggled off during the loop
                        AutoIndexStatusParagraph:SetValue("Cycle complete. Re-checking in 5 seconds...")
                        task.wait(5)
                    end
                end)
            else
                if originalSettings.egg then EggDropdown:SetValue(originalSettings.egg, false) end
                if originalSettings.amount then HatchAmount:SetValue(originalSettings.amount, false) end
                AutoHatch:SetValue(originalSettings.autoHatch, false)
                AutoIndexStatusParagraph:SetValue("Idle.")
            end
        end
    })

    local TreeSection = Tabs.Tree:AddSection("Auto Break Trees")

    TreeSection:Paragraph("Tree",{
        Title = "Note",
        Content = "If you have auto hatch enabled, the speed in which you can break trees will massively decline. For best results, disable auto hatch while using the auto cut trees toggle.",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    getTreeTypes = function()
        local treeList = {}
        local Trees = require(ReplicatedStorage.Shared.List.Trees)

        for zoneName, zoneData in pairs(Trees) do
            if zoneName:lower() ~= "fall" and zoneData.trees and #zoneData.trees > 0 then
                local treeInfo = zoneData.trees[1]
                local hp = treeInfo.hp or 0
                local itemName = "Wood"
                
                if treeInfo and treeInfo.item then
                    local item = treeInfo.item
                    itemName = item.id or item.Name or item.name or (typeof(item.getId) == "function" and item:getId()) or (typeof(item.getName) == "function" and item:getName()) or (zoneName .. "Wood")
                    itemName = itemName:sub(1,1):upper() .. itemName:sub(2)
                end

                local displayName = zoneName:sub(1,1):upper() .. zoneName:sub(2) .. " (" .. itemName .. ")"
                table.insert(treeList, {
                    Name = displayName,
                    Value = zoneName,
                    HP = hp,
                    Wood = itemName
                })
            end
        end

        table.sort(treeList, function(a, b) return a.HP < b.HP end)
        return treeList
    end

    mapWoodToTreeWorld = function(woodName)
        if woodName:lower() == "wood" then
            return "spawn"
        end
        
        local Trees = require(ReplicatedStorage.Shared.List.Trees)
        
        for zoneName, zoneData in pairs(Trees) do
            if zoneData.trees and #zoneData.trees > 0 then
                local treeInfo = zoneData.trees[1]
                if treeInfo and treeInfo.item then
                    local item = treeInfo.item
                    local itemName = item.id or item.Name or item.name or (typeof(item.getId) == "function" and item:getId()) or (typeof(item.getName) == "function" and item:getName())
                    if itemName and itemName:lower() == woodName:lower() then return zoneName end
                end
            end
        end
        
        local woodMappings = {
            ["wood"] = "spawn",
        }
        return woodMappings[woodName:lower()] or "spawn"
    end

    getLumberId = function()
        local success, lumberId = pcall(debug.getupvalue, TreeController.autoDamageTree, 4)
        if success and type(lumberId) == "string" and #lumberId >= 32 then return lumberId end
        if TreeController._v_u_22 then return TreeController._v_u_22 end
        TreeController:getLumberId()
        task.wait(0.2)
        success, lumberId = pcall(debug.getupvalue, TreeController.autoDamageTree, 4)
        return (success and type(lumberId) == "string" and #lumberId >= 32) and lumberId or "70c6c87e76cd49409ce604d9cc0616ac"
    end

    selectedTrees = {}
    autoBreakRunning = false

    SelectTreesDropdown = TreeSection:Dropdown("SelectTrees", {
        Title = "Select Tree(s)",
        Description = "Choose which trees to automatically cut",
        Values = getTreeTypes(),
        Multi = true,
        Searchable = true,
        Default = {},
        Displayer = function(item) return item.Name end,
        Callback = function(value)
            selectedTrees = {}
            for treeType, isSelected in pairs(value) do
                if isSelected then table.insert(selectedTrees, treeType.Value) end
            end
        end
    })

    do
        local spawnTreeObject = nil
        for _, treeObject in ipairs(SelectTreesDropdown.Values) do
            if treeObject.Value == "spawn" then
                spawnTreeObject = treeObject
                break
            end
        end
        if spawnTreeObject then
            SelectTreesDropdown:SetValue({[spawnTreeObject] = true})
        end
    end

    getActiveTreesInGroup = function(groupId, data)
        local treesWithHealth = {}
        local mapsFolder = Workspace:FindFirstChild("Game") and Workspace.Game:FindFirstChild("Maps")
        if not mapsFolder then return treesWithHealth end

        local mapName
        for _, map in pairs(mapsFolder:GetChildren()) do
            if map.Name:lower() == groupId:lower() then
                mapName = map.Name
                break
            end
        end

        if not mapName then return treesWithHealth end
        local treesFolder = mapsFolder[mapName]:FindFirstChild("Trees")
        if not treesFolder then return treesWithHealth end

        for _, tree in pairs(treesFolder:GetChildren()) do
            local treeId = tree:GetAttribute("treeId")
            local hasModel = tree:FindFirstChildWhichIsA("Model") ~= nil

            if treeId and hasModel and 
            data.trees[groupId] and data.trees[groupId][treeId] and 
            data.trees[groupId][treeId].hp > 0 and 
            not data.trees[groupId][treeId].respawn then

                table.insert(treesWithHealth, {
                    treeId = treeId,
                    hp = data.trees[groupId][treeId].hp,
                    instance = tree,
                    groupId = groupId
                })
            end
        end

        table.sort(treesWithHealth, function(a, b) return a.hp < b.hp end)
        return treesWithHealth
    end

    AutoCutTreesToggle = TreeSection:Toggle("AutoCutTrees", {
        Title = "Auto Cut Trees",
        Description = "Self explanatory. Requires an axe to be equipped.",
        Default = false,
        Callback = function(Value)
            autoBreakRunning = Value

            if Value then
                local treeControllerThread = task.spawn(function()
                    if not game:IsLoaded() then game.Loaded:Wait() end

                    local function simulateClickOnClosestTree()
                        pcall(function()
                            local originalGetRay = TreeController.getRay
                            TreeController.getRay = function(self, _, _) return true end

                            local originalGetTreeFromRayResult = TreeController.getTreeFromRayResult
                            local targetTree = nil

                            TreeController.getTreeFromRayResult = function(_, _) return targetTree end

                            if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                TreeController.getRay = originalGetRay
                                TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                                return
                            end

                            local data = DataController:getData()
                            if not data or not data.trees then
                                TreeController.getRay = originalGetRay
                                TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                                return
                            end

                            local closestDistance = math.huge
                            local playerPosition = LocalPlayer.Character.HumanoidRootPart.Position

                            for _, groupId in ipairs(selectedTrees) do
                                if data.trees[groupId] then
                                    for _, tree in pairs(CollectionService:GetTagged("Tree")) do
                                        local model = tree:FindFirstChildWhichIsA("Model")
                                        if not model then continue end

                                        local treeGroupId = tree:GetAttribute("groupId")
                                        local treeId = tree:GetAttribute("treeId")

                                        if treeGroupId == groupId and treeId and 
                                        data.trees[groupId][treeId] and 
                                        data.trees[groupId][treeId].hp > 0 and
                                        not data.trees[groupId][treeId].respawn then

                                            local primaryPart = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                                            if primaryPart then
                                                local distance = (primaryPart.Position - playerPosition).Magnitude
                                                if distance < closestDistance then
                                                    closestDistance = distance
                                                    targetTree = tree
                                                end
                                            end
                                        end
                                    end
                                end
                            end

                            if not targetTree then
                                TreeController.getRay = originalGetRay
                                TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                                return
                            end

                            TreeController:sendRayFromInput(0, 0)
                            TreeController.getRay = originalGetRay
                            TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                        end)
                    end

                    while autoBreakRunning do
                        simulateClickOnClosestTree()
                        task.wait(1)
                    end
                end)

                local teleportThread = task.spawn(function()
                    if not game:IsLoaded() then game.Loaded:Wait() end

                    local lumberId = getLumberId()
                    local currentGroup, currentId, lastTeleportTime = nil, nil, 0
                    math.randomseed(os.time() + os.clock() * 1000)

                    local data = DataController:getData()
                    while not data or not data.trees do
                        task.wait(0.5)
                        data = DataController:getData()
                    end

                    local function selectRandomTreeGroup()
                        data = DataController:getData()
                        if not data or not data.trees then return nil end

                        local validGroups = {}
                        for _, groupId in ipairs(selectedTrees) do
                            if data.trees[groupId] then
                                local hasActiveTrees = false
                                for treeId, treeData in pairs(data.trees[groupId]) do
                                    if treeData.hp > 0 and not treeData.respawn then
                                        hasActiveTrees = true
                                        break
                                    end
                                end
                                if hasActiveTrees then table.insert(validGroups, groupId) end
                            end
                        end

                        return #validGroups > 0 and validGroups[math.random(1, #validGroups)] or nil
                    end

                    local function findAndTeleportToRandomTree()
                        currentGroup = selectRandomTreeGroup()
                        if not currentGroup then return false end

                        if data.trees[currentGroup] then
                            local activeTrees = getActiveTreesInGroup(currentGroup, data)
                            if #activeTrees > 0 then
                                local randomTreeIndex = math.random(1, #activeTrees)
                                currentId = activeTrees[randomTreeIndex].treeId

                                local teleportSuccess = pcall(function()
                                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                        local mapsFolder = Workspace:FindFirstChild("Game") and Workspace.Game:FindFirstChild("Maps")
                                        if mapsFolder then
                                            local mapName = nil
                                            for _, map in pairs(mapsFolder:GetChildren()) do
                                                if map.Name:lower() == currentGroup:lower() then
                                                    mapName = map.Name
                                                    break
                                                end
                                            end

                                            if mapName then
                                                local treesFolder = mapsFolder[mapName]:FindFirstChild("Trees")
                                                if treesFolder then
                                                    for _, tree in pairs(treesFolder:GetChildren()) do
                                                        if tree:GetAttribute("treeId") == currentId then
                                                            local model = tree:FindFirstChildWhichIsA("Model")
                                                            if model then
                                                                LocalPlayer.Character.HumanoidRootPart.CFrame = model:GetPivot() + Vector3.new(0, 5, 0)
                                                                lastTeleportTime = os.time()
                                                                return true
                                                            end
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    return false
                                end)

                                if teleportSuccess then
                                    return true
                                else
                                    currentGroup, currentId = nil, nil
                                    return false
                                end
                            end
                        end

                        currentGroup, currentId = nil, nil
                        return false
                    end

                    while autoBreakRunning do
                        local shouldFindNewTree = not currentGroup or not currentId
                        
                        if not shouldFindNewTree then
                            data = DataController:getData()
                            if not data or not data.trees or 
                            not data.trees[currentGroup] or 
                            not data.trees[currentGroup][currentId] or
                            data.trees[currentGroup][currentId].hp <= 0 or 
                            data.trees[currentGroup][currentId].respawn then
                                shouldFindNewTree = true
                            end
                        end

                        if shouldFindNewTree then
                            findAndTeleportToRandomTree()
                        else
                            local currentTime = os.time()
                            if (currentTime - lastTeleportTime >= 3) then
                                pcall(function()
                                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                        local mapsFolder = Workspace:FindFirstChild("Game") and Workspace.Game:FindFirstChild("Maps")
                                        if mapsFolder then
                                            local mapName = nil
                                            for _, map in pairs(mapsFolder:GetChildren()) do
                                                if map.Name:lower() == currentGroup:lower() then
                                                    mapName = map.Name
                                                    break
                                                end
                                            end

                                            if mapName then
                                                local treesFolder = mapsFolder[mapName]:FindFirstChild("Trees")
                                                if treesFolder then
                                                    for _, tree in pairs(treesFolder:GetChildren()) do
                                                        if tree:GetAttribute("treeId") == currentId then
                                                            local model = tree:FindFirstChildWhichIsA("Model")
                                                            if model then
                                                                LocalPlayer.Character.HumanoidRootPart.CFrame = model:GetPivot() + Vector3.new(0, 5, 0)
                                                                lastTeleportTime = currentTime
                                                                return
                                                            end
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end)
                            end
                        end

                        if currentGroup and currentId and 
                        data.trees[currentGroup] and 
                        data.trees[currentGroup][currentId] and
                        data.trees[currentGroup][currentId].hp > 0 and 
                        not data.trees[currentGroup][currentId].respawn then
                            TreeService.damage2:Fire(currentGroup, currentId, lumberId)
                        end

                        task.wait(0.1)
                    end
                end)

                _G.TreeCuttingThreads = {
                    treeControllerThread = treeControllerThread,
                    teleportThread = teleportThread
                }

            else
                if _G.TreeCuttingThreads then
                    for name, thread in pairs(_G.TreeCuttingThreads) do
                        if thread then task.cancel(thread) end
                    end
                    _G.TreeCuttingThreads = nil
                end

                if TreeController._currentTree then
                    TreeController:cancelAutoDamageTree()
                end
            end
        end
    })

    lowercooldown = TreeSection:Toggle("RemoveCooldown", {
        Title = "Reduce Cutting Cooldown",
        Description = "Reduces the cooldown between tree hits (about 1.5x faster). Already built in with the auto trees toggle.",
        Default = false,
        Callback = function(Value)
            if Value then
                TreeController._debounce = {}
                TreeController._debounce = setmetatable({}, {
                    __index = function() return false end,
                    __newindex = function() end
                })
            else
                TreeController._debounce = {}
            end
        end
    })

    BypassStrength = TreeSection:Toggle("BypassTreeStrength", {
        Title = "Axe Strength Bypass",
        Description = "Allows you to cut any tree regardless of your current axe strength",
        Default = false,
        Callback = function(Value)
            if Value then
                if not TreeController._originalIsStrongEnough then
                    TreeController._originalIsStrongEnough = TreeController.isStrongEnough
                end
                TreeController.isStrongEnough = function() return true end
            else
                if TreeController._originalIsStrongEnough then
                    TreeController.isStrongEnough = TreeController._originalIsStrongEnough
                end
            end
        end
    })

    isAutoEquipAxeEnabled = false
    AutoEquip = TreeSection:Toggle("AutoEquipBestAxe", {
        Title = "Auto Equip Best Axe",
        Description = "Automatically equips the best axe you own.",
        Default = false,
        Callback = function(enabled)
            isAutoEquipAxeEnabled = enabled
            if enabled then
                task.spawn(function()
                    while isAutoEquipAxeEnabled do
                        pcall(function()
                            local ExclusiveItems = require(ReplicatedStorage.Shared.List.Items.Exclusive)
                            DataController:waitForData()
                            local playerData = DataController:getData()

                            local bestAxe, bestAxeIndex, bestInventoryIndex = nil, 0, nil
                            for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                                local itemObj = Util.itemUtils.createItemFromData(itemData)
                                local itemName = itemObj:getName()

                                if itemName:lower():find("axe") and not itemName:lower():find("pickaxe") then
                                    local axeData = ExclusiveItems[itemName]
                                    if axeData and axeData.index and axeData.index > bestAxeIndex then
                                        bestAxeIndex = axeData.index
                                        bestAxe = itemObj:getRealName()
                                        bestInventoryIndex = inventoryIndex
                                    end
                                end
                            end

                            if not bestAxe then return end

                            local isAxeEquipped = playerData.isAxeEquipped

                            if not isAxeEquipped then
                                InventoryService:useItem(bestInventoryIndex)
                            else
                                local currentAxe, currentAxeIndex, currentInventoryIndex = nil, 0, nil
                                for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                                    local itemObj = Util.itemUtils.createItemFromData(itemData)
                                    if itemObj:getName():lower():find("axe") and not itemObj:getName():lower():find("pickaxe") then
                                        currentAxe = itemObj:getRealName()
                                        currentAxeIndex = itemObj:directory()[itemObj:getName()].index
                                        currentInventoryIndex = inventoryIndex
                                        break
                                    end
                                end

                                if not (currentAxeIndex == bestAxeIndex and currentInventoryIndex == bestInventoryIndex) then
                                    InventoryService:useItem(bestInventoryIndex)
                                end
                            end
                        end)

                        for i = 1, 50 do
                            if not isAutoEquipAxeEnabled then break end
                            task.wait(0.1)
                        end
                    end
                end)
            end
        end
    })

    UpgradeAxe = Tabs.Tree:AddSection("Upgrade Axe")
    
    UpgradeAxe:Button({
    Title = "Enable Recommended Settings",
    Description = "Automatically enables: Auto Equip Best Axe, Reduce Cutting Cooldown, and Axe Strength Bypass",
    Callback = function()
        AutoEquip:SetValue(true)
        lowercooldown:SetValue(true) 
        BypassStrength:SetValue(true)
    end})

    local UpgradeStatusParagraph = UpgradeAxe:Paragraph("AxeUpgradeStatus", {
        Title = "Axe Upgrade",
        Content = "Loading upgrade info...",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    updateAxeUpgradeStatus = function()
        pcall(function()
            local ExclusiveItems = require(ReplicatedStorage.Shared.List.Items.Exclusive)
            local Items = require(ReplicatedStorage.Shared.Items)
            local AxesList = require(ReplicatedStorage.Shared.List.Axes)

            DataController:waitForData()
            local playerData = DataController:getData()

            local currentAxeIndex = 0
            for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                local itemObj = Util.itemUtils.createItemFromData(itemData)
                if itemObj:getName():lower():find("axe") and not itemObj:getName():lower():find("pickaxe") then
                    currentAxeIndex = itemObj:directory()[itemObj:getName()].index
                    break
                end
            end

            if currentAxeIndex == 0 then
                UpgradeStatusParagraph:SetValue(" No axe found in inventory!")
                return
            end

            local nextAxeIndex = currentAxeIndex + 1
            local nextAxe, nextAxeName = nil, nil

            for itemName, itemData in pairs(ExclusiveItems) do
                if itemName:lower():find("axe") and not itemName:lower():find("pickaxe") then
                    if itemData.index == nextAxeIndex then
                        nextAxe = Items.exclusive(itemName)
                        nextAxeName = itemName
                        break
                    end
                end
            end

            if not nextAxe then
                UpgradeStatusParagraph:SetValue(" You have the maximum axe!")
                return
            end

            local axeRequirements = AxesList[nextAxeName]
            if not axeRequirements or not axeRequirements.required then
                UpgradeStatusParagraph:SetValue(" No requirements found for next axe!")
                return
            end

            local statusLines = {}
            table.insert(statusLines, " Next: " .. nextAxe:getRealName())
            table.insert(statusLines, "")
            table.insert(statusLines, " Materials Needed:")

            local canUpgrade = true

            for i, requiredItem in ipairs(axeRequirements.required) do
                local itemName = requiredItem:getName()
                local requiredAmount = requiredItem:getAmount()

                local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
                local currentAmount = currentItem and currentItem:getAmount() or 0

                local hasEnough = requiredAmount <= currentAmount
                if not hasEnough then canUpgrade = false end

                local status = hasEnough and "" or ""
                local progress = string.format("%s/%s", 
                    Functions.comma(currentAmount), 
                    Functions.comma(requiredAmount))

                table.insert(statusLines, string.format("%s %s: %s", status, itemName, progress))
            end

            table.insert(statusLines, "")
            table.insert(statusLines, " Status: " .. (canUpgrade and "Ready to upgrade!" or "Need more materials"))

            UpgradeStatusParagraph:SetValue(table.concat(statusLines, "\n"))
        end)
    end
    
    task.spawn(function()
        while true do
            updateAxeUpgradeStatus()
            task.wait(5)
        end
    end)
    
    originalSelectedObjects = {}
    originalAutoCutState = false
    isAutoUpgradeEnabled = false
    treeToggleThread = nil

    manageTreeToggleCycle = function()
        while isAutoUpgradeEnabled do
            if autoBreakRunning then
                AutoCutTreesToggle:SetValue(false)
            end
            task.wait(1)
            
            if not autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            end
            task.wait(0.5)
            
            if autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            end
            task.wait(1)
            
            if not autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            end
            
            task.wait(20)
        end
    end

    UpgradeAxe:Toggle("AutoUpgradeAxe", {
        Title = "Auto Upgrade Axe",
        Description = "Automatically upgrades your axe when materials are available\n\n Recommended to enable:\n Axe Strength Bypass\n Auto Equip Best Axe",
        Default = false,
        Callback = function(enabled)
            if enabled then
                isAutoUpgradeEnabled = true

                originalSelectedObjects = {}
                for treeObject, isSelected in pairs(SelectTreesDropdown.Value) do
                    originalSelectedObjects[treeObject] = isSelected
                end

                originalAutoCutState = autoBreakRunning

                if treeToggleThread then task.cancel(treeToggleThread) end
                treeToggleThread = task.spawn(manageTreeToggleCycle)

                task.spawn(function()
                    while isAutoUpgradeEnabled do
                        pcall(function()
                            local ExclusiveItems = require(ReplicatedStorage.Shared.List.Items.Exclusive)
                            local Items = require(ReplicatedStorage.Shared.Items)
                            local AxesList = require(ReplicatedStorage.Shared.List.Axes)

                            DataController:waitForData()
                            local playerData = DataController:getData()

                            local currentAxeIndex = 0
                            for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                                local itemObj = Util.itemUtils.createItemFromData(itemData)
                                if itemObj:getName():lower():find("axe") and not itemObj:getName():lower():find("pickaxe") then
                                    currentAxeIndex = itemObj:directory()[itemObj:getName()].index
                                    break
                                end
                            end

                            if currentAxeIndex == 0 then return end

                            local nextAxeIndex = currentAxeIndex + 1
                            local nextAxeName = nil

                            for itemName, itemData in pairs(ExclusiveItems) do
                                if itemName:lower():find("axe") and not itemName:lower():find("pickaxe") then
                                    if itemData.index == nextAxeIndex then
                                        nextAxeName = itemName
                                        break
                                    end
                                end
                            end

                            if not nextAxeName then
                                isAutoUpgradeEnabled = false
                                return
                            end

                            local nextAxe = Items.exclusive(nextAxeName)
                            local axeRequirements = AxesList[nextAxeName]
                            if not axeRequirements or not axeRequirements.required then return end

                            local neededWoods = {}
                            local canUpgrade = true

                            for _, requiredItem in ipairs(axeRequirements.required) do
                                local itemName = requiredItem:getName()
                                local requiredAmount = requiredItem:getAmount()

                                local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
                                local currentAmount = currentItem and currentItem:getAmount() or 0

                                if currentAmount < requiredAmount then
                                    canUpgrade = false
                                    if itemName:lower():find("wood") then
                                        table.insert(neededWoods, itemName)
                                    end
                                end
                            end

                            if canUpgrade then
                                AxeService:upgradeAxe()
                                task.wait(2)
                            else
                                local neededTreeObjects = {}
                                for _, woodName in ipairs(neededWoods) do
                                    local treeWorld = mapWoodToTreeWorld(woodName)
                                    for _, treeObject in ipairs(SelectTreesDropdown.Values) do
                                        if treeObject.Value == treeWorld then
                                            neededTreeObjects[treeObject] = true
                                            break
                                        end
                                    end
                                end

                                SelectTreesDropdown:SetValue(neededTreeObjects)
                            end
                        end)
                        task.wait(5)
                    end
                end)
            else
                isAutoUpgradeEnabled = false
                
                if treeToggleThread then
                    task.cancel(treeToggleThread)
                    treeToggleThread = nil
                end
                
                SelectTreesDropdown:SetValue(originalSelectedObjects)

                if autoBreakRunning ~= originalAutoCutState then
                    AutoCutTreesToggle:SetValue(originalAutoCutState)
                end
            end
        end
    })

    getAllNonWoodRequirements = function()
        local AxesModule = require(ReplicatedStorage.Shared.List.Axes)
        local allRequirements = {}
        local requirementMap = {}
        
        for axeName, axeData in pairs(AxesModule) do
            if axeData.required then
                for _, item in ipairs(axeData.required) do
                    local amount = (item.getAmount and item:getAmount()) or item.Amount or 1
                    local itemName = (item.getName and item:getName()) or item.Name or "Unknown"

                    if not itemName:lower():find("wood") then
                        if axeName:lower():find("dungeon") and itemName:lower():find("pickaxe") then
                            itemName = "dungeonPotion"
                        elseif itemName:lower() == "dungeon" then
                            itemName = "dungeonPotions"
                        end
                        
                        if not requirementMap[itemName] or amount > requirementMap[itemName] then
                            requirementMap[itemName] = amount
                        end
                    end
                end
            end
        end
        
        for itemName, maxAmount in pairs(requirementMap) do
            table.insert(allRequirements, maxAmount .. "x " .. itemName)
        end
        
        if #allRequirements > 0 then
            return "Note you will need to own at least:\n" .. table.concat(allRequirements, ", ")
        else
            return "Note: Only wood is required for axe upgrades!"
        end
    end

    UpgradeAxe:Paragraph("NonWoodNote", {
        Title = "Additional Items",
        Content = getAllNonWoodRequirements(),
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    local BuyFarmSection = Tabs.Farm:AddSection("Buy Farms")


    getAllFarms = function()
        local options, map = {}, {}
        pcall(function()
            local FarmsList = require(ReplicatedStorage.Shared.List.Farms)
            for farmId, farmInfo in pairs(FarmsList) do
                -- Exclude farmer and other non-purchasable items
                if not farmId:lower():find("1234") and 
                not farmInfo.isNotFarm and 
                farmInfo.price and 
                farmId ~= "farmer" then  -- Exclude farmer from auto-buy
                    local name = farmInfo.name or farmId
                    table.insert(options, name)
                    map[name] = farmId
                end
            end
            
            -- Don't add farmer to the options at all
        end)
        table.sort(options)
        return options, map
    end

    local farmOptions, farmIdMap = getAllFarms()

    local farmDropdown = BuyFarmSection:Dropdown("SelectFarms", {
        Title = "Select Farms to Buy",
        Values = farmOptions,
        Multi = true,
        Default = {}
    })

    local BuyFarm = BuyFarmSection:Toggle("AutoBuyFarms", {
        Title = "Auto Buy Selected Farms",
        Description = "Buy farms when you can afford them",
        Default = false,
        Callback = function(s) _G.AutoBuyFarms = s end
    })

    task.spawn(function()
        while task.wait(5) do -- Check every 5 seconds
            if not _G.AutoBuyFarms then continue end
            pcall(function()
                local playerData, FarmsList = DataController:getData(), require(ReplicatedStorage.Shared.List.Farms)
                if not playerData then return end
                
                -- Get selected farms, or use all farms if none selected
                local farmsToCheck = farmDropdown.Value or {}
                if not next(farmsToCheck) then
                    -- If no farms selected, check all available farms (excluding farmer)
                    for _, farmName in ipairs(farmOptions) do
                        farmsToCheck[farmName] = true
                    end
                end
                
                for farmName, selected in pairs(farmsToCheck) do
                    if selected then
                        local farmId = farmIdMap[farmName]
                        local farmInfo = FarmsList[farmId]
                        if farmId and farmInfo and 
                        (playerData.gems or 0) >= (farmInfo.price or 0) and 
                        not (playerData.farms and playerData.farms[farmId]) then
                            FarmService:buy(farmId)
                            task.wait(1) -- Wait 1 second after each purchase
                        end
                    end
                end
            end)
        end
    end)

  local AutoUpgradeFarmSection = Tabs.Farm:AddSection("Auto Upgrade Farms")

    getAllFarmsWithOptions = function()
        local options, farmMap = {}, {}
        pcall(function()
            local FarmsList = require(ReplicatedStorage.Shared.List.Farms)
            local tempFarms = {}
            for id, info in pairs(FarmsList) do
                if not id:lower():find("1234") and not info.isNotFarm and info.upgrades then
                    local name = info.name or id
                    table.insert(tempFarms, { id = id, name = name })
                end
            end
            if FarmsList.farmer and FarmsList.farmer.upgrades then
                table.insert(tempFarms, { id = "farmer", name = "farmer" })
            end
            table.sort(tempFarms, function(a, b) return a.name < b.name end)
            for _, data in ipairs(tempFarms) do
                table.insert(options, data.name)
                farmMap[data.name] = data.id
            end
        end)
        return options, farmMap
    end

    local allFarmOptions, allFarmIdMap = getAllFarmsWithOptions()

    local upgradeDropdown = AutoUpgradeFarmSection:Dropdown("SelectFarmsToUpgrade", {
        Title = "Select Farms to Upgrade",
        Values = allFarmOptions,
        Multi = true,
        Searchable = true,
        Default = {}
    })

    AutoUpgradeFarmSection:Toggle("AutoUpgradeFarms", {
        Title = "Auto Upgrade Selected Farms",
        Description = "Auto buys upgrades for the selected farms (must own).",
        Default = false,
        Callback = function(s) _G.AutoUpgradeFarms = s end
    })

    -- NEW: "Buy Burst" loop logic
    task.spawn(function()
        while true do -- This is the main loop with the 5-second wait at the end.
            if _G.AutoUpgradeFarms and next(upgradeDropdown.Value or {}) then
                pcall(function()
                    -- This inner loop is the "buy burst". It will run rapidly until no more upgrades can be afforded.
                    while true do 
                        local selected = upgradeDropdown.Value
                        local FarmsList = require(ReplicatedStorage.Shared.List.Farms)
                        local playerData = DataController:getData()
                        if not playerData then break end -- Exit burst if data is lost

                        local affordableUpgrades = {}

                        -- Step 1: Find ALL currently affordable upgrades
                        for farmName, isSelected in pairs(selected) do
                            if isSelected then
                                local farmId = allFarmIdMap[farmName]
                                local farmConfig = FarmsList[farmId]
                                if farmId and farmConfig and farmConfig.upgrades and (playerData.farms and playerData.farms[farmId]) then
                                    local currentLevel = playerData.farms[farmId].stage or 0
                                    local nextLevel = currentLevel + 1
                                    local nextUpgradeInfo = farmConfig.upgrades[nextLevel]
                                    if nextUpgradeInfo then
                                        local upgradeCost = nextUpgradeInfo.price or 0
                                        if (playerData.gems or 0) >= upgradeCost then
                                            table.insert(affordableUpgrades, {id = farmId, cost = upgradeCost})
                                        end
                                    end
                                end
                            end
                        end

                        -- Step 2: If there's nothing to buy, exit the burst loop.
                        if #affordableUpgrades == 0 then
                            break 
                        end

                        -- Step 3: Sort to find the CHEAPEST affordable upgrade
                        table.sort(affordableUpgrades, function(a, b)
                            return a.cost < b.cost
                        end)
                        
                        local cheapestUpgrade = affordableUpgrades[1]

                        FarmService:upgrade(cheapestUpgrade.id)
                        task.wait(0.3) 
                    end
                end)
            end 
            task.wait(5) 
        end
    end)

    local AutoClaimSection = Tabs.Farm:AddSection("Auto Claim")

    getAllFarmsForClaim = function()
        local options, farmMap = {}, {}
        pcall(function()
            local FarmsList = require(ReplicatedStorage.Shared.List.Farms)
            for farmId, farmInfo in pairs(FarmsList) do
                if not farmId:lower():find("farmer") and not farmInfo.isNotFarm then
                    local name = farmInfo.name or farmId
                    table.insert(options, name)
                    farmMap[name] = farmId
                end
            end
        end)
        table.sort(options)
        return options, farmMap
    end

    local claimFarmOptions, claimFarmIdMap = getAllFarmsForClaim()

    local claimDropdown = AutoClaimSection:Dropdown("SelectFarmsToClaim", {Title = "Select Farms to Auto-Claim", Values = claimFarmOptions, Multi = true, Default = {}})
    local AutoClaimFarm = AutoClaimSection:Toggle("AutoClaimFarms", {Title = "Auto Claim Farms" , Description = "Automatically claims fruits from selected farms.", Default = false, Callback = function(s) _G.AutoClaimFarms = s end})

    -- This function is no longer needed but kept to avoid breaking other references if any.
    isFarmReady = function() return false end

    -- CORRECTED: The main loop is now properly structured.
    task.spawn(function()
        while true do
            -- Only run if the toggle is on and at least one farm is selected.
            if _G.AutoClaimFarms and next(claimDropdown.Value or {}) then
                pcall(function()
                    
                    local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
                    local FarmService = Knit.GetService("FarmService")
                    
                    -- Loop through every farm the user has selected in the UI.
                    for farmName, selected in pairs(claimDropdown.Value) do
                        if selected then
                            local farmId = claimFarmIdMap[farmName]
                            
                            if farmId then
                                FarmService:claim(farmId)
                                task.wait(0.2) -- Small wait between each remote fire
                            end
                        end
                    end
                end)
            end
            
            -- FIX: The main 10-second wait is now here, controlling the frequency of the entire cycle.
            task.wait(10) 
        end
    end)
    
    local CraftPetSection = Tabs.Pet:AddSection("Craft Pets")
    petDisplayToId = {}
    local PetStatusParagraph = CraftPetSection:AddParagraph("PetCraftStatus", { Title = "Selected Pet Status", Content = "Select a pet to see details." })
    
    getPlayerPetOptions = function()
        petDisplayToId = {}
        local petOptions, addedNames = {}, {}
        pcall(function()
            local Tiers = require(ReplicatedStorage.Shared.List.Pets.Tiers)
            local playerData = DataController:getData()
            if not (playerData and playerData.inventory and playerData.inventory.pet) then return end
            for petId, petRawData in pairs(playerData.inventory.pet) do
                local petObject = Util.itemUtils.createItemFromData(petRawData)
                if petObject then
                    local s, name = pcall(function() return petObject:getName() end)
                    if s then
                        local tierNum
                        local isShiny = (petRawData.sh == true)
                        pcall(function() tierNum = petObject:getTier() end)
                        local tierName = (tierNum and Tiers[tierNum]) and Tiers[tierNum].name or ""
                        if tierName == "Normal" then tierName = "" end
                        local nameParts = {}
                        if tierName ~= "" then table.insert(nameParts, tierName) end
                        if isShiny then table.insert(nameParts, "Shiny") end
                        table.insert(nameParts, name)
                        local displayName = table.concat(nameParts, " ")
                        if not addedNames[displayName] then
                            table.insert(petOptions, displayName)
                            petDisplayToId[displayName] = petId
                            addedNames[displayName] = true
                        end
                    end
                end
            end
        end)
        if #petOptions == 0 then return {"No pets found"} end
        table.sort(petOptions)
        return petOptions
    end

    updatePetStatusParagraph = function(selectedPets)
        if not selectedPets or next(selectedPets) == nil then PetStatusParagraph:SetContent("No pets selected."); return end
        local playerData = DataController:getData()
        if not (playerData and playerData.inventory and playerData.inventory.pet) then PetStatusParagraph:SetContent("Could not find pet inventory."); return end
        local contentLines = {}
        for displayName, isSelected in pairs(selectedPets) do
            if isSelected then
                local petId = petDisplayToId[displayName]
                if petId and playerData.inventory.pet[petId] then
                    local petObject = Util.itemUtils.createItemFromData(playerData.inventory.pet[petId])
                    if petObject then
                        local _, amount = pcall(function() return petObject:getAmount() end)
                        table.insert(contentLines, string.format("%s (Amount: %d) - ID: %s", displayName, amount or 0, petId))
                    end
                else table.insert(contentLines, string.format("%s (Amount: 0) - ID: %s", displayName, petId or "N/A")) end
            end
        end
        PetStatusParagraph:SetContent(#contentLines == 0 and "No pets selected." or table.concat(contentLines, "\n"))
    end

    local PetDropdown = CraftPetSection:AddDropdown("SelectPetToCraft", {
        Title = "Select Pet(s) to Craft", Values = getPlayerPetOptions(), Multi = true, Searchable = true, Default = {},
        Callback = function(value) updatePetStatusParagraph(value) end
    })

    CraftPetSection:AddButton({ Title = "Refresh Pet List", Callback = function() PetDropdown:SetValues(getPlayerPetOptions()); PetDropdown:SetValue({}); updatePetStatusParagraph({}) end })
    CraftPetSection:AddParagraph("CraftingNote", { Title = "Note", Content = "Crafting requires at least 5 of the same pet to create 1 of the next tier. You might need to rejoin after trying to craft a galaxy pet, and be aware that the pet needs to be released after the space update in order to craft to galaxy." })
    local CraftAmountInput = CraftPetSection:AddInput("CraftAmountInput", { Title = "Craft Amount", Default = "1", Numeric = true })

    CraftPetSection:AddButton({ Title = "Craft Specific Amount",
        Callback = function()
            local selectedPets, amount = PetDropdown.Value, tonumber(CraftAmountInput.Value) or 1
            if not next(selectedPets) then return end
            for displayName, isSelected in pairs(selectedPets) do
                if isSelected then
                    local petId = petDisplayToId[displayName]
                    if petId then pcall(function() PetService:craft({[1]=petId}, false, amount) end); task.wait(0.2) end
                end
            end
            task.wait(1); PetDropdown:SetValues(getPlayerPetOptions()); updatePetStatusParagraph(PetDropdown.Value)
        end
    })

    local CraftAllToggle = CraftPetSection:AddToggle("CraftAllToggle", { Title = "Craft All (Selected)", Default = false })
    CraftAllToggle:OnChanged(function()
        if CraftAllToggle.Value then
            task.spawn(function()
                while CraftAllToggle.Value do
                    local selectedPets, crafted = PetDropdown.Value, false
                    if next(selectedPets) then
                        for displayName, isSelected in pairs(selectedPets) do
                            if isSelected and CraftAllToggle.Value then
                                local petId = petDisplayToId[displayName]
                                if petId then pcall(function() PetService:craft({[1]=petId}, true, 1) end); crafted=true; task.wait(0.5) end
                            end
                        end
                    end
                    if crafted then task.wait(1); PetDropdown:SetValues(getPlayerPetOptions()) end
                    task.wait(1)
                end
            end)
        end
    end)

    task.spawn(function() while task.wait(3) do if PetDropdown and PetDropdown.Value and next(PetDropdown.Value) then pcall(updatePetStatusParagraph, PetDropdown.Value) end end end)


    
    local machines = Tabs.Machine:AddSection("Machine Script")
    
    machines:Button({
        Title = "Load Script",
        Description = "Sorry for the separate loadstring! Having such a large script was causing me to run out of local uses and creating lag issues.",
        Callback = function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/RCU-machine/refs/heads/main/RCU."))()
        end
    })


    -- Function to check if player is in dungeon
    local function isInDungeon()
        local success, result = pcall(function()
            local DungeonController = Knit.GetController("DungeonController")
            return DungeonController:isInDungeon()
        end)
        return success and result or false
    end

    AutoCritDamageSection = Tabs.Dunegon:AddSection("Auto Crit/Damage")

    local autoCriticalTapEnabled = false
    local inDungeon = false

    -- Check dungeon status every 5 seconds
    task.spawn(function()
        while true do
            if autoCriticalTapEnabled then
                inDungeon = isInDungeon()
            end
            task.wait(5)
        end
    end)

    AutoCritDamageSection:Toggle("AutoCriticalTap", {
        Title = "Auto Critical Tap",
        Description = "You will always deal 1000x damage. Incredibly overpowered.",
        Default = false,
        Callback = function(Value)
            autoCriticalTapEnabled = Value
            if Value then
                inDungeon = isInDungeon() 
                task.spawn(function()
                    while autoCriticalTapEnabled do
                        if inDungeon then
                            pcall(function()
                                DungeonService.damage._re:FireServer()
                                DungeonService.criticalTap._re:FireServer()
                            end)
                        end
                        task.wait(0.15)
                    end
                end)
            end
        end
    })

    AutoPickupPowerups = Tabs.Dunegon:AddSection("Auto Use Powerups")

    AutoPickupPowerups:Toggle("AutoPickupPowerups", {
        Title = "Auto Pickup Powerups",
        Description = "Automatically picks up all available dungeon powerups.",
        Default = false,
        Callback = function(Value)
            autoPickupEnabled = Value
            if Value then
                task.spawn(function()
                    local Powerups = require(ReplicatedStorage.Shared.List.Dungeon.Powerups)

                    -- Precompute lowercase module keys for case-insensitive comparison
                    local moduleKeys = {}
                    for key, _ in pairs(Powerups) do
                        moduleKeys[key:lower()] = key
                    end

                    while autoPickupEnabled do
                        if isInDungeon() then
                            local character = LocalPlayer.Character
                            local rootPart = character and character:FindFirstChild("HumanoidRootPart")

                            if rootPart then
                                local debrisFolder = workspace:FindFirstChild("Debris")
                                if debrisFolder then
                                    for _, child in ipairs(debrisFolder:GetChildren()) do
                                        local childKey = child.Name:gsub("%s",""):lower()
                                        if moduleKeys[childKey] then
                                            local touchFired = false
                                            -- Loop through all parts of this powerup to find TouchInterest
                                            for _, part in ipairs(child:GetChildren()) do
                                                local touch = part:FindFirstChild("TouchInterest")
                                                if touch then
                                                    pcall(function()
                                                        firetouchinterest(rootPart, part, 0)
                                                        firetouchinterest(rootPart, part, 1)
                                                    end)
                                                    touchFired = true
                                                    task.wait(0.25)
                                                    break -- fire only once per powerup
                                                end
                                            end
                                            -- If TouchInterest is directly on the parent
                                            if not touchFired then
                                                local touch = child:FindFirstChild("TouchInterest")
                                                if touch then
                                                    pcall(function()
                                                        firetouchinterest(rootPart, child, 0)
                                                        firetouchinterest(rootPart, child, 1)
                                                    end)
                                                    task.wait(0.25)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        task.wait(3)
                    end
                end)
            end
        end
    })

    EquipBest = Tabs.Dunegon:AddSection("Equip Best Pets")
        
    local equipBestPetsEnabled = false

    EquipBest:Toggle("EquipBestDungeonPets", {
        Title = "Equip Best Dungeon Pets",
        Description = "Automatically equips the best dungeon pets and removes weaker ones. Checks every 5 seconds.",
        Default = false,
        Callback = function(Value)
            equipBestPetsEnabled = Value
            if Value then
                task.spawn(function()
                    while equipBestPetsEnabled do
                        pcall(function()
                            local itemUtils = require(ReplicatedStorage.Shared.Util).itemUtils
                            local data = DataController:getData()
                            if not data then return end
                            
                            -- Get max equippable pets from label
                            local label = game:GetService("Players").LocalPlayer.PlayerGui.MainUI.Menus.DungeonJoinFrame.Main.Default.YourTeamLabel
                            local text = label.Text -- e.g., "Your Team 7/10"
                            local maxEquippable = tonumber(string.match(text, "%d+/%d+"):match("/(%d+)"))
                            
                            -- Get all dungeon pets and sort by multiplier
                            local dungeonPets = {}
                            if data.inventory.pet then
                                for petId, _ in pairs(data.inventory.pet) do
                                    local pet = itemUtils.getItemFromId(data, petId)
                                    if pet and pet:getSpecialMultiplierName() == "dungeonDamage" then
                                        table.insert(dungeonPets, {
                                            id = petId,
                                            multiplier = pet:getSpecialMultiplierAmount(),
                                            amount = pet:getAmount()
                                        })
                                    end
                                end
                            end
                            
                            -- Sort by multiplier (highest first)
                            table.sort(dungeonPets, function(a, b)
                                return a.multiplier > b.multiplier
                            end)
                            
                            -- Get best pets to equip
                            local bestPetsToEquip = {}
                            local totalPetsToEquip = 0
                            for _, petData in ipairs(dungeonPets) do
                                if totalPetsToEquip < maxEquippable then
                                    local petsToEquip = math.min(petData.amount, maxEquippable - totalPetsToEquip)
                                    if petsToEquip > 0 then
                                        bestPetsToEquip[petData.id] = petsToEquip
                                        totalPetsToEquip = totalPetsToEquip + petsToEquip
                                    end
                                end
                            end
                            
                            -- Remove pets that shouldn't be equipped
                            if data.dungeonTeam then
                                for equippedPetId, equippedAmount in pairs(data.dungeonTeam) do
                                    local shouldKeep = bestPetsToEquip[equippedPetId]
                                    local correctAmount = shouldKeep and bestPetsToEquip[equippedPetId] or 0
                                    
                                    if not shouldKeep or equippedAmount > correctAmount then
                                        local removeAmount = equippedAmount - correctAmount
                                        for i = 1, removeAmount do
                                            DungeonService:removePetFromTeam(equippedPetId)
                                            task.wait(0.1)
                                        end
                                    end
                                end
                            end
                            
                            -- Add best pets that aren't equipped or need more
                            for petId, targetAmount in pairs(bestPetsToEquip) do
                                local currentEquipped = (data.dungeonTeam and data.dungeonTeam[petId]) or 0
                                local needToAdd = targetAmount - currentEquipped
                                
                                for i = 1, needToAdd do
                                    DungeonService:addPetToTeam(petId)
                                    task.wait(0.1)
                                end
                            end
                        end)
                        
                        task.wait(5) -- Check every 5 seconds
                    end
                end)
            end
        end
    })

    local DungeonAutoJoinSection = Tabs.Dunegon:AddSection("Auto Join Dungeon")

    -- Status element to show dungeon tickets
    local ticketStatus = DungeonAutoJoinSection:AddParagraph("Dungeon",{
        Title = "Dungeon Tickets",
        Content = "Checking..."
    })

    -- Function to update ticket status
    local function updateTicketStatus()
        pcall(function()
            local data = DataController:getData()
            local dungeonTicketItem = require(ReplicatedStorage.Shared.Util).itemUtils.getItemFromName(data, "dungeonTicket")
            
            if dungeonTicketItem and dungeonTicketItem:getAmount() > 0 then
                ticketStatus:SetValue("Dungeon Tickets: " .. dungeonTicketItem:getAmount())
            else
                ticketStatus:SetValue("No Dungeon Tickets")
            end
        end)
    end

    -- Update tickets every 5 seconds
    task.spawn(function()
        while true do
            updateTicketStatus()
            task.wait(5)
        end
    end)

    -- Get dungeon gamemodes for dropdown
    local DungeonGamemodes = require(ReplicatedStorage.Shared.List.Dungeon.DungeonGamemodes)
    local gamemodeOptions = {}
    for i, gamemode in ipairs(DungeonGamemodes) do
        table.insert(gamemodeOptions, string.format("%d. %s (%d tickets)", i, gamemode.name, gamemode.price))
    end

    -- Dropdown for gamemode selection
    local selectedGamemode = 1
    local gamemodeDropdown = DungeonAutoJoinSection:Dropdown("GamemodeSelect", {
        Title = "Select Dungeon Mode",
        Values = gamemodeOptions,
        Multi = false,
        Default = 1,
        Callback = function(Value)
            -- Extract the number from the selected option
            local gamemodeNumber = string.match(Value, "^(%d+)")
            selectedGamemode = tonumber(gamemodeNumber) or 1
        end
    })

    -- Auto join toggle
    local autoJoinEnabled = false
    DungeonAutoJoinSection:Toggle("AutoJoinDungeon", {
        Title = "Auto Join Dungeon",
        Description = "Automatically joins the selected dungeon gamemode. The game has no bosses in level 101, so if the script's aren't doing anything, it's because you will need to wait out the timer.",
        Default = false,
        Callback = function(Value)
            autoJoinEnabled = Value
            if Value then
                task.spawn(function()
                    -- Instant check when toggle is enabled
                    if not isInDungeon() then
                        pcall(function()
                            DungeonService:startDungeon(selectedGamemode)
                        end)
                        task.wait(3) 
                    else
                        task.wait(3)
                    end
                    
                    while autoJoinEnabled do
                        if not isInDungeon() then
                            pcall(function()
                                DungeonService:startDungeon(selectedGamemode)
                            end)
                            task.wait(3) 
                        else
                            task.wait(3) 
                        end
                    end
                end)
            end
        end
    })

    local DungeonUISection = Tabs.Dunegon:AddSection("Misc")

    local isHUDOverrideEnabled = false
    local isStopScreenShakeEnabled = false
    local originalHideHUD = nil
    local originalShakeScreen = nil
    local originalCriticalTap = nil

    DungeonUISection:Toggle("KeepHUDVisible", {
        Title = "Keep HUD Visible",
        Description = "Prevents the dungeon from hiding your HUD. This must be on before entering a dungeon to work.",
        Default = false,
        Callback = function(enabled)
            isHUDOverrideEnabled = enabled
            local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
            local UIController = Knit.GetController("UIController")
            if enabled then
                if not originalHideHUD then
                    originalHideHUD = UIController.hideHUD
                end
                UIController.hideHUD = function(self, hide, exceptions)
                    originalHideHUD(self, false, {["bottom"] = true})
                end
            else
                if originalHideHUD then
                    UIController.hideHUD = originalHideHUD
                end
            end
        end
    })

    DungeonUISection:Toggle("StopScreenShakes", {
        Title = "Stop Screen Shakes",
        Description = "Prevents dungeon screen shakes and critical tap effects.",
        Default = false,
        Callback = function(enabled)
            isStopScreenShakeEnabled = enabled
            local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
            local DC = Knit.GetController("DungeonController")
            if enabled then
                if not originalShakeScreen then
                    originalShakeScreen = DC.shakeScreen
                end
                if not originalCriticalTap then
                    originalCriticalTap = DC.criticalTap
                end
                DC.shakeScreen = function() end
                DC.criticalTap = function() end
            else
                if originalShakeScreen then
                    DC.shakeScreen = originalShakeScreen
                end
                if originalCriticalTap then
                    DC.criticalTap = originalCriticalTap
                end
            end
        end
    })
    
    local isPreventTeleportEnabled = false
    local originalTeleportFromRoom = nil

    DungeonUISection:Toggle("PreventTeleport", {
        Title = "Prevent Teleport",
        Description = "Prevents teleporting when the dungeon ends. DO NOT use this unless you are using the Auto Join Dungeon toggle, or you will be stuck.",
        Default = false,
        Callback = function(enabled)
            isPreventTeleportEnabled = enabled
            local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
            task.wait(2)
            local DC = Knit.GetController("DungeonController")
            if enabled then
                if not originalTeleportFromRoom then
                    originalTeleportFromRoom = DC.teleportFromRoom
                end
                DC.teleportFromRoom = function()
                end
            else
                if originalTeleportFromRoom then
                    DC.teleportFromRoom = originalTeleportFromRoom
                end
            end
        end
    })

    DungeonMerchant = Tabs.Dunegon:AddSection("Dungeon Shop")

    -- Get all dungeon shop items
    local function getAllDungeonShopItems()
        local options = {}
        local itemMap = {}
        
        pcall(function()
            local DungeonShop = require(ReplicatedStorage.Shared.List.Dungeon.Shop)
            
            for i, shopItem in ipairs(DungeonShop) do
                local item = shopItem.item
                local price = shopItem.price
                
                -- Get item name and amount using proper methods
                local itemName = "Unknown Item"
                local itemAmount = 1
                
                pcall(function()
                    -- Use the proper methods to get name and amount
                    if item.getName then
                        itemName = item:getName()
                    elseif item.getRealName then
                        itemName = item:getRealName()
                    end
                    
                    -- Get the amount using the proper method
                    if item.getAmount then
                        itemAmount = item:getAmount()
                    end
                end)
                
                -- Format display name with amount if greater than 1
                local displayName
                if itemAmount > 1 then
                    displayName = string.format("%dx %s - %s coins", itemAmount, itemName, Functions.suffixes(price))
                else
                    displayName = string.format("%s - %s coins", itemName, Functions.suffixes(price))
                end
                
                table.insert(options, displayName)
                itemMap[displayName] = {
                    item = item,
                    price = price,
                    index = i,
                    amount = itemAmount,
                    itemName = itemName  -- Store the actual name for comparison
                }
            end
        end)
        
        return options, itemMap
    end

    local dungeonShopOptions, dungeonShopItemMap = getAllDungeonShopItems()
    local selectedShopItems = {}

    -- Dropdown for selecting items
    local shopItemDropdown = DungeonMerchant:Dropdown("SelectShopItems", {
        Title = "Select Items to Auto Buy",
        Values = dungeonShopOptions,
        Multi = true,
        Searchable = true,
        Default = {},
        Callback = function(value)
            selectedShopItems = value
        end
    })


    DungeonMerchant:Button({
    Title = "Select All",
    Description = "Selects all dungeon shop items.",
    Callback = function()
        local allSelected = {}
        for _, optionName in ipairs(dungeonShopOptions) do
            allSelected[optionName] = true
        end
        shopItemDropdown:SetValue(allSelected)
        selectedShopItems = allSelected
    end})

    -- Auto buy toggle
    local autoBuyShopEnabled = false
    DungeonMerchant:Toggle("AutoBuyShopItems", {
        Title = "Auto Buy Selected Items",
        Description = "Automatically buys selected items when they appear in the dungeon shop",
        Default = false,
        Callback = function(Value)
            autoBuyShopEnabled = Value
            if Value then
                task.spawn(function()
                    while autoBuyShopEnabled do
                        if next(selectedShopItems) then
                            pcall(function()
                                local DungeonShop = require(ReplicatedStorage.Shared.List.Dungeon.Shop)
                                local playerData = DataController:getData()
                                if not playerData then return end
                                
                                -- Get current dungeon coins
                                local dungeonCoins = playerData.dungeonCoins or 0
                                
                                -- Get current shop hour for seed generation
                                local timeData = DateTime.fromUnixTimestamp(Knit.serverTimeNow + 3600):ToUniversalTime()
                                
                                -- Check each shop slot (1-3)
                                for slot = 1, 3 do
                                    local seed = timeData.Year * 222 + timeData.Month * 333 + timeData.Day * 444444 + timeData.Hour * 33333 + LocalPlayer.UserId + slot
                                    local shopItem = DungeonShop[Functions.getRandom(DungeonShop, seed)]
                                    
                                    if shopItem then
                                        local item = shopItem.item
                                        local price = shopItem.price
                                        
                                        -- Check if already bought
                                        local boughtKey = string.format("%d", seed)
                                        local isBought = playerData.dungeonShopBought[boughtKey] or false
                                        
                                        if not isBought and dungeonCoins >= price then
                                            -- Get item name using proper methods
                                            local itemName = "Unknown Item"
                                            local itemAmount = 1
                                            
                                            pcall(function()
                                                if item.getName then
                                                    itemName = item:getName()
                                                elseif item.getRealName then
                                                    itemName = item:getRealName()
                                                end
                                                
                                                if item.getAmount then
                                                    itemAmount = item:getAmount()
                                                end
                                            end)
                                            
                                            -- Check if this item is selected for auto buy
                                            for displayName, isSelected in pairs(selectedShopItems) do
                                                if isSelected and dungeonShopItemMap[displayName] then
                                                    local selectedItem = dungeonShopItemMap[displayName]
                                                    
                                                    -- Compare item names, amounts, and prices
                                                    if itemName == selectedItem.itemName and 
                                                    itemAmount == selectedItem.amount and 
                                                    price == selectedItem.price then
                                                        DungeonService:buyShop(slot)
                                                        task.wait(1)
                                                        break
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end)
                        end
                        task.wait(5) -- Check every 5 seconds
                    end
                end)
            end
        end
    })


    DungeonUpgrades = Tabs.Dunegon:AddSection("Auto Buy Upgrades")

    -- Get all dungeon upgrades for dropdown
    local function getAllDungeonUpgrades()
        local options = {}
        local upgradeMap = {}
        
        pcall(function()
            local DungeonUpgrades = require(ReplicatedStorage.Shared.List.Dungeon.Upgrades)
            
            for upgradeId, upgradeData in pairs(DungeonUpgrades) do
                local displayName = Functions.toPascal(upgradeId)
                table.insert(options, displayName)
                upgradeMap[displayName] = upgradeId
            end
        end)
        
        table.sort(options)
        return options, upgradeMap
    end

    local dungeonUpgradeOptions, dungeonUpgradeMap = getAllDungeonUpgrades()
    local selectedDungeonUpgrades = {}

    -- Dropdown for selecting upgrades
    local dungeonUpgradeDropdown = DungeonUpgrades:Dropdown("SelectDungeonUpgrades", {
        Title = "Select Upgrades to Auto Buy",
        Values = dungeonUpgradeOptions,
        Multi = true,
        Searchable = true,
        Default = {},
        Callback = function(value)
            selectedDungeonUpgrades = value
        end
    })

    -- Auto upgrade toggle
    local autoDungeonUpgradeEnabled = false
    DungeonUpgrades:Toggle("AutoUpgrade", {
        Title = "Auto Upgrade",
        Description = "Automatically buys selected dungeon upgrades when you can afford them",
        Default = false,
        Callback = function(Value)
            autoDungeonUpgradeEnabled = Value
            if Value then
                task.spawn(function()
                    while autoDungeonUpgradeEnabled do
                        if next(selectedDungeonUpgrades) then
                            local upgradesBought = 0
                            
                            pcall(function()
                                local playerData = DataController:getData()
                                if not playerData then return end
                                
                                local DungeonUpgradesModule = require(ReplicatedStorage.Shared.List.Dungeon.Upgrades)
                                local dungeonCoins = playerData.dungeonCoins or 0
                                
                                -- Check each selected upgrade
                                for displayName, isSelected in pairs(selectedDungeonUpgrades) do
                                    if isSelected and dungeonUpgradeMap[displayName] then
                                        local upgradeId = dungeonUpgradeMap[displayName]
                                        local upgradeData = DungeonUpgradesModule[upgradeId]
                                        
                                        if upgradeData then
                                            local currentLevel = playerData.dungeonUpgrades[upgradeId] or 0
                                            local nextLevel = currentLevel + 1
                                            
                                            -- Check if there's a next level available
                                            if upgradeData.upgrades[nextLevel] then
                                                local upgradeCost = upgradeData.upgrades[nextLevel].cost or 0
                                                
                                                -- Check if player can afford it
                                                if dungeonCoins >= upgradeCost then
                                                    -- Convert to lowercase for service call
                                                    local lowercaseUpgradeId = upgradeId:sub(1,1):lower() .. upgradeId:sub(2)
                                                    DungeonService:upgrade(lowercaseUpgradeId)
                                                    
                                                    upgradesBought = upgradesBought + 1
                                                    dungeonCoins = dungeonCoins - upgradeCost -- Update local coins count
                                                    
                                                    task.wait(0.25) -- 0.25 second delay between purchases
                                                    
                                                    -- Update player data for next iteration
                                                    playerData = DataController:getData()
                                                    if playerData then
                                                        dungeonCoins = playerData.dungeonCoins or 0
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end)
                        end
                        
                        task.wait(3) -- Check every 3 seconds
                    end
                end)
            end
        end
    })


    local AutoCraftSection = Tabs.Craft:AddSection("Auto Craft")

    AutoCraftSection:Paragraph("AutoCraftSectionParagraph", {
        Title = "Note",
        Content = "You will not visually get a message that you have crafted something, but it will have been built. This will also use items that might be rare, so be careful with what you select. If something still appears as unbuilt, rejoin.",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    ResourceStatusParagraph = AutoCraftSection:Paragraph("ResourceStatus", {
        Title = "Resource Status",
        Content = "Select buildings to see resource requirements",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    local isAutoCraftEnabled = false
    local originalAutoCraftSettings = {}
    local autoCraftBuildingMap -- This one can stay local as it's not used elsewhere

    local function getUnbuiltBuildings()
        local options, buildingMap = {}, {}
        pcall(function()
            local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
            local playerData = DataController:getData()
            if not playerData then return end

            for buildingId, buildingData in pairs(Buildings) do
                local isBuilt = playerData.buildings and playerData.buildings[buildingId] or false
                if not isBuilt and buildingData.name and buildingData.required then
                    local displayName = buildingData.name
                    table.insert(options, displayName)
                    buildingMap[displayName] = buildingId
                end
            end
        end)
        table.sort(options)
        return options, buildingMap
    end

    local function canAffordBuilding(buildingId)
        local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
        local buildingData = Buildings[buildingId]
        if not buildingData or not buildingData.required then return false end
        
        local playerData = DataController:getData()
        if not playerData then return false end
        
        for _, requiredItem in ipairs(buildingData.required) do
            local itemName = requiredItem:getName()
            local requiredAmount = requiredItem:getAmount()
            
            local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
            local currentAmount = currentItem and currentItem:getAmount() or 0
            
            if currentAmount < requiredAmount then
                return false
            end
        end
        return true
    end

    local function getPrerequisiteChain(buildingId, visited)
        visited = visited or {}
        if visited[buildingId] then return {} end
        visited[buildingId] = true
        
        local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
        local buildingData = Buildings[buildingId]
        if not buildingData then return {} end
        
        local chain = {}
        if buildingData.previousBuilding then
            local prereqChain = getPrerequisiteChain(buildingData.previousBuilding, visited)
            for _, prereq in ipairs(prereqChain) do
                table.insert(chain, prereq)
            end
            table.insert(chain, buildingData.previousBuilding)
        end
        
        return chain
    end

    local function getMissingResources()
        local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
        local playerData = DataController:getData()
        if not playerData then return {} end
        
        local missingResources = {}
        
        if autoCraftDropdown and autoCraftDropdown.Value then
            for buildingName, isSelected in pairs(autoCraftDropdown.Value) do
                if isSelected then
                    local buildingId = autoCraftBuildingMap[buildingName]
                    local buildingData = Buildings[buildingId]
                    
                    if buildingData and buildingData.required then
                        for _, requiredItem in ipairs(buildingData.required) do
                            local itemName = requiredItem:getName()
                            local requiredAmount = requiredItem:getAmount()
                            
                            local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
                            local currentAmount = currentItem and currentItem:getAmount() or 0
                            
                            if currentAmount < requiredAmount then
                                local needed = requiredAmount - currentAmount
                                missingResources[itemName] = (missingResources[itemName] or 0) + needed
                            end
                        end
                    end
                end
            end
        end
        
        return missingResources
    end

    local function updateResourceStatus()
        local missingResources = getMissingResources()
        
        if not next(missingResources) then
            if ResourceStatusParagraph then
                ResourceStatusParagraph:SetValue(" All selected buildings can be crafted!")
            end
            return
        end
        
        local statusLines = {" Missing Resources:"}
        for itemName, amount in pairs(missingResources) do
            table.insert(statusLines, string.format("   %s: %s", itemName, Functions.comma(amount)))
        end
        
        if ResourceStatusParagraph then
            ResourceStatusParagraph:SetValue(table.concat(statusLines, "\n"))
        end
    end

    local function mapWoodToTreeWorldForCraft(woodName)
        if woodName:lower() == "wood" then return "spawn" end
        
        local Trees = require(ReplicatedStorage.Shared.List.Trees)
        for zoneName, zoneData in pairs(Trees) do
            if zoneData.trees and #zoneData.trees > 0 then
                local treeInfo = zoneData.trees[1]
                if treeInfo and treeInfo.item then
                    local item = treeInfo.item
                    local itemName = item.id or item.Name or item.name or (item.getId and item:getId()) or (item.getName and item:getName())
                    if itemName and itemName:lower() == woodName:lower() then return zoneName end
                end
            end
        end
        return "spawn"
    end

    local autoCraftOptions, initialBuildingMap = getUnbuiltBuildings()
    autoCraftBuildingMap = initialBuildingMap

    AutoCraftSection:Button({
        Title = "Enable Recommended Settings",
        Description = "Automatically enables: Auto Equip Best Axe, Reduce Cutting Cooldown, and Axe Strength Bypass",
        Callback = function()
            AutoEquip:SetValue(true)
            lowercooldown:SetValue(true) 
            BypassStrength:SetValue(true)
        end
    })

    autoCraftDropdown = AutoCraftSection:Dropdown("SelectBuildingsToCraft", {
        Title = "Select Buildings to Auto Craft",
        Description = "Crafts all selected buildings that you can afford and farms trees for needed wood.",
        Values = autoCraftOptions,
        Multi = true,
        Searchable = true,
        Default = {}
    })

    autoCraftDropdown:OnChanged(function(value)
        updateResourceStatus()
    end)

   AutoCraftBuildings = AutoCraftSection:Toggle("AutoCraft", {
        Title = "Auto Craft Selected Buildings",
        Description = "Automatically crafts selected buildings and farms trees for wood resources.",
        Default = false,
        Callback = function(enabled)
            isAutoCraftEnabled = enabled
            if enabled then
                originalAutoCraftSettings.selectedTrees = {}
                for treeObject, isSelected in pairs(SelectTreesDropdown.Value) do
                    originalAutoCraftSettings.selectedTrees[treeObject] = isSelected
                end
                originalAutoCraftSettings.autoCutState = autoBreakRunning
                task.spawn(function()
                    while isAutoCraftEnabled do
                        pcall(function()
                            local playerData = DataController:getData()
                            if not playerData then return end
                            local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
                            local selectedBuildings = autoCraftDropdown.Value or {}
                            local neededWoods = {}
                            local canCraftSomething = false
                            for buildingName, isSelected in pairs(selectedBuildings) do
                                if isSelected then
                                    local buildingId = autoCraftBuildingMap[buildingName]
                                    local buildingData = Buildings[buildingId]
                                    if buildingData then
                                        for _, prereqId in ipairs(getPrerequisiteChain(buildingId)) do
                                            if not (playerData.buildings and playerData.buildings[prereqId]) and canAffordBuilding(prereqId) then
                                                BuildingService:build(prereqId)
                                                task.wait(1)
                                                canCraftSomething = true
                                            end
                                        end
                                        if not (playerData.buildings and playerData.buildings[buildingId]) then
                                            if canAffordBuilding(buildingId) then
                                                BuildingService:build(buildingId)
                                                task.wait(2)
                                                canCraftSomething = true
                                            elseif buildingData.required then
                                                for _, requiredItem in ipairs(buildingData.required) do
                                                    local itemName = requiredItem:getName()
                                                    local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
                                                    if (currentItem and currentItem:getAmount() or 0) < requiredItem:getAmount() and itemName:lower():find("wood") then
                                                        table.insert(neededWoods, itemName)
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            if #neededWoods > 0 then
                                local neededTreeObjects = {}
                                for _, woodName in ipairs(neededWoods) do
                                    local treeWorld = mapWoodToTreeWorldForCraft(woodName)
                                    for _, treeObject in ipairs(SelectTreesDropdown.Values) do
                                        if treeObject.Value == treeWorld then neededTreeObjects[treeObject] = true; break end
                                    end
                                end
                                SelectTreesDropdown:SetValue(neededTreeObjects)
                                if not autoBreakRunning then AutoCutTreesToggle:SetValue(true) end
                            elseif canCraftSomething and autoBreakRunning then
                                AutoCutTreesToggle:SetValue(false)
                            end
                        end)
                        task.wait(3)
                    end
                end)
            elseif next(originalAutoCraftSettings) then
                SelectTreesDropdown:SetValue(originalAutoCraftSettings.selectedTrees)
                if autoBreakRunning ~= originalAutoCraftSettings.autoCutState then
                    AutoCutTreesToggle:SetValue(originalAutoCraftSettings.autoCutState)
                end
            end
        end
    })

    AutoCraftSection:Button({
        Title = "Refresh Building List",
        Description = "Updates the list of available buildings to craft",
        Callback = function()
            local newOptions, newBuildingMap = getUnbuiltBuildings()
            autoCraftOptions = newOptions
            autoCraftBuildingMap = newBuildingMap
            autoCraftDropdown:SetValues(newOptions)
            autoCraftDropdown:SetValue({})
            updateResourceStatus()
        end
    })

    task.spawn(function()
        while true do
            local newOptions, newBuildingMap = getUnbuiltBuildings()
            autoCraftOptions = newOptions
            autoCraftBuildingMap = newBuildingMap

            pcall(function()
                autoCraftDropdown:SetValues(newOptions)
            end)
            updateResourceStatus()
            task.wait(5)
        end
    end)


    explorerroom = Tabs.Craft:AddSection("Scattered Items")

    explorerroom:Paragraph("WorldMap", {
        Title = "World Map",
        Content = "To get the world map, you will need to follow these steps. Teleport to Desert (don't move), then teleport to Tech City (don't move), then teleport to Volcano (don't move). Next, teleport to spawn, and manually go through every world without teleporting, up to spaceship. Finally teleport to Heaven, and you will unlock it.",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    explorerroom:Button({
        Title = "Claim Hints",
        Description = "Automatically claims all available explorer hints",
        Callback = function()
            pcall(function()
                local Knit = require(ReplicatedStorage.Packages.Knit)
                local ExplorerService = Knit.GetService("ExplorerService")
                local DataController = Knit.GetController("DataController")
                local UIController = Knit.GetController("UIController")
                
                DataController:waitForData()
                local playerData = DataController:getData()

                local hintsCollected = 0
                
                -- Try to collect hint 1
                if not playerData.explorerHints.hint1 then
                    local result = ExplorerService:collectHint(1)
                    if result == "success" then
                        hintsCollected = hintsCollected + 1
                        task.wait(1)
                    end
                end
                
                -- Try to collect hint 2 (requires hint 1 to be collected first)
                playerData = DataController:getData() -- Refresh data
                if playerData.explorerHints.hint1 and not playerData.explorerHints.hint2 then
                    local result = ExplorerService:collectHint(2)
                    if result == "success" then
                        hintsCollected = hintsCollected + 1
                    end
                end
                
                if hintsCollected > 0 then
                else
                end
            end)
        end
    })

    explorerroom:Button({
        Title = "Get all Scattered Explorer Items",
        Description = "Like the title says, you will get the scattered items - e.g globe",
        Callback = function()
            pcall(function()
                local explorerRoom = workspace.Game.Maps.Spaceship:FindFirstChild("extra explorer room")
                if not explorerRoom then
                    warn("Extra explorer room not found!")
                    return
                end
                
                local activatedCount = 0
                local totalItems = 0
                
                for _, item in pairs(explorerRoom:GetChildren()) do
                    totalItems = totalItems + 1
                    local proximityPrompt = item:FindFirstChildOfClass("ProximityPrompt")
                    
                    if proximityPrompt then
                        pcall(function()
                            fireproximityprompt(proximityPrompt)
                            activatedCount = activatedCount + 1
                        end)
                        task.wait(1) 
                    end
                end
            end)
        end
    })


    ActivateLeversSection = Tabs.Craft:AddSection("Activate Levers")

    ActivateLeversSection:Toggle("AutoActivateLevers", {
        Title = "Activate Light Switches",
        Description = "Automatically activates built light switches that haven't been activated yet",
        Default = false,
        Callback = function(Value)
            local autoActivateEnabled = Value
            if Value then
                task.spawn(function()
                    while autoActivateEnabled do
                        pcall(function()
                            local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
                            local playerData = DataController:getData()
                            if not playerData then return end
                            
                            for buildingId, buildingData in pairs(Buildings) do
                                if buildingId:lower():find("lightswitch") then
                                    local isBuilt = playerData.buildings and playerData.buildings[buildingId] or false
                                    
                                    if isBuilt then
                                        local switchNumber = buildingId:match("lightSwitch(%d+)")
                                        if switchNumber then
                                            local switchId = tonumber(switchNumber)
                                            
                                            local isActivated = table.find(playerData.lightSwitches or {}, switchId) ~= nil
                                            
                                            if not isActivated then
                                                local Knit = require(ReplicatedStorage.Packages.Knit)
                                                Knit.GetService("RewardService").activateLightSwitch._re:FireServer(switchId)
                                                task.wait(1)
                                            end
                                        end
                                    end
                                end
                            end
                        end)
                        
                        task.wait(3)
                    end
                end)
            else
                autoActivateEnabled = false
            end
        end
    })

        
    local MapQuestSection = Tabs.Quest:AddSection("Map Quests")

    local MapQuestStatusParagraph = MapQuestSection:Paragraph("MapQuestStatus", {
        Title = "Map Quest Progress",
        Content = "Loading map quest status...",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    local updateMapQuestStatus = function()
        pcall(function()
            local Maps = require(ReplicatedStorage.Shared.List.Maps)
            DataController:waitForData()
            local playerData = DataController:getData()
            
            if not playerData then
                MapQuestStatusParagraph:SetValue(" Could not get player data")
                return
            end
            
            -- Find highest map number
            local highestMap = 0
            if playerData.maps then
                for mapNumber, _ in pairs(playerData.maps) do
                    if tonumber(mapNumber) and tonumber(mapNumber) > highestMap then
                        highestMap = tonumber(mapNumber)
                    end
                end
            end
            
            -- Next map to unlock
            local nextMapNumber = highestMap + 1
            local nextMap = Maps[nextMapNumber]
            
            local statusLines = {}
            table.insert(statusLines, string.format(" Best Map Owned: %d", highestMap))
            
            if nextMap then
                table.insert(statusLines, string.format(" Next Map: Map %d - %s", nextMapNumber, nextMap.name))
                table.insert(statusLines, "")
                
                if nextMap.quests then
                    table.insert(statusLines, " Quest Progress:")
                    
                    for questIndex, questData in pairs(nextMap.quests) do
                        local questType = questData.quest
                        local required = questData.amount
                        local questName = questData.name
                        
                        -- Get progress from mapQuests
                        local currentProgress = playerData.mapQuests[questIndex] or 0
                        
                        -- Cap progress at required amount for display
                        local displayProgress = math.min(currentProgress, required)
                        
                        local isCompleted = currentProgress >= required
                        local status = isCompleted and "" or ""
                        local percentage = math.floor((displayProgress / required) * 100)
                        
                        -- Show quest info
                        local displayText = questType
                        if questName then
                            displayText = questType .. " (" .. questName .. ")"
                        end
                        
                        table.insert(statusLines, string.format("%s %s", status, displayText))
                        table.insert(statusLines, string.format("   %s/%s (%d%%)", 
                            Functions.suffixes(displayProgress),
                            Functions.suffixes(required),
                            percentage
                        ))
                    end
                end
            else
                table.insert(statusLines, " ALL MAPS UNLOCKED!")
            end
            
            MapQuestStatusParagraph:SetValue(table.concat(statusLines, "\n"))
        end)
    end

 
    -- Update map quest status every 5 seconds
    task.spawn(function()
        while true do
            updateMapQuestStatus()
            task.wait(5)
        end
    end)

    -- Toggle in GUI
    MapQuestSection:Toggle("AutoCompleteMapQuest", {
        Title = "Auto Complete Map Quest",
        Description = "Automatically completes map quests and unlocks walls sequentially.",
        Default = false,
        Callback = function(enabled)
            task.spawn(function()
                _G.MapQuestEnabled = enabled
                
                -- Store original states when enabling
                local originalStates = {
                    autoClickEnabled = AutoClick.Value,
                    autoRebirthEnabled = AutoRebirth.Value,
                    selectedRebirthValue = rebirthDropdown.Value,
                    selectedEggValue = EggDropdown.Value,
                    selectedAmountValue = HatchAmount.Value,
                    autoHatchEnabled = AutoHatch.Value,
                    craftAllToggleState = CraftAllToggle.Value,
                    selectedFarmsForClaim = claimDropdown.Value or {},
                    autoClaimFarmsEnabled = AutoClaimFarm.Value,
                    selectedTreesValue = SelectTreesDropdown.Value,
                    autoCutTreesEnabled = AutoCutTreesToggle.Value,
                    selectedPetsValue = PetDropdown.Value,
                    autoBuyFarmsEnabled = BuyFarm.Value,
                    selectedFarmsToBuy = farmDropdown.Value or {},
                    AutoCraftBuildings = AutoCraftBuildings.Value,
                    autoCraftDropdown = autoCraftDropdown.Value
                }
                
                local function restoreOriginalStates()
                    pcall(function()
                        AutoClick:SetValue(originalStates.autoClickEnabled)
                        AutoRebirth:SetValue(originalStates.autoRebirthEnabled)
                        rebirthDropdown:SetValue(originalStates.selectedRebirthValue)
                        EggDropdown:SetValue(originalStates.selectedEggValue)
                        farmDropdown:SetValue(originalStates.selectedFarmsToBuy)
                        HatchAmount:SetValue(originalStates.selectedAmountValue)
                        AutoHatch:SetValue(originalStates.autoHatchEnabled)
                        CraftAllToggle:SetValue(originalStates.craftAllToggleState)
                        claimDropdown:SetValue(originalStates.selectedFarmsForClaim)
                        AutoClaimFarm:SetValue(originalStates.autoClaimFarmsEnabled)
                        SelectTreesDropdown:SetValue(originalStates.selectedTreesValue)
                        AutoCutTreesToggle:SetValue(originalStates.autoCutTreesEnabled)
                        BuyFarm:SetValue(originalStates.autoBuyFarmsEnabled)
                        PetDropdown:SetValue(originalStates.selectedPetsValue)
                        AutoCraftBuildings:SetValue(originalStates.AutoCraftBuildings)
                        autoCraftDropdown:SetValue(originalStates.autoCraftDropdown)
                    end)
                end
                
                if enabled then
                    if AutoClick and not AutoClick.Value then
                        AutoClick:SetValue(true)
                    end

                    task.spawn(function()
                        while _G.MapQuestEnabled do
                            local success = pcall(function()
                                if not _G.MapQuestEnabled then return end
                                
                                local Maps = require(ReplicatedStorage.Shared.List.Maps)
                                local playerData = DataController:getData()
                                
                                if not playerData then return end
                                
                                AutoHatch:SetValue(false)
                                AutoRebirth:SetValue(false)
                                CraftAllToggle:SetValue(false)
                                AutoClaimFarm:SetValue(false)
                                AutoCutTreesToggle:SetValue(false)
                                BuyFarm:SetValue(false)

                                local highestMap = 0
                                if playerData.maps then
                                    for mapNumber, _ in pairs(playerData.maps) do
                                        if tonumber(mapNumber) and tonumber(mapNumber) > highestMap then
                                            highestMap = tonumber(mapNumber)
                                        end
                                    end
                                end
                                
                                local nextMapNumber = highestMap + 1
                                local nextMap = Maps[nextMapNumber]
                                
                                local allQuestsCompleted = true
                                
                                if nextMap and nextMap.quests then
                                    for questIndex, questData in pairs(nextMap.quests) do
                                        if not _G.MapQuestEnabled then return end
                                        
                                        local currentProgress = playerData.mapQuests[questIndex] or 0
                                        if currentProgress >= questData.amount then
                                            continue
                                        else
                                            allQuestsCompleted = false
                                        end
                                        
                                        -- From here, we are only processing the CURRENT UNFINISHED quest
                                        local questType = questData.quest
                                        local required = questData.amount
                                        local questName = questData.name

                                        if questType == "rebirths" then
                                            local currentRebirths = playerData.rebirths or 0
                                            local rebirthsNeeded = required - currentRebirths

                                            if rebirthsNeeded > 1e98 then -- 1DTG threshold (adjust if needed)
                                                -- Equip fixed 150B rebirths
                                                for _, option in ipairs(rebirthOptions) do
                                                    if option.amount == 150e9 then
                                                        rebirthDropdown:SetValue(option.display)
                                                        break
                                                    end
                                                end

                                                AutoRebirth:SetValue(true)

                                                -- Fire the server request every 3 seconds
                                                task.spawn(function()
                                                    local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
                                                    local MapService = Knit.GetService("MapService")
                                                    while _G.MapQuestEnabled and rebirthsNeeded > 1e12 do
                                                        pcall(function()
                                                            MapService:purchaseSpaceWorld()
                                                        end)
                                                        task.wait(3)
                                                    end
                                                end)

                                            else
                                                -- Normal rebirth handling (existing logic)
                                                local bestOptionDisplay = nil
                                                if rebirthsNeeded > 0 then
                                                    for _, option in ipairs(rebirthOptions) do
                                                        if option.amount >= rebirthsNeeded then
                                                            bestOptionDisplay = option.display
                                                            break
                                                        end
                                                    end
                                                end
                                                if bestOptionDisplay then
                                                    rebirthDropdown:SetValue(bestOptionDisplay)
                                                else
                                                    rebirthDropdown:SetValue("Max Unlocked")
                                                end
                                                AutoRebirth:SetValue(true)
                                            end 

                                        elseif questType == "openEgg" and questName then
                                            local targetEggName = questName
                                            for _, eggOption in ipairs(eggOptions) do
                                                if eggOption:lower():find(targetEggName:lower()) then
                                                    EggDropdown:SetValue(eggOption)
                                                    break
                                                end
                                            end
                                            HatchAmount:SetValue("Max")
                                            AutoHatch:SetValue(true)

                                        elseif questType == "craftAnyGalaxyPets" then
                                            local previousMapNumber = nextMapNumber - 1
                                            local previousMap = Maps[previousMapNumber]
                                            local previousWorldEggName = (previousMap and previousMap.name) or nextMap.name
                                            
                                            for _, eggOption in ipairs(eggOptions) do
                                                if eggOption:lower():find(previousWorldEggName:lower()) then
                                                    EggDropdown:SetValue(eggOption)
                                                    break
                                                end
                                            end
                                            
                                            HatchAmount:SetValue("Max")
                                            AutoHatch:SetValue(true)
                                            
                                            task.wait(2)
                                            PetDropdown:SetValues(getPlayerPetOptions())
                                            local playerPetOptions = getPlayerPetOptions()
                                            local galaxyCraftablePets = {}
                                            
                                            local Eggs = require(ReplicatedStorage.Shared.List.Pets.Eggs)
                                            local previousEggData = Eggs[previousWorldEggName]
                                            local previousWorldPetNames = {}
                                            if previousEggData and previousEggData.pets then
                                                for petName, _ in pairs(previousEggData.pets) do table.insert(previousWorldPetNames, petName) end
                                            end
                                            
                                            for _, displayName in ipairs(playerPetOptions) do
                                                for _, worldPetName in ipairs(previousWorldPetNames) do
                                                    if displayName:find(worldPetName) then
                                                        galaxyCraftablePets[displayName] = true
                                                        break
                                                    end
                                                end
                                            end

                                            local toxicPetNames = {}
                                            if playerData.maps then
                                                for mapNumber, _ in pairs(playerData.maps) do
                                                    local mapNum = tonumber(mapNumber)
                                                    if mapNum and mapNum >= 17 then
                                                        local mapData = Maps[mapNum]
                                                        if mapData and mapData.name then
                                                            local worldEggData = Eggs[mapData.name]
                                                            if worldEggData and worldEggData.pets then
                                                                for petName, chance in pairs(worldEggData.pets) do
                                                                    if chance > 0.01 then table.insert(toxicPetNames, petName) end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end

                                            for _, displayName in ipairs(playerPetOptions) do
                                                for _, toxicPetName in ipairs(toxicPetNames) do
                                                    if displayName:find("Toxic") and displayName:find(toxicPetName) then
                                                        galaxyCraftablePets[displayName] = true
                                                        break
                                                    end
                                                end
                                            end
                                            
                                            if next(galaxyCraftablePets) and PetDropdown then
                                                PetDropdown:SetValue(galaxyCraftablePets)
                                                CraftAllToggle:SetValue(true)
                                            end
                                            
                                        elseif questType == "hatchPet" and questName then
                                            local previousMapNumber = nextMapNumber - 1
                                            local previousMap = Maps[previousMapNumber]
                                            local worldName = (previousMap and previousMap.name) or "Spawn"
                                            
                                            for _, eggOption in ipairs(eggOptions) do
                                                if eggOption:lower():find(worldName:lower()) then
                                                    EggDropdown:SetValue(eggOption)
                                                    break
                                                end
                                            end
                                            
                                            HatchAmount:SetValue("Max")
                                            AutoHatch:SetValue(true)
                
                                        elseif questType == "useAuraDice" then
                                            local bestDiceId, maxAmount = nil, 0
                                            if playerData.inventory and playerData.inventory.auraDice then
                                                for itemId, itemData in pairs(playerData.inventory.auraDice) do
                                                    if (itemData.am or 0) > maxAmount then
                                                        maxAmount = itemData.am
                                                        bestDiceId = itemData.nm or itemId
                                                    end
                                                end
                                            end
                                            if bestDiceId and maxAmount > 0 then
                                                pcall(function() AuraService:roll(bestDiceId) end)
                                                task.wait(2)
                                            end
                                            
                                        elseif questType == "collectFruits" then
                                            rebirthDropdown:SetValue("Max Unlocked")
                                            AutoRebirth:SetValue(true)
                                            
                                            local allFarms = {}
                                            for _, farmName in ipairs(farmOptions) do allFarms[farmName] = true end
                                            farmDropdown:SetValue(allFarms)
                                            BuyFarm:SetValue(true)
                                            
                                            local allClaimFarms = {}
                                            for _, farmName in ipairs(claimFarmOptions) do allClaimFarms[farmName] = true end
                                            claimDropdown:SetValue(allClaimFarms)
                                            AutoClaimFarm:SetValue(true)
                                        
                                        elseif questType == "building" and questName and (questName:lower():find("bridge") or questName:lower():find("wooden")) then
                                                
                                                local bridgeOptionName = "Wooden Bridge"
                                                local foundOption = false
                                                for _, option in ipairs(autoCraftDropdown.Values) do
                                                    if option == bridgeOptionName then
                                                        foundOption = true
                                                        break
                                                    end
                                                end

                                                if foundOption then
                                                    autoCraftDropdown:SetValue({[bridgeOptionName] = true})
                                                    AutoCraftBuildings:SetValue(true)
                                                else
                                                end
                                                
                                        elseif questType == "usePotions" then
                                            local bestPotionId, maxAmount = nil, 0
                                            if playerData.inventory and playerData.inventory.potion then
                                                for itemId, itemData in pairs(playerData.inventory.potion) do
                                                    if (itemData.am or 0) > maxAmount and not (itemData.nm or ""):lower():find("mega") then
                                                        maxAmount = itemData.am
                                                        bestPotionId = itemId
                                                    end
                                                end
                                            end
                                            if bestPotionId and maxAmount > 0 then
                                                local potionsNeeded = math.min(required - currentProgress, maxAmount)
                                                if potionsNeeded > 0 then
                                                    pcall(function() Knit.GetService("InventoryService"):useItem(bestPotionId, {use = potionsNeeded}) end)
                                                    task.wait(2)
                                                end
                                            end
                                            
                                        elseif questType == "useMegaPotions" then
                                            local bestMegaPotionId, maxAmount = nil, 0
                                            if playerData.inventory and playerData.inventory.potion then
                                                for itemId, itemData in pairs(playerData.inventory.potion) do
                                                    if (itemData.am or 0) > maxAmount and (itemData.nm or ""):lower():find("mega") then
                                                        maxAmount = itemData.am
                                                        bestMegaPotionId = itemId
                                                    end
                                                end
                                            end
                                            if bestMegaPotionId and maxAmount > 0 then
                                                local megaPotionsNeeded = math.min(required - currentProgress, maxAmount)
                                                if megaPotionsNeeded > 0 then
                                                    pcall(function() Knit.GetService("InventoryService"):useItem(bestMegaPotionId, {use = megaPotionsNeeded}) end)
                                                    task.wait(2)
                                                end
                                            end
                                        end
                                        break
                                    end
                                else
                                    allQuestsCompleted = true
                                end
                                
                                if allQuestsCompleted then
                                    restoreOriginalStates()
                                    _G.MapQuestEnabled = false
                                    return
                                end
                            end)
                            
                            if not success then end
                            if not _G.MapQuestEnabled then break end
                            task.wait(3)
                        end
                        
                        restoreOriginalStates()
                    end)
                else
                    _G.MapQuestEnabled = false
                    restoreOriginalStates()
                end
            end)
        end
    })
    
    local MapQuestNone = MapQuestSection:Paragraph("MapQuestNone", {
        Title = "Note",
        Content = "For the build quest in the kingdom world, the bridge will be built, but this script won't source the resources. Make sure you have at least 3 ancient ticks, 3 fire aura dice, 5 grapes, and 5 apples.",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    local AngelQuestSection = Tabs.Quest:AddSection("Angel Quests")

    angelQuestEnabled = false

    local AngelQuestStatusParagraph = AngelQuestSection:Paragraph("AngelQuestStatus", {
        Title = "Angel Quest Status",
        Content = "Loading quest status...",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    updateAngelQuestStatus = function()
        pcall(function()
            local AngelQuestsList = require(ReplicatedStorage.Shared.List.AngelQuests)
            DataController:waitForData()
            local playerData = DataController:getData()
            
            local currentTier = playerData.angelQuestTier or 1
            local currentProgress = playerData.angelQuestProgress or 0
            local totalTiers = #AngelQuestsList
            
            if currentTier > totalTiers then
                AngelQuestStatusParagraph:SetValue(string.format(" Completed all %d Angel Quests!", totalTiers))
            else
                local questInfo = AngelQuestsList[currentTier]
                if questInfo then
                    local requiredAmount = questInfo.quest.amount
                    local formattedQuestText = questInfo.text:format(requiredAmount)
                    
                    local statusText = string.format(
                        " Tier: %d/%d\n Quest: %s\n Progress: %d/%d",
                        currentTier, totalTiers, formattedQuestText, currentProgress, requiredAmount
                    )
                    AngelQuestStatusParagraph:SetValue(statusText)
                else
                    AngelQuestStatusParagraph:SetValue(string.format(" Unable to read quest for Tier %d", currentTier))
                end
            end
        end)
    end

    getAllAuraDice = function()
        local options, diceMap = {}, {}
        pcall(function()
            local AuraDices = require(ReplicatedStorage.Shared.List.Items.AuraDices)
            for diceId, diceData in pairs(AuraDices) do
                local displayName = diceData.name
                table.insert(options, displayName)
                diceMap[displayName] = diceId
            end
        end)
        table.sort(options)
        return options, diceMap
    end

    local diceOptions, diceIdMap = getAllAuraDice()

    allowedDiceDropdown = AngelQuestSection:Dropdown("AllowedDice", {
        Title = "Allowed Dice",
        Description = "Select which dice to use for aura quests (if none selected, uses any owned dice)",
        Values = diceOptions,
        Multi = true,
        Searchable = true,
        Default = {}
    })


    getCurrentQuestType = function()
        local success, result = pcall(function()
            local AngelQuestsList = require(ReplicatedStorage.Shared.List.AngelQuests)
            DataController:waitForData()
            local playerData = DataController:getData()
            
            if not playerData then 
                return nil 
            end
            
            local currentTier = playerData.angelQuestTier or 1
            
            if currentTier <= #AngelQuestsList then
                local questData = AngelQuestsList[currentTier]
                return questData and questData.quest or nil
            else
                return nil
            end
        end)
        
        if success then
            return result
        else
            return nil
        end
    end


    findBestPotion = function()
        local playerData = DataController:getData()
        if not playerData or not playerData.inventory or not playerData.inventory.exclusive then
            return nil
        end
        
        local bestPotion = nil
        local highestAmount = 0
        
        for itemId, itemData in pairs(playerData.inventory.exclusive) do
            if itemData.nm and itemData.nm:lower():find("potion") and itemData.am and itemData.am > highestAmount then
                highestAmount = itemData.am
                bestPotion = itemId
            end
        end
        
        return bestPotion
    end

    getAvailableAuraDice = function()
        local playerData = DataController:getData()
        if not playerData then
            return {}
        end
        
        local selectedDice = allowedDiceDropdown.Value or {}
        local availableDice = {}
        
        if next(selectedDice) == nil then
            local AuraDices = require(ReplicatedStorage.Shared.List.Items.AuraDices)
            
            for diceId, diceData in pairs(AuraDices) do
                local item = Util.itemUtils.getItemFromName(playerData, diceId)
                if item and item:getAmount() > 0 then
                    table.insert(availableDice, diceId)
                end
            end
        else
            for diceName, isSelected in pairs(selectedDice) do
                if isSelected then
                    local diceId = diceIdMap[diceName]
                    local item = Util.itemUtils.getItemFromName(playerData, diceId)
                    if item and item:getAmount() > 0 then
                        table.insert(availableDice, diceId)
                    end
                end
            end
        end
        
        return availableDice
    end

    setupForQuestType = function(questType)
        if not questType then 
            return 
        end
        
        local questName = questType.quest
        
        if questName:lower():find("egg") or questName:lower():find("hatch") then
            
            local heavenEggFound = false
            
            for i, eggOption in ipairs(eggOptions) do
                if eggOption:lower():find("heaven") then
                    EggDropdown:SetValue(eggOption)
                    selectedEgg = displayToEggName[eggOption] or "Heaven"
                    heavenEggFound = true
                    break
                end
            end
            
            if not heavenEggFound then
            end
            
            HatchAmount:SetValue("Max")
            selectedAmount = hatchAmounts["Max"]
            
            if not _G.AutoHatchEnabled then
                AutoHatch:SetValue(true)
            else
            end
        end
        
        if questName == "destroyTree" then
            AutoEquip:SetValue(true)
            local neededTrees = {}
            for _, treeObject in ipairs(SelectTreesDropdown.Values) do
                local treeName = treeObject.Value:lower()
                if treeName == "spawn" or treeName == "desert" or treeName == "nuclear" then
                    neededTrees[treeObject] = true
                end
            end
            SelectTreesDropdown:SetValue(neededTrees)
            selectedTrees = {}
            for treeType, isSelected in pairs(neededTrees) do
                if isSelected then table.insert(selectedTrees, treeType.Value) end
            end
            if not autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            else
            end
        end
        
        if questName == "craftRing" then
            task.spawn(function()
                while angelQuestEnabled do
                    pcall(function()
                        local Knit = require(ReplicatedStorage.Packages.Knit)
                        Knit.GetService("RingService"):craftRing("basicRing", 1)
                    end)
                    task.wait(5)
                end
            end)
        end
        
        if questName == "usePotions" then
            task.spawn(function()
                while angelQuestEnabled do
                    local potionId = findBestPotion()
                    if potionId then
                        pcall(function()
                            local Knit = require(ReplicatedStorage.Packages.Knit)
                            Knit.GetService("InventoryService"):useItem(potionId, {use = 1})
                        end)
                    else
                    end
                    task.wait(2)
                end
            end)
        end

        if questName == "useAuraDice" or questName == "rollOneInAura" then
            task.spawn(function()
                while angelQuestEnabled do
                    local currentQuest = getCurrentQuestType()
                    if not currentQuest or (currentQuest.quest ~= "useAuraDice" and currentQuest.quest ~= "rollOneInAura") then
                        break 
                    end
                    
                    local availableDice = getAvailableAuraDice()
                    if #availableDice > 0 then
                        local randomDice = availableDice[math.random(1, #availableDice)]
                        pcall(function()
                            AuraService:roll(randomDice)
                        end)
                    else
                    end
                    task.wait(2)
                end
            end)
        end
    end

    storeOriginalSettings = function()
        originalEggSelection = selectedEgg
        originalHatchAmount = selectedAmount
        
        originalAutoHatchState = AutoHatch.Value

        originalTreeSelection = {}
        for treeObject, isSelected in pairs(SelectTreesDropdown.Value) do
            originalTreeSelection[treeObject] = isSelected
        end
        originalAutoCutState = autoBreakRunning
    end

    restoreOriginalSettings = function()
        if originalEggSelection then
            for _, eggOption in ipairs(eggOptions) do
                if eggOption:find(originalEggSelection) then
                    EggDropdown:SetValue(eggOption)
                    selectedEgg = displayToEggName[eggOption] or originalEggSelection
                    break
                end
            end
        end
        
        if originalHatchAmount then
            local amountText = originalHatchAmount == 1 and "1x" or originalHatchAmount == 3 and "3x" or "Max"
            HatchAmount:SetValue(amountText)
            selectedAmount = originalHatchAmount
        end
        
        if not originalAutoHatchState and _G.AutoHatchEnabled then
            AutoHatch:SetValue(false)
        end
        
        if originalTreeSelection then
            SelectTreesDropdown:SetValue(originalTreeSelection)
            
            selectedTrees = {}
            for treeType, isSelected in pairs(originalTreeSelection) do
                if isSelected then table.insert(selectedTrees, treeType.Value) end
            end
        end
        
        if autoBreakRunning ~= originalAutoCutState then
            AutoCutTreesToggle:SetValue(originalAutoCutState)
        end
    end

    angelQuestToggle = AngelQuestSection:Toggle("AutoCompleteAngelQuest", {
        Title = "Auto Complete Angel Quest",
        Description = "Automatically completes the angel quests.",
        Default = false,
        Callback = function(enabled)
            task.spawn(function()
                angelQuestEnabled = enabled
                
                if enabled then
                    storeOriginalSettings()
                    
                    task.spawn(function()
                        task.wait(2)
                        
                        while angelQuestEnabled do
                            local currentQuest = getCurrentQuestType()
                            
                            if currentQuest then
                                setupForQuestType(currentQuest)
                            else
                            end
                            
                            pcall(function()
                                local AngelQuestsList = require(ReplicatedStorage.Shared.List.AngelQuests)
                                DataController:waitForData()
                                local playerData = DataController:getData()
                                
                                local currentTier = playerData.angelQuestTier or 1
                                local currentProgress = playerData.angelQuestProgress or 0
                                
                                if currentTier <= #AngelQuestsList then
                                    local questInfo = AngelQuestsList[currentTier]
                                    if questInfo then
                                        local requiredAmount = questInfo.quest.amount
                                        
                                        if currentProgress >= requiredAmount then
                                            local Knit = require(ReplicatedStorage.Packages.Knit)
                                            Knit.GetService("QuestService"):claimAngelQuest()
                                            restoreOriginalSettings()
                                            task.wait(2)
                                        end
                                    end
                                end
                            end)
                            
                            updateAngelQuestStatus()
                            task.wait(1)
                        end
                    end)
                else
                    restoreOriginalSettings()
                end
            end)
        end
        })

    task.spawn(function()
        while true do
            updateAngelQuestStatus()
            task.wait(5)
        end
    end)


    ClaimSection = Tabs.Claim:AddSection("Claim/Collect")

    local isAutoCollectEnabled = false
    local autoCollectThread = nil

    local function claimChestsInUnlockedMaps()
        if not game:IsLoaded() then game.Loaded:Wait() end
        task.wait(1)

        local Knit = require(ReplicatedStorage.Packages.Knit)
        local Maps = require(ReplicatedStorage.Shared.List.Maps)

        local DataController
        repeat
            DataController = Knit.GetController("DataController")
            task.wait()
        until DataController

        local function getUnlockedZones()
            local playerData = DataController:getData()
            if not playerData or not playerData.maps then return {} end
            local unlockedMapIds = playerData.maps
            local unlockedZones = {}
            for mapId, mapData in pairs(Maps) do
                if mapData.alwaysUnlocked or table.find(unlockedMapIds, mapId) then
                    mapData.id = mapId
                    table.insert(unlockedZones, mapData)
                end
            end
            table.sort(unlockedZones, function(a, b) return a.id < b.id end)
            return unlockedZones
        end

        local function formatZoneName(name)
            return (name:gsub("%s+", ""))
        end

        local function firePrompt(prompt)
            if prompt and prompt:IsA("ProximityPrompt") and prompt.Enabled then
                fireproximityprompt(prompt, math.huge)
            end
        end

        local function getZonePrompts(chestFolder)
            local prompts = {}
            for _, chest in ipairs(chestFolder:GetChildren()) do
                local touch = chest:FindFirstChild("Touch")
                if touch then
                    local prompt = touch:FindFirstChildOfClass("ProximityPrompt")
                    if prompt and prompt.Enabled then
                        table.insert(prompts, prompt)
                    end
                end
            end
            return prompts
        end

        local function beginChestCollection()
            local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            local originalCFrame = humanoidRootPart.CFrame

            local unlockedZones = getUnlockedZones()
            if #unlockedZones == 0 then return end

            for _, zoneData in ipairs(unlockedZones) do
                if not isAutoCollectEnabled then break end 
                if not zoneData.cframe then continue end

                local zoneName = formatZoneName(zoneData.name)
                local mapFolder = Workspace:FindFirstChild("Game") and Workspace.Game.Maps:FindFirstChild(zoneName)
                if not mapFolder then continue end
                local chestFolder = mapFolder:FindFirstChild("MiniChests")
                if not chestFolder then continue end

                humanoidRootPart:PivotTo(zoneData.cframe)
                task.wait(2)

                local lastCount = 0
                local sameCountDuration = 0
                local noPromptCount = 0

                while isAutoCollectEnabled do
                    local prompts = getZonePrompts(chestFolder)
                    local currentCount = #prompts

                    if currentCount == lastCount then
                        sameCountDuration += 1
                    else
                        sameCountDuration = 0
                    end
                    lastCount = currentCount

                    if sameCountDuration >= 10 then
                        break
                    end

                    if #prompts == 0 then
                        noPromptCount += 1
                        if noPromptCount >= 3 then
                            break
                        end
                    else
                        noPromptCount = 0
                        for _, prompt in ipairs(prompts) do
                            if not isAutoCollectEnabled then break end
                            firePrompt(prompt)
                            task.wait(0.25)
                        end
                    end
                    task.wait(1)
                end

                task.wait(1)
            end

            humanoidRootPart:PivotTo(originalCFrame)
        end

        pcall(beginChestCollection)
    end

    --  Toggle for Auto Chest Collection
    ClaimSection:Toggle("Auto Collect Mini-Chests", {
        Title = "Auto Collect Mini-Chests",
        Description = "Automatically teleports through unlocked zones and collects all mini-chests until stopped.",
        Default = false,
        Callback = function(enabled)
            isAutoCollectEnabled = enabled

            if enabled then
                autoCollectThread = task.spawn(function()
                    while isAutoCollectEnabled do
                        claimChestsInUnlockedMaps()
                        task.wait(5)
                    end
                end)
            else
                if autoCollectThread then
                    task.cancel(autoCollectThread)
                    autoCollectThread = nil
                end
            end
        end
    })


    ClaimSection:Toggle("AutoPickUp", { Title = "Auto Pick Up", Default = false,
        Callback = function(enabled)
            _G.AutoPickUpEnabled = enabled
            if _G.AutoPickUpThread then task.cancel(_G.AutoPickUpThread); _G.AutoPickUpThread = nil end
            if enabled then
                _G.AutoPickUpThread = task.spawn(function()
                    local orbsFolder = Workspace:FindFirstChild("Debris") and Workspace.Debris:FindFirstChild("Orbs")
                    if not orbsFolder then return end
                    while _G.AutoPickUpEnabled and task.wait(0.2) do
                        local character, hrp = LocalPlayer.Character, nil
                        if character and character:FindFirstChild("HumanoidRootPart") then hrp = character.HumanoidRootPart else continue end
                        local orbsToCollect = {}
                        for _, orb in ipairs(orbsFolder:GetChildren()) do
                            if orb:IsA("BasePart") then
                                orb:SetAttribute("canCollect", true); orb.Anchored = true
                                if (orb.Position - hrp.Position).Magnitude <= math.huge then
                                    table.insert(orbsToCollect, orb.Name)
                                    local attachment = hrp:FindFirstChild("_orbAttachment" .. orb.Name); if attachment then attachment:Destroy() end
                                end
                            end
                        end
                        if #orbsToCollect > 0 then
                            pcall(function() OrbService.collectOrbs:Fire(orbsToCollect) end)
                            for _, orbName in ipairs(orbsToCollect) do local orb = orbsFolder:FindFirstChild(orbName); if orb then orb:Destroy() end end
                        end
                    end
                end)
            end
        end
    })

    pickupStarsThread = nil
    ClaimSection:Toggle("PickupStars", { Title = "Pickup Stars",
        Callback = function(enabled)
            if pickupStarsThread then task.cancel(pickupStarsThread); pickupStarsThread = nil end
            if enabled then
                pickupStarsThread = task.spawn(function()
                    while enabled do
                        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        local debris = Workspace:FindFirstChild("Debris")
                        if hrp and debris then
                            for _, starModel in ipairs(debris:GetChildren()) do
                                if starModel.Name == "FallingStar" then
                                    local starCore = starModel.PrimaryPart
                                    local hideFolder = starCore and starCore:FindFirstChild("hideAfterLanding")
                                    if hideFolder then
                                        local isStillFalling = false
                                        for _, particle in ipairs(hideFolder:GetChildren()) do
                                            if particle:IsA("ParticleEmitter") and particle.Enabled == true then
                                                isStillFalling = true
                                                break
                                            end
                                        end
                                        if not isStillFalling then
                                            pcall(firetouchinterest, hrp, starCore, 0)
                                            pcall(firetouchinterest, hrp, starCore, 1)
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        task.wait(0.1)
                    end
                end)
            end
        end
    })


    local autoClaimThreads = {}
    createClaimToggle = function(id, title, claimFunc)
        ClaimSection:Toggle("AutoClaim"..id, { Title = title, Default = false,
            Callback = function(enabled)
                if autoClaimThreads[id] then task.cancel(autoClaimThreads[id]); autoClaimThreads[id]=nil end
                if enabled then autoClaimThreads[id] = task.spawn(function() while enabled do pcall(claimFunc); task.wait(5) end end) end
            end
        })
    end

    createClaimToggle("Achievements", "Auto Claim Achievements", function()
        local Achievements = require(ReplicatedStorage.Shared.List.Achievements)
        DataController:waitForData()
        local playerData = DataController:getData()
        for achievementKey, achievementData in pairs(Achievements) do
            local currentLevel = 1
            for claimedId, _ in pairs(playerData.claimedAchievements) do if claimedId:find(achievementKey) then currentLevel = currentLevel + 1 end end
            if #achievementData.list >= currentLevel and achievementData.list[currentLevel].amount <= achievementData.getValue(playerData) then
                RewardService:claimAchievement(achievementKey); task.wait(1)
            end
        end
    end)

    local autoClaimPlaytimeEnabled = false
    ClaimSection:Toggle("AutoClaimPlaytime", {
        Title = "Auto Claim Playtime Rewards",
        Default = false,
        Callback = function(enabled)
            autoClaimPlaytimeEnabled = enabled

            if autoClaimPlaytimeThread then
                task.cancel(autoClaimPlaytimeThread)
                autoClaimPlaytimeThread = nil
            end

            if enabled then
                autoClaimPlaytimeThread = task.spawn(function()
                    local Holder = LocalPlayer.PlayerGui.MainUI.Menus.RewardsFrame.Main.Displays.Playtime.Holder

                    while autoClaimPlaytimeEnabled do
                        local success, err = pcall(function()
                            for _, rewardFrame in ipairs(Holder:GetChildren()) do
                                if rewardFrame:IsA("Frame") then
                                    local rewardId = tonumber(rewardFrame.Name)
                                    local timerLabel = rewardFrame:FindFirstChild("Main", true) and rewardFrame.Main:FindFirstChild("Timer")

                                    if timerLabel and timerLabel.Text == "Claim" then
                                        RewardService:claimPlaytimeReward(rewardId)
                                        task.wait(1)
                                    end
                                end
                            end
                        end)

                        if not success then
                        end

                        task.wait(10)
                    end
                end)
            end
        end
    })

    createClaimToggle("Daily", "Auto Claim Daily Reward", function()
        DataController:waitForData()
        local playerData = DataController:getData()
        if workspace:GetServerTimeNow() - playerData.dayReset >= 86400 and math.max(0, 600 - (playerData.dailyRewardRequiredTime or 0)) <= 0 then
            RewardService:claimDailyReward(); task.wait(1)
        end
    end)

    createClaimToggle("Prestige", "Auto Prestige", function()
        local PrestigeService = Knit.GetService("PrestigeService")
        local Prestiges = require(ReplicatedStorage.Shared.List.Prestige.Prestiges)
        DataController:waitForData()
        local playerData = DataController:getData()
        
        if playerData then
            local currentPrestige = playerData.prestige
            local currentPrestigeXP = playerData.prestigeXp
            local nextPrestige = Prestiges[currentPrestige + 1]
            
            if nextPrestige and currentPrestigeXP >= nextPrestige.required then
                PrestigeService:claim()
                task.wait(1)
            end
        end
    end)

    local IndexService = Knit.GetService("IndexService")
    local DataController = Knit.GetController("DataController")
    local PetController = Knit.GetController("PetController")

    local IndexRewards = require(ReplicatedStorage.Shared.List.IndexRewards)
    local Util = require(ReplicatedStorage.Shared.Util)

    ClaimSection:Toggle("AutoClaimIndexRewards", {
        Title = "Auto Claim Index Rewards",
        Default = false,
        Callback = function(enabled)
            autoClaimIndexRewardsEnabled = enabled
            if enabled then
                task.spawn(function()
                    DataController:waitForData()
                    while autoClaimIndexRewardsEnabled do
                        local playerData = DataController:getData()
                        if playerData then
                            local claimed = playerData.claimedIndexRewards or {}
                            local existTable = PetController:getExistTable()
                            local indexedCount = Util.indexUtils.countIndex(playerData, existTable)

                            for rewardId, rewardData in pairs(IndexRewards) do
                                local required = rewardData.required or 0
                                local alreadyClaimed = table.find(claimed, rewardId)


                                if indexedCount >= required and not alreadyClaimed then
                                    -- Claim reward every second until successful
                                    task.spawn(function()
                                        while autoClaimIndexRewardsEnabled and not table.find((DataController:getData().claimedIndexRewards or {}), rewardId) do
                                            local success, err = pcall(function()
                                                IndexService:claimIndexReward(rewardId)
                                            end)
                                            if success then
                                            else
                                            end
                                            task.wait(1)
                                        end
                                    end)
                                end
                            end
                        else
                        end
                        task.wait(5)
                    end
                end)
            else
            end
        end
    })


    local isAutoClaimAllChestsEnabled = false

    local AutoClaimAllChests = ClaimSection:Toggle("AutoClaimAllChests", { 
        Title = "Auto Claim All Chests", 
        Default = false,
        Callback = function(enabled)
            isAutoClaimAllChestsEnabled = enabled
        end
    })

    task.spawn(function()
        DataController:waitForData()
        local Chests = require(ReplicatedStorage.Shared.List.Chests)

        while true do
            if isAutoClaimAllChestsEnabled then
                pcall(function()
                    for chestId, chestData in pairs(Chests) do
                        RewardService:claimChest(chestId)
                        task.wait(0.2)
                    end
                end)
            end
            task.wait(10)
        end
    end)
    
    supplyDropThread = nil
    ClaimSection:Toggle("OpenSupplyDrops", { Title = "Open Supply Drops", Default = false,
        Callback = function(enabled)
            if supplyDropThread then task.cancel(supplyDropThread); supplyDropThread = nil end
            if enabled then
                supplyDropThread = task.spawn(function()
                    while enabled do
                        local debris = Workspace:FindFirstChild("Debris")
                        if debris then
                            for _, dropEvent in ipairs(debris:GetChildren()) do
                                if dropEvent.Name:find("SupplyDropEvent") then
                                    for _, obj in ipairs(dropEvent:GetChildren()) do
                                        local prompt = obj:FindFirstChild("ProximityPrompt"); if prompt then pcall(fireproximityprompt, prompt) end
                                    end
                                end
                            end
                        end
                        task.wait(1)
                    end
                end)
            end
        end
    })

    local TutorialSection = Tabs.Misc:AddSection("Tutorial")

    TutorialSection:AddButton({
        Title = "Complete Tutorial",
        Callback = function()
            local success, err = pcall(function()
                local TutorialList = require(ReplicatedStorage.Shared.List.Tutorial)
                local function forceCompleteCheck()
                    return true
                end

                local hookedCount = 0
                for i, stageData in ipairs(TutorialList) do
                    if type(stageData) == "table" and type(stageData.stageIsCompleted) == "function" then
                        stageData.stageIsCompleted = forceCompleteCheck
                        hookedCount = hookedCount + 1
                    end
                end
            end)
        end
    })

    AncientWheel = Tabs.Misc:AddSection("Ancient Wheel")
    isAutoSpinEnabled = false
    AncientWheel:Toggle("AutoSpin", { Title = "Auto Spin Ancient Wheel", Default = false,
        Callback = function(enabled)
            isAutoSpinEnabled = enabled
            task.spawn(function()
                while isAutoSpinEnabled do
                    pcall(function() RewardService:ancientWheelSpin() end)
                    task.wait(0.01)
                end
            end)
        end
    })

    
    ClanWheel = Tabs.Misc:AddSection("Clan Wheel")
    isAutoSpinEnabled1 = false
    ClanWheel:Toggle("AutoSpin1", { Title = "Auto Spin Clan Wheel", Default = false,
        Callback = function(enabled)
            isAutoSpinEnabled1 = enabled
            task.spawn(function()
                while isAutoSpinEnabled1 do
                    pcall(function() ClanService:clanWheelSpin()() end)
                    task.wait(60)
                end
            end)
        end
    })

    BoostWheel = Tabs.Misc:AddSection("Boost Wheel")
    isAutoSpinEnabled12 = false
    BoostWheel:Toggle("AutoSpin12", { Title = "Auto Spin Boost Wheel", Default = false,
        Callback = function(enabled)
            isAutoSpinEnabled12 = enabled
            task.spawn(function()
                while isAutoSpinEnabled12 do
                    pcall(function() RewardService:boostWheelSpin()() end)
                    task.wait(60)
                end
            end)
        end
    })


    AncientMerchantSection = Tabs.Misc:AddSection("Ancient Merchant")

    getAllAncientMerchantItems = function()
        local options, itemMap = {}, {}
        pcall(function()
            local AncientMerchant = require(ReplicatedStorage.Shared.List.AncientMerchant)
            for i, offer in ipairs(AncientMerchant) do
                local name, amount, price = offer.item.nm or "Unknown Item", offer.item.am or 1, offer.price or 0
                local displayName = string.format("%s - %d Ancient Tickets", (amount > 1 and (amount .. "x " .. name)) or name, price)
                table.insert(options, displayName)
                itemMap[displayName] = {name = name, amount = amount, price = price}
            end
        end)
        return options, itemMap
    end

    local merchantOptions, merchantItemMap = getAllAncientMerchantItems()
    local selectedMerchantItems = {}

    AncientMerchantSection:Dropdown("SelectItems", {Title = "Select Items", Values = merchantOptions, Multi = true, Searchable = true, Default = {}, Callback = function(value) selectedMerchantItems = value end})

    isAutoBuyEnabled = false
    AncientMerchantSection:Toggle("AutoBuy", {Title = "Auto Buy", Description = "Automatically buys selected items when they appear in the merchant", Default = false, Callback = function(enabled)
        isAutoBuyEnabled = enabled
        if enabled then
            task.spawn(function()
                while isAutoBuyEnabled do
                    if next(selectedMerchantItems) then
                        pcall(function()
                            local AncientMerchantList = require(ReplicatedStorage.Shared.List.AncientMerchant)
                            DataController:waitForData()
                            local data, boughtData, serverTimeNow = DataController:getData(), (DataController:getData()).ancientMerchantBought or {}, Knit.serverTimeNow or os.time()
                            for slot = 1, Values.ancientMerchantSlots(LocalPlayer, data) do
                                local ts = DateTime.fromUnixTimestamp(serverTimeNow + 3600):ToUniversalTime()
                                local seed = ts.Year * 222 + ts.Month * 333 + ts.Day * 444444 + ts.Hour * 33333 + LocalPlayer.UserId + slot
                                local itemData = AncientMerchantList[Functions.getRandom(AncientMerchantList, seed)]
                                if itemData then
                                    local merchantItem = itemData.item
                                    local merchantName = merchantItem.nm or "Unknown"
                                    local merchantAmount = merchantItem.am or 1
                                    
                                    for displayName, isSelected in pairs(selectedMerchantItems) do
                                        if isSelected and merchantItemMap[displayName] then
                                            local selectedItem = merchantItemMap[displayName]
                                            if merchantName == selectedItem.name and merchantAmount == selectedItem.amount then
                                                local key = string.format("%*", seed)
                                                if not boughtData[key] then
                                                    local ancientTickets = 0
                                                    if data.inventory and data.inventory.exclusive then 
                                                        for itemId, item in pairs(data.inventory.exclusive) do 
                                                            if item.nm == "ancientTicket" then 
                                                                ancientTickets = item.am or 0
                                                                break 
                                                            end 
                                                        end 
                                                    end
                                                    if ancientTickets >= selectedItem.price then 
                                                        RewardService:buyAncientMerchant(slot)
                                                        task.wait(2) 
                                                    end
                                                end
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end)
                    end
                    task.wait(5)
                end
            end)
        end
    end})


    PassSection = Tabs.Misc:AddSection("Season Pass")
    PassSection:Toggle("AutoClaimToggle", { Title = "Auto Claim Season Rewards", Description = "Automatically claims all available season pass rewards.", Default = false, Callback = function(s) _G.AutoClaimToggle = s end })
    PassSection:Toggle("AutoResetPassToggle", { Title = "Auto Reset Season Pass", Description = "Automatically resets the pass AFTER all rewards have been claimed.", Default = false, Callback = function(s) _G.AutoResetPassToggle = s end })

    task.spawn(function()
        while task.wait(5) do
            if not (_G.AutoClaimToggle or _G.AutoResetPassToggle) then continue end
            pcall(function()
                local playerData = DataController:getData(); if not playerData then return end
                local seasonNum, currentPassLevel, hasPremiumPass, claimedTiersData, totalTiers = seasonVariables.season, seasonUtils.seasonUtils.getLevel(playerData), playerData[("season%*PassPremium"):format(seasonVariables.season)], playerData[("season%*PassClaimed"):format(seasonVariables.season)], #seasonTiersList
                local allRewardsClaimed = true

                for tier = 1, totalTiers do
                    if tier > currentPassLevel then allRewardsClaimed = false; break end
                    for track = 1, 2 do
                        if track == 2 and not hasPremiumPass then continue end
                        local rewardKey = ("%*%*"):format(track, tier)
                        
                        if not claimedTiersData[rewardKey] then
                            allRewardsClaimed = false
                            if _G.AutoClaimToggle then
                                SeasonService:claimTier(tier, track)
                                task.wait(0.2)
                            end
                        end
                    end
                end
                
                if _G.AutoResetPassToggle and allRewardsClaimed then SeasonService:resetPass() end
            end)
        end
    end)


    Aura = Tabs.Misc:AddSection("Aura")
    local AuraDices = require(ReplicatedStorage.Shared.List.Items.AuraDices)
    selectedDiceItems, autoRollThread = {}, nil
    local diceNames, diceOptions = {}, {}
    do local names = {} for name, info in pairs(AuraDices) do table.insert(names, info.name); diceOptions[info.name]=name end table.sort(names); diceNames=names end

    updateDiceStatus = function()
        local statusLines, hasSelected = {}, false
        pcall(function()
            DataController:waitForData()
            local playerData = DataController:getData()
            for diceName, isSelected in pairs(selectedDiceItems) do
                if isSelected then
                    hasSelected = true
                    local item = Util.itemUtils.getItemFromName(playerData, diceOptions[diceName])
                    table.insert(statusLines, string.format("%s (%dx)", diceName, (item and item:getAmount() or 0)))
                end
            end
        end)
        return not hasSelected and "No dice selected" or table.concat(statusLines, "\n")
    end

    local AuraDiceDropdown = Aura:Dropdown("SelectAuraDice", { Title = "Select Aura Dice", Values = diceNames, Multi = true, Searchable = true, Default = {} })
    local SelectedDiceParagraph = Aura:Paragraph("SelectedDiceDisplay", { Title = "Selected Dice", Content = "No dice selected" })
    AuraDiceDropdown:OnChanged(function(value) selectedDiceItems = value end)

    Aura:Toggle("AutoRoll", { Title = "Auto Roll", Default = false,
        Callback = function(enabled)
            if autoRollThread then task.cancel(autoRollThread); autoRollThread = nil end
            if enabled then
                autoRollThread = task.spawn(function()
                    while enabled do
                        local availableDice = {}
                        pcall(function()
                            DataController:waitForData(); local playerData = DataController:getData()
                            for diceName, isSelected in pairs(selectedDiceItems) do
                                if isSelected then local item=Util.itemUtils.getItemFromName(playerData, diceOptions[diceName]); if item and item:getAmount()>0 then table.insert(availableDice, diceOptions[diceName]) end end
                            end
                        end)
                        if #availableDice > 0 then pcall(function() AuraService:roll(availableDice[math.random(1,#availableDice)]) end) end
                        task.wait(1)
                    end
                end)
            end
        end
    })

    task.spawn(function() while true do SelectedDiceParagraph:SetValue(updateDiceStatus()); task.wait(1) end end)

    local CraftDiceSection = Tabs.Misc:AddSection("Craft Dice")

    -- Get all aura dice crafting recipes
    local AuraDiceCrafting = require(ReplicatedStorage.Shared.List.AuraDiceCrafting)
    local diceCraftOptions, diceCraftMap = {}, {}

    for i, recipe in ipairs(AuraDiceCrafting) do
        local requiredName = recipe.item:getName()
        local rewardName = recipe.reward:getName()
        local displayName = requiredName .. "  " .. rewardName
        table.insert(diceCraftOptions, displayName)
        diceCraftMap[displayName] = {
            recipeIndex = i,
            requiredName = requiredName,
            rewardName = rewardName,
            requiredAmount = recipe.item:getAmount(),
            rewardId = rewardName
        }
    end

    local selectedDiceCrafts = {}

    local DiceCraftDropdown = CraftDiceSection:Dropdown("SelectDiceCrafts", {
        Title = "Select Dice to Craft",
        Description = "Choose which aura dice to craft",
        Values = diceCraftOptions,
        Multi = true,
        Searchable = true,
        Default = {},
        Callback = function(value)
            selectedDiceCrafts = value
        end
    })

    local isAutoCraftDiceEnabled = false

    CraftDiceSection:Toggle("CraftAllDice", {
        Title = "Craft All (Selected)",
        Description = "Automatically crafts all selected aura dice as much as possible",
        Default = false,
        Callback = function(enabled)
            isAutoCraftDiceEnabled = enabled
            if enabled then
                task.spawn(function()
                    while isAutoCraftDiceEnabled do
                        pcall(function()
                            DataController:waitForData()
                            local playerData = DataController:getData()
                            for displayName, isSelected in pairs(selectedDiceCrafts) do
                                if isSelected and diceCraftMap[displayName] then
                                    local craftInfo = diceCraftMap[displayName]
                                    local requiredItem = AuraDiceCrafting[craftInfo.recipeIndex].item
                                    local rewardItem = AuraDiceCrafting[craftInfo.recipeIndex].reward
                                    local requiredName = craftInfo.requiredName
                                    local requiredAmount = craftInfo.requiredAmount
                                    local rewardId = craftInfo.recipeIndex

                                    local playerItem = Util.itemUtils.getItemFromName(playerData, requiredName)
                                    local playerAmount = playerItem and playerItem:getAmount() or 0
                                    local maxCraftable = math.floor(playerAmount / requiredAmount)

                                    if maxCraftable > 0 then
                                        local Knit = require(ReplicatedStorage.Packages.Knit)
                                        local AuraService = Knit.GetService("AuraService")
                                        AuraService:craftDice(rewardId, maxCraftable)
                                        task.wait(1)
                                    end
                                end
                            end
                        end)
                        task.wait(5)
                    end
                end)
            end
        end
    })
    
local PetArchiverSection = Tabs.Misc:AddSection("Pet Archiver")

    local petsToKeepInput = PetArchiverSection:AddInput("PetsToKeepInput", {
        Title = "Number of best Pets to KEEP",
        Default = "20",
        Numeric = true,
        Description = "Keeps your strongest pets."
    })

    local keepSpecialToggle = PetArchiverSection:AddToggle("KeepSpecialPetsToggle", {
        Title = "Keep Event Pets",
        Description = "Keep pets with an event boost.",
        Default = true
    })

    PetArchiverSection:AddButton({
        Title = "Archive Unwanted Pets",
        Description = "This will never archive a pet which has a % bonus. This will archive all pets, other then equipped pets, your strongest pets, and event pets (if selected).",
        Callback = function()
            local numToKeep = tonumber(petsToKeepInput.Value) or 20
            local shouldKeepPercentBonus = keepSpecialToggle.Value
            
            local playerData = DataController:getData()
            local PetDefinitions = require(ReplicatedStorage.Shared.List.Pets.Pets)
            
            if not playerData or not playerData.inventory or not playerData.inventory.pet then
                warn("Pet Archiver: Could not load pet inventory data.")
                return
            end

            local allPetsMasterList = {}
            pcall(function()
                for petId, petRawData in pairs(playerData.inventory.pet) do
                    local petObject = Util.itemUtils.createItemFromData(petRawData)
                    if petObject then
                        table.insert(allPetsMasterList, {
                            id = petId,
                            name = petObject:getName(),
                            multiplier = petObject:getMultiplier()
                        })
                    end
                end
            end)
            table.sort(allPetsMasterList, function(a, b) return a.multiplier > b.multiplier end)

            local petsToKeepIds = {}

            -- Rule 1: Keep Top N pets
            for i = 1, math.min(numToKeep, #allPetsMasterList) do
                petsToKeepIds[allPetsMasterList[i].id] = true
            end

            -- Rule 2: Keep ALL equipped pets
            if playerData.equippedPets then
                for petId, _ in pairs(playerData.equippedPets) do
                    petsToKeepIds[petId] = true
                end
            end
            
            -- Rule 3 & 4: Keep special bonus pets
            for _, petData in ipairs(allPetsMasterList) do
                local petDef = PetDefinitions[petData.name]
                if petDef then
                    -- ALWAYS keep pets with the dynamic 'special' key
                    if petDef.special then
                        petsToKeepIds[petData.id] = true
                    end
                    -- CONDITIONALLY keep pets with the 'specialMultiplier' key
                    if petDef.specialMultiplier and shouldKeepPercentBonus then
                        petsToKeepIds[petData.id] = true
                    end
                end
            end

            local petsToArchiveIds = {}
            for petId, _ in pairs(playerData.inventory.pet) do
                if not petsToKeepIds[petId] then
                    petsToArchiveIds[petId] = true
                end
            end

            if next(petsToArchiveIds) then
                pcall(function()
                    PetService:archivePets(petsToArchiveIds, 1)
                end)
                print(string.format("Archiver: Sent %d pets to the archive.", table.getn(petsToArchiveIds)))
            else
                print("Archiver: No pets to archive based on your rules.")
            end
        end
    })
    EventSection = Tabs.Misc:AddSection("Events")
    isAutoBreakingMeteors = false
    EventSection:Toggle("AutoBreakMeteors", { Title = "Auto Break Meteors (Infinite Range)", Default = false,
        Callback = function(Value)
            isAutoBreakingMeteors = Value
            if Value then
                task.spawn(function()
                    while isAutoBreakingMeteors do
                        local allMeteors = CollectionService:GetTagged("Meteor")
                        if #allMeteors > 0 then
                            while #allMeteors > 0 and isAutoBreakingMeteors do
                                for _, meteor in ipairs(allMeteors) do
                                    pcall(function() local id=meteor:GetAttribute("meteorId"); if id then EventService.damageMeteor:Fire(id) end end)
                                end
                                task.wait()
                                allMeteors = CollectionService:GetTagged("Meteor")
                            end
                        end
                        task.wait(5)
                    end
                end)
            end
        end
    })

    -- Hand the library over to our managers
    SaveManager:SetLibrary(Library)
    InterfaceManager:SetLibrary(Library)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetIgnoreIndexes{}
    InterfaceManager:SetFolder("FluentScriptHub")
    SaveManager:SetFolder("FluentScriptHub/specific-game")
    InterfaceManager:BuildInterfaceSection(Tabs.Settings)
    SaveManager:BuildConfigSection(Tabs.Settings)

    local usercountsection = Tabs.Settings:AddSection("User Count")

    local userCountParagraph = Tabs.Settings:AddParagraph("UserCountStatus", {
        Title = "Script User Count",
        Content = "Loading..."
    })


    -- Step 1: Register the user
    local registerResponse = requestFunc({
        Url = "https://duckyscripts.pythonanywhere.com/api/rcu/add-user",
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = HttpService:JSONEncode({
            username = username,
            userid = userid
        })
    })

    if registerResponse and registerResponse.Body then
    end


    task.spawn(function()
        while true do
            local heartbeatResponse = requestFunc({
                Url = "https://duckyscripts.pythonanywhere.com/api/rcu/active",
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = HttpService:JSONEncode({
                    userid = userid,
                    active = true
                })
            })

            if heartbeatResponse and heartbeatResponse.Body then
                local responseBody = heartbeatResponse.Body
                local data = HttpService:JSONDecode(responseBody)
                local activeCount = data.active_count or 0
                local totalCount = data.count or 0
                userCountParagraph:SetValue(tostring ("Total users: " .. tostring(totalCount) .. "\n" .. "Active Users: " .. tostring(activeCount)))
            end

            task.wait(30) 
        end
    end)


    Window:SelectTab(1)
    SaveManager:LoadAutoloadConfig()
end

task.spawn(function()
    if not game:IsLoaded() then game.Loaded:Wait() end

    Knit = require(ReplicatedStorage.Packages.Knit)
    Knit.OnStart():await()

    ClickService = Knit.GetService("ClickService")
    EggService = Knit.GetService("EggService")
    RebirthService = Knit.GetService("RebirthService")
    TreeService = Knit.GetService("TreeService")
    AxeService = Knit.GetService("AxeService")
    InventoryService = Knit.GetService("InventoryService")
    PetService = Knit.GetService("PetService")
    RewardService = Knit.GetService("RewardService")
    ClanService = Knit.GetService("ClanService")
    UpgradeService = Knit.GetService("UpgradeService")
    SeasonService = Knit.GetService("SeasonService")
    FarmService = Knit.GetService("FarmService")
    AuraService = Knit.GetService("AuraService")
    EventService = Knit.GetService("EventService")
    OrbService = Knit.GetService("OrbService")
    BuildingService = Knit.GetService("BuildingService")
    LumberjackService = Knit.GetService("LumberjackService")
    DungeonService = Knit.GetService("DungeonService")
    
    DataController = Knit.GetController("DataController")
    EggController = Knit.GetController("EggController")
    TreeController = Knit.GetController("TreeController")
    AuraController = Knit.GetController("AuraController")
    MapController = Knit.GetController("MapController")
    OrbController = Knit.GetController("OrbController")
    ItemController = Knit.GetController("ItemController")
    SoundController = Knit.GetController("SoundController")
    FarmController = Knit.GetController("FarmController")
    BuildingController = Knit.GetController("BuildingController")
    HatchingController = require(LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("Client"):WaitForChild("Controllers"):WaitForChild("HatchingController"))
    
    Functions = require(ReplicatedStorage.Shared.Functions)
    seasonVariables = require(ReplicatedStorage.Shared.Variables)
    seasonUtils = require(ReplicatedStorage.Shared.Util)
    seasonTiersList = require(ReplicatedStorage.Shared.List[("Season%*"):format(seasonVariables.season)].Tiers)
    Util = require(ReplicatedStorage.Shared.Util)
    Values = require(ReplicatedStorage.Shared.Values)   

    Window = Library:Window{
        Title = "RCU",
        SubTitle = "By Duckie",
        TabWidth = 160,
        Size =  UDim2.fromOffset(580, 460),
        Resize = false,
        Theme = "Darker",
        MinimizeKey = Enum.KeyCode.LeftShift
    }

    Tabs = {
        Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
        Event = Window:AddTab({ Title = "Event", Icon = "ghost" }),
        Main = Window:AddTab({ Title = "Auto Farm", Icon = "crown" }),
        Eggs = Window:AddTab({ Title = "Eggs", Icon = "egg" }),
        Tree = Window:AddTab({ Title = "Axe/Tree", Icon = "phosphor-tree-evergreen-duotone" }),
        Farm = Window:AddTab({ Title = "Farming", Icon = "phosphor-farm-bold" }),
        Pet = Window:AddTab({ Title = "Pet Crafting", Icon = "paw-print" }),
        Machine = Window:AddTab({ Title = "Machines/Minigames", Icon = "phosphor-game-controller-bold" }),
        Dunegon = Window:AddTab({ Title = "Dungeon", Icon = "phosphor-shield-checkered-bold" }),
        Craft = Window:AddTab({ Title = "Building", Icon = "hammer" }),
        Quest = Window:AddTab({ Title = "Quests", Icon = "phosphor-scroll-bold" }),
        Claim = Window:AddTab({ Title = "Auto Claim/Collect", Icon = "gift" }),
        Misc = Window:AddTab({ Title = "Misc", Icon = "sparkles" }),
    }

    BuildUI()
end)
