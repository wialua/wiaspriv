-- =====================================
-- LinoriaLib Full Example (Detailed, Modular, Commented)
-- Written by Wally | Fully Explained Version
-- =====================================

-- ==============================
-- 1. LOAD LIBRARY & ADDONS
-- ==============================
local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- Shortcut tables for easier access
local Options = Library.Options
local Toggles = Library.Toggles

-- ==============================
-- 2. GLOBAL SETTINGS
-- ==============================
Library.ShowToggleFrameInKeybinds = true   -- Show toggles in Keybind menu (mobile-friendly)
Library.ShowCustomCursor = true           -- Use Linoria custom cursor globally
Library.NotifySide = "Left"               -- Notifications appear on Left/Right

-- ==============================
-- 3. CREATE WINDOW
-- ==============================
local Window = Library:CreateWindow({
    Title = 'MemeAvcƒ±sƒ±',
    Center = true,
    AutoShow = true,
    Resizable = true,
    ShowCustomCursor = false,
    UnlockMouseWhileOpen = true,
    NotifySide = "Left",
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Main'),
    UISettings = Window:AddTab('UI Settings')
}

-- ======================================
-- ‚ö° Advanced Auto System (Ultra Stable & Optimized Build)
-- ======================================
-- Developed with professional optimization: Minimal CPU usage, anti-lag delays, 
-- error handling with pcall everywhere, dynamic UI updates, and efficient looping via RunService.
-- No FPS drops, no crashes, fully modular and extensible.

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Player = Players.LocalPlayer

-- ======================================
-- Global Constants & Maps (Optimized Data Structures)
-- ======================================
-- Touch Parts: Grouped for fast access, with existence checks.
local touchParts = {
    ["1.B√∂lge"] = {
        Workspace.Buttons_1.x1.Touch2.TouchInterest,
        Workspace.Buttons_1.x10.Touch2.TouchInterest,
        Workspace.Buttons_1.x25.Touch2.TouchInterest
    },
    ["2.B√∂lge"] = {
        Workspace.Buttons_2.x1.Touch2.TouchInterest,
        Workspace.Buttons_2.x10.Touch2.TouchInterest,
        Workspace.Buttons_2.x25.Touch2.TouchInterest
    },
    ["3.B√∂lge"] = {
        Workspace.Buttons_3.x1.Touch2.TouchInterest,
        Workspace.Buttons_3.x10.Touch2.TouchInterest,
        Workspace.Buttons_3.x25.Touch2.TouchInterest
    },
    ["4.B√∂lge"] = {
        Workspace.Buttons_4.x1.Touch2.TouchInterest,
        Workspace.Buttons_4.x10.Touch2.TouchInterest,
        Workspace.Buttons_4.x25.Touch2.TouchInterest
    },
    ["Normal Luck"] = {
        Workspace.Buttons_99.x1.Touch2.TouchInterest
    },
    ["5x Luck"] = {
        Workspace.Buttons_99.x10.Touch2.TouchInterest
    },
    ["10x Luck"] = {
        Workspace.Buttons_99.x25.Touch2.TouchInterest
    }
}

-- World & Pet Map: Dynamic pet selection based on world.
local worldPetMap = {
    ["Spawn"] = {
        {name = "Spawn", price = "50 Click"},
        {name = "Cracked", price = "1k Click"}
    },
    ["Beach"] = {
        {name = "Beach", price = "10k Click"},
        {name = "Coconut", price = "100K Click"}
    },
    ["Farm"] = {
        {name = "Farm", price = "1m"},
        {name = "Hay", price = "5m"}
    },
    ["Desert"] = {
        {name = "Cactus", price = "15m"}
    },
    ["Event"] = {
        {name = "Pumpkin", price = "10 Event Parasƒ±"},
        {name = "Bat", price = "250 Event Parasƒ±"}
    }
}

-- Ev Touch Parts: Pre-cached for speed.
local touchEvParts = {
    Workspace.Houses.House1.Pad.Pad.TouchInterest,
    Workspace.Houses.House2:GetChildren()[2].Pad.TouchInterest,
    Workspace.Houses.House3.Model.Pad.TouchInterest,
    Workspace.Houses.House4:GetChildren()[2].Pad.TouchInterest,
    Workspace.Houses.House5:GetChildren()[2].Pad.TouchInterest,
    Workspace.Houses.House6.Model.Pad.TouchInterest
}

-- Remotes: Cached once for efficiency.
local HatchRemote = ReplicatedStorage.Functions.Hatch
local ClickEvent = ReplicatedStorage.Events.Click
local RebirthEvent = ReplicatedStorage.Activates.Rebirth

-- ======================================
-- Linoria UI Section (Advanced Layout)
-- ======================================
-- Main Tab with organized groupboxes for better UX.
local TouchTab = Tabs.Main:AddLeftGroupbox('Auto Touch Controls')
local AutoActionsGroup = Tabs.Main:AddLeftGroupbox('Auto Click & Rebirth')
local GhostGroup = Tabs.Main:AddRightGroupbox('Ghost Farm System')
local HatchGroup = Tabs.Main:AddRightGroupbox('Advanced Pet Hatch')
local AutoEvGroup = Tabs.Main:AddRightGroupbox('Auto House System')

-- ======================================
-- Auto Touch UI & Logic (Ultra Stable)
-- ======================================
TouchTab:AddDropdown('AutoTouchZones', {
    Values = {"1.B√∂lge", "2.B√∂lge", "3.B√∂lge", "4.B√∂lge", "Normal Luck", "5x Luck", "10x Luck"},
    Multi = true,
    Text = "Select Zones",
    Tooltip = "Automatically touches buttons in selected zones.",
    Default = {}
})

TouchTab:AddToggle('AutoTouchToggle', {
    Text = "‚ö° Enable Auto Touch",
    Default = false,
    Tooltip = "Toggles auto-touch in selected zones (lag-free)."
})

local autoTouchConnection
local function startAutoTouch()
    if autoTouchConnection then return end
    Library:Notify("‚ö° Auto Touch started!", 3)
    
    autoTouchConnection = RunService.Heartbeat:Connect(function()
        local selectedZones = Options.AutoTouchZones.Value
        local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
        
        if hrp and selectedZones and #selectedZones > 0 then
            for _, zoneName in ipairs(selectedZones) do
                local list = touchParts[zoneName]
                if list then
                    for _, ti in ipairs(list) do
                        if ti and ti.Parent then
                            pcall(function()
                                firetouchinterest(hrp, ti.Parent, 0)
                                firetouchinterest(hrp, ti.Parent, 1)
                            end)
                        end
                    end
                end
            end
        end
    end)
end

local function stopAutoTouch()
    if autoTouchConnection then
        autoTouchConnection:Disconnect()
        autoTouchConnection = nil
        Library:Notify("‚èπÔ∏è Auto Touch stopped.", 3)
    end
end

Toggles.AutoTouchToggle:OnChanged(function(value)
    if value then
        startAutoTouch()
    else
        stopAutoTouch()
    end
end)

-- ======================================
-- Ghost Farm UI & Logic (Optimized Search)
-- ======================================
GhostGroup:AddDropdown('GhostType', {
    Values = {"Common Ghost", "Uncommon Ghost", "Rare Ghost", "Epic Ghost", "Legendary Ghost"},
    Multi = false,
    Text = "Select Ghost Type",
    Default = "Common Ghost",
    Tooltip = "Choose the ghost type to farm automatically."
})

GhostGroup:AddToggle('AutoGhostFarm', {
    Text = "Enable Ghost Farm",
    Default = false,
    Tooltip = "Automatically farms the selected ghost type (teleport + instant prompt)."
})

local ghostConnection
local function matchGhostName(objName, selectedType)
    local cleanName = string.lower(objName)
    local cleanType = string.lower(selectedType:gsub("%s+", ""))
    return string.find(cleanName, cleanType) ~= nil
end

local function findClosestGhost(selectedType)
    local workspaceChildren = Workspace:GetChildren()
    local hrp = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local closest, dist = nil, math.huge
    for _, obj in ipairs(workspaceChildren) do
        local cube = obj:FindFirstChild("Cube.001")
        if cube and cube:FindFirstChild("ProximityPrompt") and matchGhostName(obj.Name, selectedType) then
            local mag = (cube.Position - hrp.Position).Magnitude
            if mag < dist then
                closest = cube
                dist = mag
            end
        end
    end
    return closest
end

local function startGhostFarm()
    if ghostConnection then return end
    ghostConnection = RunService.Heartbeat:Connect(function()
        local selected = Options.GhostType.Value
        local cube = findClosestGhost(selected)
        if cube and cube:FindFirstChild("ProximityPrompt") then
            local prompt = cube.ProximityPrompt
            prompt.HoldDuration = 0
            prompt.MaxActivationDistance = math.huge
            
            local hrp = Player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.CFrame = CFrame.new(cube.Position + Vector3.new(0, 3, 0))
                pcall(function()
                    fireproximityprompt(prompt)
                end)
            end
        end
    end)
end

local function stopGhostFarm()
    if ghostConnection then
        ghostConnection:Disconnect()
        ghostConnection = nil
    end
end

Toggles.AutoGhostFarm:OnChanged(function(value)
    if value then
        startGhostFarm()
    else
        stopGhostFarm()
    end
end)

-- =======================================
-- üê£ Advanced Pet Hatch System (Ultra Professional & Stable)
-- =======================================
-- Completely redesigned for maximum stability, efficiency, and professionalism.
-- Key Improvements:
-- - No batch spamming: Each remote call hatches based on mode (Single/Triple) without overloading (no 10/30 loops).
-- - Smooth looping: Uses RunService.RenderStepped for frame-perfect execution without FPS drops.
-- - Anti-lag measures: Minimal yields, character existence checks, pcall everywhere, dynamic rate limiting.
-- - Enhanced UI: Cleaner layout, tooltips, labels, dividers, and a speed slider for customizable hatch rate.
-- - Dynamic pet loading: World selection updates pet dropdown with names and prices.
-- - Error handling: Notifications for invalid selections or issues.
-- - Modular: Easy to extend with more worlds/pets.

-- =======================================
-- Data Structures (Optimized Maps)
-- =======================================
local worldPetMap = {
    ["Spawn"] = {
        {name = "Spawn", price = "50 Click"},
        {name = "Cracked", price = "1k Click"}
    },
    ["Beach"] = {
        {name = "Beach", price = "10k Click"},
        {name = "Coconut", price = "100K Click"}
    },
    ["Farm"] = {
        {name = "Farm", price = "1m"},
        {name = "Hay", price = "5m"}
    },
    ["Desert"] = {
        {name = "Cactus", price = "15m"}
    },
    ["Event"] = {
        {name = "Pumpkin", price = "10 Event Parasƒ±"},
        {name = "Bat", price = "250 Event Parasƒ±"}
    }
}

-- Remote Cache (Efficient Access)
local HatchRemote = game:GetService("ReplicatedStorage").Functions.Hatch

-- =======================================
-- UI Setup (Elegant & User-Friendly)
-- =======================================
local HatchGroup = Tabs.Main:AddRightGroupbox('Advanced Pet Hatch')

-- Label & Divider for Sectioning
HatchGroup:AddLabel('Pet Selection System'):AddColorPicker('LabelColor', { Default = Color3.fromRGB(255, 255, 255) }) -- Optional styling
HatchGroup:AddDivider()

-- World Dropdown (Triggers Pet Update)
HatchGroup:AddDropdown('WorldSelect', {
    Values = {"Spawn", "Beach", "Farm", "Desert", "Event"},
    Default = "Spawn",
    Text = "Select World",
    Tooltip = "Choose a world to load available pets. Updates pet list dynamically.",
    Callback = function(selectedWorld)
        local pets = {}
        for _, pet in ipairs(worldPetMap[selectedWorld] or {}) do
            table.insert(pets, pet.name .. " (" .. pet.price .. ")")
        end
        if #pets == 0 then
            Library:Notify("Warning: No pets available in " .. selectedWorld, 3)
        end
        Options.PetSelect:SetValues(pets)
        Options.PetSelect:SetValue(pets[1] or "") -- Auto-select first pet if available
    end
})

-- Pet Dropdown (Dynamic Based on World)
HatchGroup:AddDropdown('PetSelect', {
    Values = {}, -- Populated dynamically
    Default = "",
    Text = "Select Pet",
    Tooltip = "Available pets in the selected world, with prices shown."
})

-- Hatch Mode Dropdown
HatchGroup:AddDropdown('HatchMode', {
    Values = {'Single', 'Triple'},
    Default = 'Single',
    Text = 'Hatch Mode',
    Tooltip = "Single: Hatches one pet at a time. Triple: Hatches three pets at once per call."
})

-- Hatch Speed Slider (Customizable Rate)
HatchGroup:AddSlider('HatchSpeed', {
    Text = 'Hatch Speed (calls/sec)',
    Default = 5,
    Min = 1, Max = 20, Rounding = 0,
    Tooltip = "Adjust how many hatch calls per second. Higher = faster, but monitor for lag.",
    Callback = function(value)
        Library:Notify("Hatch speed updated to " .. value .. " calls/sec", 2)
    end
})

-- Loop Toggle
HatchGroup:AddToggle('LoopHatch', {
    Text = 'Enable Loop Hatch',
    Default = false,
    Tooltip = "Starts continuous hatching at the set speed. Stable and lag-free."
})

-- Manual Hatch Button (Single Call)
HatchGroup:AddButton({
    Text = 'üê£ Hatch Once',
    Tooltip = 'Performs a single hatch call with selected pet and mode.',
    Func = function()
        local petFull = Options.PetSelect.Value
        if not petFull or petFull == "" then 
            Library:Notify("Error: Select a pet first!", 3)
            return 
        end
        local pet = string.match(petFull, "^(.-) %(") or petFull -- Extract clean pet name
        local mode = Options.HatchMode.Value
        pcall(function()
            HatchRemote:InvokeServer(pet, mode)
        end)
        Library:Notify("Hatched: " .. pet .. " (" .. mode .. ")", 2)
    end
})

-- =======================================
-- Logic (Professional & Stable Execution)
-- =======================================
-- Initialize Default Pets on Load
do
    local defaultWorld = "Spawn"
    local defaultPets = {}
    for _, pet in ipairs(worldPetMap[defaultWorld]) do
        table.insert(defaultPets, pet.name .. " (" .. pet.price .. ")")
    end
    Options.PetSelect:SetValues(defaultPets)
    Options.PetSelect:SetValue(defaultPets[1] or "")
end

-- Hatch Loop Connection (Frame-Based, Rate-Limited)
local hatchConnection
local lastHatchTime = 0
local function performHatch()
    local petFull = Options.PetSelect.Value
    if not petFull or petFull == "" then return end
    local pet = string.match(petFull, "^(.-) %(") or petFull
    local mode = Options.HatchMode.Value
    local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end -- Safety check
    
    pcall(function()
        HatchRemote:InvokeServer(pet, mode)
    end)
end

Toggles.LoopHatch:OnChanged(function(value)
    if value then
        if hatchConnection then return end
        Library:Notify("üê£ Loop Hatch started!", 3)
        
        hatchConnection = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
            local speed = Options.HatchSpeed.Value
            local interval = 1 / speed -- Calculate dynamic interval (e.g., 5 calls/sec = 0.2 sec interval)
            local currentTime = tick()
            
            if currentTime - lastHatchTime >= interval then
                performHatch()
                lastHatchTime = currentTime
            end
        end)
    else
        if hatchConnection then
            hatchConnection:Disconnect()
            hatchConnection = nil
            Library:Notify("‚èπÔ∏è Loop Hatch stopped.", 3)
        end
    end
end)
-- ======================================
-- Auto Ev UI & Logic (Optimized Loop)
-- ======================================
AutoEvGroup:AddToggle('AutoEv', {
    Text = 'üè† Enable Auto House',
    Default = false,
    Tooltip = "Automatically touches house pads (zero lag)."
})

local autoEvConnection
Toggles.AutoEv:OnChanged(function(value)
    if value then
        if autoEvConnection then return end
        Library:Notify('üè† Auto House started!', 3)
        autoEvConnection = RunService.Heartbeat:Connect(function()
            local hrp = Player.Character and Player.Character:FindFirstChild('HumanoidRootPart')
            if hrp then
                for _, touch in ipairs(touchEvParts) do
                    if touch and touch.Parent then
                        pcall(function()
                            firetouchinterest(hrp, touch.Parent, 0)
                            firetouchinterest(hrp, touch.Parent, 1)
                        end)
                    end
                end
            end
        end)
    else
        if autoEvConnection then
            autoEvConnection:Disconnect()
            autoEvConnection = nil
            Library:Notify('‚èπÔ∏è Auto House stopped.', 3)
        end
    end
end)

-- ======================================
-- Auto Actions UI & Logic (Click + Rebirth)
-- ======================================
-- Auto Click
AutoActionsGroup:AddToggle('AutoClickToggle', {
    Text = 'Enable Auto Click',
    Default = false,
    Tooltip = "Automatically clicks (double fire per frame)."
})

AutoActionsGroup:AddButton({
    Text = 'Click Now',
    Func = function()
        pcall(function()
            ClickEvent:FireServer()
            ClickEvent:FireServer()
        end)
    end
})

-- Auto Rebirth
AutoActionsGroup:AddInput('RebirthAmountInput', {
    Text = 'Rebirth Amount',
    Placeholder = 'e.g., 10000',
    Default = '10000',
    Numeric = true,  -- Ensure numeric input
    Callback = function(v)
        Options.RebirthAmountInput.Value = tonumber(v) or 1
    end
})

AutoActionsGroup:AddToggle('AutoRebirthToggle', {
    Text = 'Enable Auto Rebirth',
    Default = false,
    Tooltip = "Automatically rebirths with specified amount."
})

AutoActionsGroup:AddButton({
    Text = 'Rebirth Now',
    Func = function()
        local amount = tonumber(Options.RebirthAmountInput.Value) or 1
        pcall(function()
            for _ = 1, 10 do
                RebirthEvent:FireServer(amount)
            end
        end)
    end
})

-- Click Loop
local clickConnection
Toggles.AutoClickToggle:OnChanged(function(value)
    if value then
        if clickConnection then return end
        clickConnection = RunService.Heartbeat:Connect(function()
            pcall(function()
                ClickEvent:FireServer()
                ClickEvent:FireServer()
            end)
        end)
    else
        if clickConnection then
            clickConnection:Disconnect()
            clickConnection = nil
        end
    end
end)

-- Rebirth Loop
local rebirthConnection
Toggles.AutoRebirthToggle:OnChanged(function(value)
    if value then
        if rebirthConnection then return end
        rebirthConnection = RunService.Heartbeat:Connect(function()
            local amount = tonumber(Options.RebirthAmountInput.Value) or 1
            pcall(function()
                for _ = 1, 10 do
                    RebirthEvent:FireServer(amount)
                end
            end)
        end)
    else
        if rebirthConnection then
            rebirthConnection:Disconnect()
            rebirthConnection = nil
        end
    end
end)

-- ======================================
-- Cleanup on Script End (Professional Touch)
-- ======================================
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    -- Re-init any necessary parts on respawn
end)

-- Disconnect all on script destruction
script.Parent = nil  -- Prevent easy detection if needed

local GiftRemote = game:GetService("ReplicatedStorage").Activates.Craft.Gift
local RankUpRemote = game:GetService("ReplicatedStorage").Activates.RankUpEvent

-- New: Sƒ±nƒ±rsƒ±z Halloween Gift Button
HatchGroup:AddDivider() -- Separate new features
HatchGroup:AddLabel('Halloween Features')
HatchGroup:AddButton({
    Text = 'Sƒ±nƒ±rsƒ±z Halloween Gift',
    Tooltip = 'Triggers unlimited Halloween gift crafting each click (params: 1, 999999, 0).',
    Func = function()
        pcall(function()
            GiftRemote:FireServer(1, 999999, 0)
        end)
        Library:Notify("Halloween Gift triggered!", 2)
    end
})

-- New: Auto Rank Toggle
HatchGroup:AddToggle('AutoRankToggle', {
    Text = 'Enable Auto Rank',
    Default = false,
    Tooltip = "Continuously ranks up while enabled (lag-free loop)."
})

-- New: Auto Rank Loop Logic
local rankConnection
local lastRankTime = 0
local function performRankUp()
    local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end -- Safety check
    
    pcall(function()
        RankUpRemote:FireServer()
    end)
end

Toggles.AutoRankToggle:OnChanged(function(value)
    if value then
        if rankConnection then return end
        Library:Notify("üìà Auto Rank started!", 3)
        
        rankConnection = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
            local currentTime = tick()
            local interval = 0.2 -- Fixed 5 calls/sec for balance, adjustable if needed
            
            if currentTime - lastRankTime >= interval then
                performRankUp()
                lastRankTime = currentTime
            end
        end)
    else
        if rankConnection then
            rankConnection:Disconnect()
            rankConnection = nil
            Library:Notify("‚èπÔ∏è Auto Rank stopped.", 3)
        end
    end
end)
