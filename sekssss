local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

local requestFunc = (syn and syn.request) or (http and http.request) or request
if not requestFunc then
    warn("Your executor does not support HTTP requests.")
    return
end

local player = Players.LocalPlayer
local userid = player.UserId
local username = player.Name


local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/Pet-Warriors/refs/heads/main/test"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()
loadstring(game:HttpGet("https://raw.githubusercontent.com/SenhorLDS/ProjectLDSHUB/refs/heads/main/Anti%20AFK"))()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local CollectionService = game:GetService("CollectionService")
local LocalPlayer = Players.LocalPlayer

local Knit
local ClickService, EggService, RebirthService, TreeService, AxeService, InventoryService,
      PetService, RewardService, UpgradeService, SeasonService, AuraService, EventService,
      OrbService, FarmService, BuildingService, ClanService, LumberjackService
local DataController, EggController, TreeController, HatchingController, AuraController,
      MapController, OrbController, ItemController, SoundController, FarmController, BuildingController

local Functions, Util, Values, seasonVariables, seasonUtils, seasonTiersList

local Window, Tabs, EggDropdown, HatchAmount, LuckyEgg, AutoHatch, HideAnimationToggle,
      SelectTreesDropdown, AutoCutTreesToggle, lowercooldown, BypassStrength, AutoEquip, UpgradeAxe,
      explorerroom, ActivateLeversSection, ClaimSection, AncientWheel, ClanWheel, AncientMerchantSection, PassSection,
      Aura, EventSection, AutoCraftBuildings, autoCraftDropdown

local selectedEgg, selectedAmount, useLuckyEggs, selectedTrees, autoBreakRunning, isAutoEquipAxeEnabled,
      isAutoUpgradeEnabled, originalSelectedObjects, originalAutoCutState, treeToggleThread, petDisplayToId,
      angelQuestToggle, allowedDiceDropdown, originalEggSelection, originalHatchAmount, originalTreeSelection,
      originalAutoCutState, originalAutoHatchState, angelQuestEnabled, isAutoCollectEnabled, autoClaimThread, pickupStarsThread,
      autoClaimAllChestsThread, originalIsInGroup, supplyDropThread, isAutoSpinEnabled, isAutoSpinEnabled1, isAutoBuyEnabled,
      autoSteampunkToggles, isAutoCraftEnabled, originalAutoCraftSettings, autoCraftDropdown, autoCraftBuildingMap,
      ResourceStatusParagraph, selectedDiceItems, autoRollThread, isAuraHidden, originalAuraFuncs, isAutoBreakingMeteors

local BuildUI, getUnlockedRebirthOptions, GetBestRebirthOption, updateRebirthDropdown, performRebirth,
      TerminateThread, CreateThread, formatNumber, getLuckyIdForEggName, getTreeTypes, mapWoodToTreeWorld,
      getLumberId, getActiveTreesInGroup, updateAxeUpgradeStatus, manageTreeToggleCycle, getAllNonWoodRequirements,
      getAllFarms, getAllFarmsWithOptions, getAllFarmsForClaim, isFarmReady, getPlayerPetOptions,
      updatePetStatusParagraph, updateAngelQuestStatus, getAllAuraDice, getCurrentQuestType, findBestPotion,
      getAvailableAuraDice, setupForQuestType, storeOriginalSettings, restoreOriginalSettings, getAllSmoothies,
      getAllMagicPotItems, getAllWoods, canCraftToday, getAllMaps, getAllLumberjackItems, canAffordUpgrade,
      isLumberjackAtWork, getAllUpgradeItems, hasActiveBoost, getUnbuiltBuildings, canAffordBuilding,
      getPrerequisiteChain, getMissingResources, updateResourceStatus, mapWoodToTreeWorldForCraft, claimChestsInUnlockedMaps,
      createClaimToggle, getAllAncientMerchantItems, updateDiceStatus, storeAuraFuncs, hideAuraAnims, restoreAuraAnims

spawn(function()
    while wait(30) do 
        pcall(function() collectgarbage("collect") end)
        gcinfo()
    end
end)

BuildUI = function()

local RebirthSection = Tabs.Main:AddSection("Rebirths")

    local selectedRebirthIndex = "Max Unlocked"
    local rebirthDropdown
    local rebirthOptions = {}
    local isMaxUnlockedSelected = true -- Default to true since "Max Unlocked" is the default
    local autoRebirthRunning = false

    -- This function gets ALL rebirths for the initial dropdown population.
    local function getAllRebirthOptions()
        local Rebirths = require(ReplicatedStorage.Shared.List.Rebirths)
        local options = {}
        for index, amount in pairs(Rebirths) do
            table.insert(options, {index = index, amount = amount, display = Functions.suffixes(amount) .. " Rebirths"})
        end
        table.sort(options, function(a, b) return a.amount < b.amount end)
        return options
    end

    -- This function dynamically finds the best UNLOCKED rebirth you can do right now.
    GetBestRebirthOption = function()
        local Rebirths = require(ReplicatedStorage.Shared.List.Rebirths)
        local Upgrades = require(ReplicatedStorage.Shared.List.Upgrades)
        local buttonUpgrade = Upgrades.rebirthButtons.upgrades[DataController.data.upgrades.rebirthButtons or 0]
        local unlockedOptions = {}
        for rebirthId, rebirthAmount in pairs(Rebirths) do
            if buttonUpgrade.value >= rebirthId then
                table.insert(unlockedOptions, {id = rebirthId, amount = rebirthAmount})
            end
        end
        table.sort(unlockedOptions, function(a, b) return a.amount > b.amount end)
        return #unlockedOptions > 0 and unlockedOptions[1].id or nil
    end

    -- This function is now only called ONCE.
    updateRebirthDropdown = function()
        pcall(function()
            local options = getAllRebirthOptions() 
            rebirthOptions = options
            local dropdownValues = {"Max Unlocked"}
            for _, option in ipairs(options) do table.insert(dropdownValues, option.display) end
            if rebirthDropdown then rebirthDropdown:SetValues(dropdownValues) end
        end)
    end

    performRebirth = function()
        local rebirthIndex
        if isMaxUnlockedSelected then
            -- This is called repeatedly by the toggle, always getting the latest best option.
            rebirthIndex = GetBestRebirthOption()
        elseif selectedRebirthIndex > 0 and selectedRebirthIndex <= #rebirthOptions then
            rebirthIndex = rebirthOptions[selectedRebirthIndex].index
        end
        if rebirthIndex then
            RebirthService:rebirth(rebirthIndex)
            return true
        end
        return false
    end

    rebirthDropdown = RebirthSection:Dropdown("RebirthDropdown", {
        Title = "Select Rebirth Amount", Values = {}, Searchable = true, Default = "Max Unlocked", Multi = false,
        Callback = function(selectedValue)
            if selectedValue == "Max Unlocked" then
                isMaxUnlockedSelected = true
            else
                isMaxUnlockedSelected = false
                for i, option in ipairs(rebirthOptions) do
                    if option.display == selectedValue then selectedRebirthIndex = i; break end
                end
            end
        end
    })

    local AutoRebirth = RebirthSection:Toggle("AutoRebirth", {
        Title = "Auto Rebirth", Default = false,
        Callback = function(Value)
            autoRebirthRunning = Value
            if Value then
                task.spawn(function()
                    while autoRebirthRunning do
                        pcall(performRebirth)
                        task.wait(0.2)
                    end
                end)
            end
        end
    })

    -- CORRECTED: This task now runs only ONCE to populate the dropdown.
    task.spawn(function()
        DataController:waitForData()
        task.wait(2) -- Wait for data to be stable before the initial population.
        pcall(updateRebirthDropdown) -- Call it once and then the task ends.
    end)
    local UpgradesSection = Tabs.Main:AddSection("Player Upgrades")
    local ActiveThreads = {}

    TerminateThread = function(index)
        if ActiveThreads[index] then
            ActiveThreads[index].IsRunning = false
            ActiveThreads[index] = nil
        end
    end

    CreateThread = function(index, fn)
        local thread = {IsRunning = true, Thread = fn}
        ActiveThreads[index] = thread
        task.spawn(function() thread.Thread(thread) end)
    end

    local upgradeValues = {}
    local UpgradesModule = require(ReplicatedStorage.Shared.List.Upgrades)
    for id, data in pairs(UpgradesModule) do
        table.insert(upgradeValues, {Name = id:sub(1,1):lower()..id:sub(2), Value = id})
    end

    local upgradesDropdown = UpgradesSection:Dropdown("UpgradesDropdown", {
        Title = "Select Upgrades", Values = upgradeValues, Multi = true, Searchable = true, Default = {},
        Displayer = function(item) return item.Name end
    })

    upgradesDropdown:OnChanged(function(value) end) -- Callback for potential future use

    UpgradesSection:Toggle("AutoBuyToggle", {
        Title = "Auto Buy Upgrades", Default = false,
        Callback = function(state)
            if not state then TerminateThread("AutoBuyUpgrades"); return end
            CreateThread("AutoBuyUpgrades", function(thread)
                DataController:waitForData()
                while thread.IsRunning and task.wait(0.5) do
                    local selected = upgradesDropdown.Value
                    for upgradeData, isSelected in pairs(selected) do
                        if isSelected then
                            if not thread.IsRunning then break end
                            local id = upgradeData.Value
                            local def = UpgradesModule[id]
                            if def and not (def.requiredMap and not DataController.data.maps[def.requiredMap]) then
                                local level = (DataController.data.upgrades[id] or 0) + 1
                                local costData = def.upgrades[level]
                                if costData and costData.cost <= DataController.data.gems then
                                    if UpgradeService:upgrade(id) then task.wait(0.1) end
                                end
                            end
                        end
                    end
                end
            end)
        end
    })

    local TreeSection = Tabs.Tree:AddSection("Auto Break Trees")

    TreeSection:Paragraph("Tree",{
        Title = "Note",
        Content = "If you have auto hatch enabled, the speed in which you can break trees will massively decline. For best results, disable auto hatch while using the auto cut trees toggle.",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    getTreeTypes = function()
        local treeList = {}
        local Trees = require(ReplicatedStorage.Shared.List.Trees)

        for zoneName, zoneData in pairs(Trees) do
            if zoneName:lower() ~= "fall" and zoneData.trees and #zoneData.trees > 0 then
                local treeInfo = zoneData.trees[1]
                local hp = treeInfo.hp or 0
                local itemName = "Wood"
                
                if treeInfo and treeInfo.item then
                    local item = treeInfo.item
                    itemName = item.id or item.Name or item.name or (typeof(item.getId) == "function" and item:getId()) or (typeof(item.getName) == "function" and item:getName()) or (zoneName .. "Wood")
                    itemName = itemName:sub(1,1):upper() .. itemName:sub(2)
                end

                local displayName = zoneName:sub(1,1):upper() .. zoneName:sub(2) .. " (" .. itemName .. ")"
                table.insert(treeList, {
                    Name = displayName,
                    Value = zoneName,
                    HP = hp,
                    Wood = itemName
                })
            end
        end

        table.sort(treeList, function(a, b) return a.HP < b.HP end)
        return treeList
    end

    mapWoodToTreeWorld = function(woodName)
        if woodName:lower() == "wood" then
            return "spawn"
        end
        
        local Trees = require(ReplicatedStorage.Shared.List.Trees)
        
        for zoneName, zoneData in pairs(Trees) do
            if zoneData.trees and #zoneData.trees > 0 then
                local treeInfo = zoneData.trees[1]
                if treeInfo and treeInfo.item then
                    local item = treeInfo.item
                    local itemName = item.id or item.Name or item.name or (typeof(item.getId) == "function" and item:getId()) or (typeof(item.getName) == "function" and item:getName())
                    if itemName and itemName:lower() == woodName:lower() then return zoneName end
                end
            end
        end
        
        local woodMappings = {
            ["wood"] = "spawn",
        }
        return woodMappings[woodName:lower()] or "spawn"
    end

    getLumberId = function()
        local success, lumberId = pcall(debug.getupvalue, TreeController.autoDamageTree, 4)
        if success and type(lumberId) == "string" and #lumberId >= 32 then return lumberId end
        if TreeController._v_u_22 then return TreeController._v_u_22 end
        TreeController:getLumberId()
        task.wait(0.2)
        success, lumberId = pcall(debug.getupvalue, TreeController.autoDamageTree, 4)
        return (success and type(lumberId) == "string" and #lumberId >= 32) and lumberId or "70c6c87e76cd49409ce604d9cc0616ac"
    end

    selectedTrees = {}
    autoBreakRunning = false

    SelectTreesDropdown = TreeSection:Dropdown("SelectTrees", {
        Title = "Select Tree(s)",
        Description = "Choose which trees to automatically cut",
        Values = getTreeTypes(),
        Multi = true,
        Searchable = true,
        Default = {},
        Displayer = function(item) return item.Name end,
        Callback = function(value)
            selectedTrees = {}
            for treeType, isSelected in pairs(value) do
                if isSelected then table.insert(selectedTrees, treeType.Value) end
            end
        end
    })

    do
        local spawnTreeObject = nil
        for _, treeObject in ipairs(SelectTreesDropdown.Values) do
            if treeObject.Value == "spawn" then
                spawnTreeObject = treeObject
                break
            end
        end
        if spawnTreeObject then
            SelectTreesDropdown:SetValue({[spawnTreeObject] = true})
        end
    end

    getActiveTreesInGroup = function(groupId, data)
        local treesWithHealth = {}
        local mapsFolder = Workspace:FindFirstChild("Game") and Workspace.Game:FindFirstChild("Maps")
        if not mapsFolder then return treesWithHealth end

        local mapName
        for _, map in pairs(mapsFolder:GetChildren()) do
            if map.Name:lower() == groupId:lower() then
                mapName = map.Name
                break
            end
        end

        if not mapName then return treesWithHealth end
        local treesFolder = mapsFolder[mapName]:FindFirstChild("Trees")
        if not treesFolder then return treesWithHealth end

        for _, tree in pairs(treesFolder:GetChildren()) do
            local treeId = tree:GetAttribute("treeId")
            local hasModel = tree:FindFirstChildWhichIsA("Model") ~= nil

            if treeId and hasModel and 
            data.trees[groupId] and data.trees[groupId][treeId] and 
            data.trees[groupId][treeId].hp > 0 and 
            not data.trees[groupId][treeId].respawn then

                table.insert(treesWithHealth, {
                    treeId = treeId,
                    hp = data.trees[groupId][treeId].hp,
                    instance = tree,
                    groupId = groupId
                })
            end
        end

        table.sort(treesWithHealth, function(a, b) return a.hp < b.hp end)
        return treesWithHealth
    end

    AutoCutTreesToggle = TreeSection:Toggle("AutoCutTrees", {
        Title = "Auto Cut Trees",
        Description = "Self explanatory. Requires an axe to be equipped.",
        Default = false,
        Callback = function(Value)
            autoBreakRunning = Value

            if Value then
                local treeControllerThread = task.spawn(function()
                    if not game:IsLoaded() then game.Loaded:Wait() end

                    local function simulateClickOnClosestTree()
                        pcall(function()
                            local originalGetRay = TreeController.getRay
                            TreeController.getRay = function(self, _, _) return true end

                            local originalGetTreeFromRayResult = TreeController.getTreeFromRayResult
                            local targetTree = nil

                            TreeController.getTreeFromRayResult = function(_, _) return targetTree end

                            if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                TreeController.getRay = originalGetRay
                                TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                                return
                            end

                            local data = DataController:getData()
                            if not data or not data.trees then
                                TreeController.getRay = originalGetRay
                                TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                                return
                            end

                            local closestDistance = math.huge
                            local playerPosition = LocalPlayer.Character.HumanoidRootPart.Position

                            for _, groupId in ipairs(selectedTrees) do
                                if data.trees[groupId] then
                                    for _, tree in pairs(CollectionService:GetTagged("Tree")) do
                                        local model = tree:FindFirstChildWhichIsA("Model")
                                        if not model then continue end

                                        local treeGroupId = tree:GetAttribute("groupId")
                                        local treeId = tree:GetAttribute("treeId")

                                        if treeGroupId == groupId and treeId and 
                                        data.trees[groupId][treeId] and 
                                        data.trees[groupId][treeId].hp > 0 and
                                        not data.trees[groupId][treeId].respawn then

                                            local primaryPart = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                                            if primaryPart then
                                                local distance = (primaryPart.Position - playerPosition).Magnitude
                                                if distance < closestDistance then
                                                    closestDistance = distance
                                                    targetTree = tree
                                                end
                                            end
                                        end
                                    end
                                end
                            end

                            if not targetTree then
                                TreeController.getRay = originalGetRay
                                TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                                return
                            end

                            TreeController:sendRayFromInput(0, 0)
                            TreeController.getRay = originalGetRay
                            TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                        end)
                    end

                    while autoBreakRunning do
                        simulateClickOnClosestTree()
                        task.wait(1)
                    end
                end)

                local teleportThread = task.spawn(function()
                    if not game:IsLoaded() then game.Loaded:Wait() end

                    local lumberId = getLumberId()
                    local currentGroup, currentId, lastTeleportTime = nil, nil, 0
                    math.randomseed(os.time() + os.clock() * 1000)

                    local data = DataController:getData()
                    while not data or not data.trees do
                        task.wait(0.5)
                        data = DataController:getData()
                    end

                    local function selectRandomTreeGroup()
                        data = DataController:getData()
                        if not data or not data.trees then return nil end

                        local validGroups = {}
                        for _, groupId in ipairs(selectedTrees) do
                            if data.trees[groupId] then
                                local hasActiveTrees = false
                                for treeId, treeData in pairs(data.trees[groupId]) do
                                    if treeData.hp > 0 and not treeData.respawn then
                                        hasActiveTrees = true
                                        break
                                    end
                                end
                                if hasActiveTrees then table.insert(validGroups, groupId) end
                            end
                        end

                        return #validGroups > 0 and validGroups[math.random(1, #validGroups)] or nil
                    end

                    local function findAndTeleportToRandomTree()
                        currentGroup = selectRandomTreeGroup()
                        if not currentGroup then return false end

                        if data.trees[currentGroup] then
                            local activeTrees = getActiveTreesInGroup(currentGroup, data)
                            if #activeTrees > 0 then
                                local randomTreeIndex = math.random(1, #activeTrees)
                                currentId = activeTrees[randomTreeIndex].treeId

                                local teleportSuccess = pcall(function()
                                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                        local mapsFolder = Workspace:FindFirstChild("Game") and Workspace.Game:FindFirstChild("Maps")
                                        if mapsFolder then
                                            local mapName = nil
                                            for _, map in pairs(mapsFolder:GetChildren()) do
                                                if map.Name:lower() == currentGroup:lower() then
                                                    mapName = map.Name
                                                    break
                                                end
                                            end

                                            if mapName then
                                                local treesFolder = mapsFolder[mapName]:FindFirstChild("Trees")
                                                if treesFolder then
                                                    for _, tree in pairs(treesFolder:GetChildren()) do
                                                        if tree:GetAttribute("treeId") == currentId then
                                                            local model = tree:FindFirstChildWhichIsA("Model")
                                                            if model then
                                                                LocalPlayer.Character.HumanoidRootPart.CFrame = model:GetPivot() + Vector3.new(0, 5, 0)
                                                                lastTeleportTime = os.time()
                                                                return true
                                                            end
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    return false
                                end)

                                if teleportSuccess then
                                    return true
                                else
                                    currentGroup, currentId = nil, nil
                                    return false
                                end
                            end
                        end

                        currentGroup, currentId = nil, nil
                        return false
                    end

                    while autoBreakRunning do
                        local shouldFindNewTree = not currentGroup or not currentId
                        
                        if not shouldFindNewTree then
                            data = DataController:getData()
                            if not data or not data.trees or 
                            not data.trees[currentGroup] or 
                            not data.trees[currentGroup][currentId] or
                            data.trees[currentGroup][currentId].hp <= 0 or 
                            data.trees[currentGroup][currentId].respawn then
                                shouldFindNewTree = true
                            end
                        end

                        if shouldFindNewTree then
                            findAndTeleportToRandomTree()
                        else
                            local currentTime = os.time()
                            if (currentTime - lastTeleportTime >= 3) then
                                pcall(function()
                                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                        local mapsFolder = Workspace:FindFirstChild("Game") and Workspace.Game:FindFirstChild("Maps")
                                        if mapsFolder then
                                            local mapName = nil
                                            for _, map in pairs(mapsFolder:GetChildren()) do
                                                if map.Name:lower() == currentGroup:lower() then
                                                    mapName = map.Name
                                                    break
                                                end
                                            end

                                            if mapName then
                                                local treesFolder = mapsFolder[mapName]:FindFirstChild("Trees")
                                                if treesFolder then
                                                    for _, tree in pairs(treesFolder:GetChildren()) do
                                                        if tree:GetAttribute("treeId") == currentId then
                                                            local model = tree:FindFirstChildWhichIsA("Model")
                                                            if model then
                                                                LocalPlayer.Character.HumanoidRootPart.CFrame = model:GetPivot() + Vector3.new(0, 5, 0)
                                                                lastTeleportTime = currentTime
                                                                return
                                                            end
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end)
                            end
                        end

                        if currentGroup and currentId and 
                        data.trees[currentGroup] and 
                        data.trees[currentGroup][currentId] and
                        data.trees[currentGroup][currentId].hp > 0 and 
                        not data.trees[currentGroup][currentId].respawn then
                            TreeService.damage2:Fire(currentGroup, currentId, lumberId)
                        end

                        task.wait(0.1)
                    end
                end)

                _G.TreeCuttingThreads = {
                    treeControllerThread = treeControllerThread,
                    teleportThread = teleportThread
                }

            else
                if _G.TreeCuttingThreads then
                    for name, thread in pairs(_G.TreeCuttingThreads) do
                        if thread then task.cancel(thread) end
                    end
                    _G.TreeCuttingThreads = nil
                end

                if TreeController._currentTree then
                    TreeController:cancelAutoDamageTree()
                end
            end
        end
    })

    lowercooldown = TreeSection:Toggle("RemoveCooldown", {
        Title = "Reduce Cutting Cooldown",
        Description = "Reduces the cooldown between tree hits (about 1.5x faster). Already built in with the auto trees toggle.",
        Default = false,
        Callback = function(Value)
            if Value then
                TreeController._debounce = {}
                TreeController._debounce = setmetatable({}, {
                    __index = function() return false end,
                    __newindex = function() end
                })
            else
                TreeController._debounce = {}
            end
        end
    })

    BypassStrength = TreeSection:Toggle("BypassTreeStrength", {
        Title = "Axe Strength Bypass",
        Description = "Allows you to cut any tree regardless of your current axe strength",
        Default = false,
        Callback = function(Value)
            if Value then
                if not TreeController._originalIsStrongEnough then
                    TreeController._originalIsStrongEnough = TreeController.isStrongEnough
                end
                TreeController.isStrongEnough = function() return true end
            else
                if TreeController._originalIsStrongEnough then
                    TreeController.isStrongEnough = TreeController._originalIsStrongEnough
                end
            end
        end
    })

    isAutoEquipAxeEnabled = false
    AutoEquip = TreeSection:Toggle("AutoEquipBestAxe", {
        Title = "Auto Equip Best Axe",
        Description = "Automatically equips the best axe you own.",
        Default = false,
        Callback = function(enabled)
            isAutoEquipAxeEnabled = enabled
            if enabled then
                task.spawn(function()
                    while isAutoEquipAxeEnabled do
                        pcall(function()
                            local ExclusiveItems = require(ReplicatedStorage.Shared.List.Items.Exclusive)
                            DataController:waitForData()
                            local playerData = DataController:getData()

                            local bestAxe, bestAxeIndex, bestInventoryIndex = nil, 0, nil
                            for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                                local itemObj = Util.itemUtils.createItemFromData(itemData)
                                local itemName = itemObj:getName()

                                if itemName:lower():find("axe") and not itemName:lower():find("pickaxe") then
                                    local axeData = ExclusiveItems[itemName]
                                    if axeData and axeData.index and axeData.index > bestAxeIndex then
                                        bestAxeIndex = axeData.index
                                        bestAxe = itemObj:getRealName()
                                        bestInventoryIndex = inventoryIndex
                                    end
                                end
                            end

                            if not bestAxe then return end

                            local isAxeEquipped = playerData.isAxeEquipped

                            if not isAxeEquipped then
                                InventoryService:useItem(bestInventoryIndex)
                            else
                                local currentAxe, currentAxeIndex, currentInventoryIndex = nil, 0, nil
                                for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                                    local itemObj = Util.itemUtils.createItemFromData(itemData)
                                    if itemObj:getName():lower():find("axe") and not itemObj:getName():lower():find("pickaxe") then
                                        currentAxe = itemObj:getRealName()
                                        currentAxeIndex = itemObj:directory()[itemObj:getName()].index
                                        currentInventoryIndex = inventoryIndex
                                        break
                                    end
                                end

                                if not (currentAxeIndex == bestAxeIndex and currentInventoryIndex == bestInventoryIndex) then
                                    InventoryService:useItem(bestInventoryIndex)
                                end
                            end
                        end)

                        for i = 1, 50 do
                            if not isAutoEquipAxeEnabled then break end
                            task.wait(0.1)
                        end
                    end
                end)
            end
        end
    })

    UpgradeAxe = Tabs.Tree:AddSection("Upgrade Axe")
    
    UpgradeAxe:Button({
    Title = "Enable Recommended Settings",
    Description = "Automatically enables: Auto Equip Best Axe, Reduce Cutting Cooldown, and Axe Strength Bypass",
    Callback = function()
        AutoEquip:SetValue(true)
        lowercooldown:SetValue(true) 
        BypassStrength:SetValue(true)
    end})

    local UpgradeStatusParagraph = UpgradeAxe:Paragraph("AxeUpgradeStatus", {
        Title = "Axe Upgrade",
        Content = "Loading upgrade info...",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    updateAxeUpgradeStatus = function()
        pcall(function()
            local ExclusiveItems = require(ReplicatedStorage.Shared.List.Items.Exclusive)
            local Items = require(ReplicatedStorage.Shared.Items)
            local AxesList = require(ReplicatedStorage.Shared.List.Axes)

            DataController:waitForData()
            local playerData = DataController:getData()

            local currentAxeIndex = 0
            for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                local itemObj = Util.itemUtils.createItemFromData(itemData)
                if itemObj:getName():lower():find("axe") and not itemObj:getName():lower():find("pickaxe") then
                    currentAxeIndex = itemObj:directory()[itemObj:getName()].index
                    break
                end
            end

            if currentAxeIndex == 0 then
                UpgradeStatusParagraph:SetValue("‚ùå No axe found in inventory!")
                return
            end

            local nextAxeIndex = currentAxeIndex + 1
            local nextAxe, nextAxeName = nil, nil

            for itemName, itemData in pairs(ExclusiveItems) do
                if itemName:lower():find("axe") and not itemName:lower():find("pickaxe") then
                    if itemData.index == nextAxeIndex then
                        nextAxe = Items.exclusive(itemName)
                        nextAxeName = itemName
                        break
                    end
                end
            end

            if not nextAxe then
                UpgradeStatusParagraph:SetValue("üéâ You have the maximum axe!")
                return
            end

            local axeRequirements = AxesList[nextAxeName]
            if not axeRequirements or not axeRequirements.required then
                UpgradeStatusParagraph:SetValue("‚ùå No requirements found for next axe!")
                return
            end

            local statusLines = {}
            table.insert(statusLines, "üéØ Next: " .. nextAxe:getRealName())
            table.insert(statusLines, "")
            table.insert(statusLines, "üìã Materials Needed:")

            local canUpgrade = true

            for i, requiredItem in ipairs(axeRequirements.required) do
                local itemName = requiredItem:getName()
                local requiredAmount = requiredItem:getAmount()

                local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
                local currentAmount = currentItem and currentItem:getAmount() or 0

                local hasEnough = requiredAmount <= currentAmount
                if not hasEnough then canUpgrade = false end

                local status = hasEnough and "‚úÖ" or "‚ùå"
                local progress = string.format("%s/%s", 
                    Functions.comma(currentAmount), 
                    Functions.comma(requiredAmount))

                table.insert(statusLines, string.format("%s %s: %s", status, itemName, progress))
            end

            table.insert(statusLines, "")
            table.insert(statusLines, "üî® Status: " .. (canUpgrade and "Ready to upgrade!" or "Need more materials"))

            UpgradeStatusParagraph:SetValue(table.concat(statusLines, "\n"))
        end)
    end
    
    task.spawn(function()
        while true do
            updateAxeUpgradeStatus()
            task.wait(5)
        end
    end)
    
    originalSelectedObjects = {}
    originalAutoCutState = false
    isAutoUpgradeEnabled = false
    treeToggleThread = nil

    manageTreeToggleCycle = function()
        while isAutoUpgradeEnabled do
            if autoBreakRunning then
                AutoCutTreesToggle:SetValue(false)
            end
            task.wait(1)
            
            if not autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            end
            task.wait(0.5)
            
            if autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            end
            task.wait(1)
            
            if not autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            end
            
            task.wait(20)
        end
    end

    UpgradeAxe:Toggle("AutoUpgradeAxe", {
        Title = "Auto Upgrade Axe",
        Description = "Automatically upgrades your axe when materials are available\n\n‚ö†Ô∏è Recommended to enable:\n‚Ä¢ Axe Strength Bypass\n‚Ä¢ Auto Equip Best Axe",
        Default = false,
        Callback = function(enabled)
            if enabled then
                isAutoUpgradeEnabled = true

                originalSelectedObjects = {}
                for treeObject, isSelected in pairs(SelectTreesDropdown.Value) do
                    originalSelectedObjects[treeObject] = isSelected
                end

                originalAutoCutState = autoBreakRunning

                if treeToggleThread then task.cancel(treeToggleThread) end
                treeToggleThread = task.spawn(manageTreeToggleCycle)

                task.spawn(function()
                    while isAutoUpgradeEnabled do
                        pcall(function()
                            local ExclusiveItems = require(ReplicatedStorage.Shared.List.Items.Exclusive)
                            local Items = require(ReplicatedStorage.Shared.Items)
                            local AxesList = require(ReplicatedStorage.Shared.List.Axes)

                            DataController:waitForData()
                            local playerData = DataController:getData()

                            local currentAxeIndex = 0
                            for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                                local itemObj = Util.itemUtils.createItemFromData(itemData)
                                if itemObj:getName():lower():find("axe") and not itemObj:getName():lower():find("pickaxe") then
                                    currentAxeIndex = itemObj:directory()[itemObj:getName()].index
                                    break
                                end
                            end

                            if currentAxeIndex == 0 then return end

                            local nextAxeIndex = currentAxeIndex + 1
                            local nextAxeName = nil

                            for itemName, itemData in pairs(ExclusiveItems) do
                                if itemName:lower():find("axe") and not itemName:lower():find("pickaxe") then
                                    if itemData.index == nextAxeIndex then
                                        nextAxeName = itemName
                                        break
                                    end
                                end
                            end

                            if not nextAxeName then
                                isAutoUpgradeEnabled = false
                                return
                            end

                            local nextAxe = Items.exclusive(nextAxeName)
                            local axeRequirements = AxesList[nextAxeName]
                            if not axeRequirements or not axeRequirements.required then return end

                            local neededWoods = {}
                            local canUpgrade = true

                            for _, requiredItem in ipairs(axeRequirements.required) do
                                local itemName = requiredItem:getName()
                                local requiredAmount = requiredItem:getAmount()

                                local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
                                local currentAmount = currentItem and currentItem:getAmount() or 0

                                if currentAmount < requiredAmount then
                                    canUpgrade = false
                                    if itemName:lower():find("wood") then
                                        table.insert(neededWoods, itemName)
                                    end
                                end
                            end

                            if canUpgrade then
                                AxeService:upgradeAxe()
                                task.wait(2)
                            else
                                local neededTreeObjects = {}
                                for _, woodName in ipairs(neededWoods) do
                                    local treeWorld = mapWoodToTreeWorld(woodName)
                                    for _, treeObject in ipairs(SelectTreesDropdown.Values) do
                                        if treeObject.Value == treeWorld then
                                            neededTreeObjects[treeObject] = true
                                            break
                                        end
                                    end
                                end

                                SelectTreesDropdown:SetValue(neededTreeObjects)
                            end
                        end)
                        task.wait(5)
                    end
                end)
            else
                isAutoUpgradeEnabled = false
                
                if treeToggleThread then
                    task.cancel(treeToggleThread)
                    treeToggleThread = nil
                end
                
                SelectTreesDropdown:SetValue(originalSelectedObjects)

                if autoBreakRunning ~= originalAutoCutState then
                    AutoCutTreesToggle:SetValue(originalAutoCutState)
                end
            end
        end
    })

    getAllNonWoodRequirements = function()
        local AxesModule = require(ReplicatedStorage.Shared.List.Axes)
        local allRequirements = {}
        local requirementMap = {}
        
        for axeName, axeData in pairs(AxesModule) do
            if axeData.required then
                for _, item in ipairs(axeData.required) do
                    local amount = (item.getAmount and item:getAmount()) or item.Amount or 1
                    local itemName = (item.getName and item:getName()) or item.Name or "Unknown"

                    if not itemName:lower():find("wood") then
                        if axeName:lower():find("dungeon") and itemName:lower():find("pickaxe") then
                            itemName = "dungeonPotion"
                        elseif itemName:lower() == "dungeon" then
                            itemName = "dungeonPotions"
                        end
                        
                        if not requirementMap[itemName] or amount > requirementMap[itemName] then
                            requirementMap[itemName] = amount
                        end
                    end
                end
            end
        end
        
        for itemName, maxAmount in pairs(requirementMap) do
            table.insert(allRequirements, maxAmount .. "x " .. itemName)
        end
        
        if #allRequirements > 0 then
            return "Note you will need to own at least:\n" .. table.concat(allRequirements, ", ")
        else
            return "Note: Only wood is required for axe upgrades!"
        end
    end

    UpgradeAxe:Paragraph("NonWoodNote", {
        Title = "Additional Items",
        Content = getAllNonWoodRequirements(),
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    local BuyFarmSection = Tabs.Farm:AddSection("Buy Farms")


    getAllFarms = function()
        local options, map = {}, {}
        pcall(function()
            local FarmsList = require(ReplicatedStorage.Shared.List.Farms)
            for farmId, farmInfo in pairs(FarmsList) do
                -- Exclude farmer and other non-purchasable items
                if not farmId:lower():find("1234") and 
                not farmInfo.isNotFarm and 
                farmInfo.price and 
                farmId ~= "farmer" then  -- Exclude farmer from auto-buy
                    local name = farmInfo.name or farmId
                    table.insert(options, name)
                    map[name] = farmId
                end
            end
            
            -- Don't add farmer to the options at all
        end)
        table.sort(options)
        return options, map
    end

    local farmOptions, farmIdMap = getAllFarms()

    local AutoClaimSection = Tabs.Farm:AddSection("Auto Claim")

    getAllFarmsForClaim = function()
        local options, farmMap = {}, {}
        pcall(function()
            local FarmsList = require(ReplicatedStorage.Shared.List.Farms)
            for farmId, farmInfo in pairs(FarmsList) do
                if not farmId:lower():find("farmer") and not farmInfo.isNotFarm then
                    local name = farmInfo.name or farmId
                    table.insert(options, name)
                    farmMap[name] = farmId
                end
            end
        end)
        table.sort(options)
        return options, farmMap
    end

    local claimFarmOptions, claimFarmIdMap = getAllFarmsForClaim()

    local claimDropdown = AutoClaimSection:Dropdown("SelectFarmsToClaim", {Title = "Select Farms to Auto-Claim", Values = claimFarmOptions, Multi = true, Default = {}})
    local AutoClaimFarm = AutoClaimSection:Toggle("AutoClaimFarms", {Title = "Auto Claim Farms" , Description = "Attempts to claim selected farms every 10 seconds.", Default = false, Callback = function(s) _G.AutoClaimFarms = s end})

    -- This function is no longer needed but kept to avoid breaking other references if any.
    isFarmReady = function() return false end

    -- CORRECTED: The main loop is now properly structured.
    task.spawn(function()
        while true do
            -- Only run if the toggle is on and at least one farm is selected.
            if _G.AutoClaimFarms and next(claimDropdown.Value or {}) then
                pcall(function()
                    
                    local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
                    local FarmService = Knit.GetService("FarmService")
                    
                    -- Loop through every farm the user has selected in the UI.
                    for farmName, selected in pairs(claimDropdown.Value) do
                        if selected then
                            local farmId = claimFarmIdMap[farmName]
                            
                            if farmId then
                                FarmService:claim(farmId)
                                task.wait(0.2) -- Small wait between each remote fire
                            end
                        end
                    end
                end)
            end
            
            -- FIX: The main 10-second wait is now here, controlling the frequency of the entire cycle.
            task.wait(10) 
        end
    end)
    
    local CraftPetSection = Tabs.Pet:AddSection("Craft Pets")
    petDisplayToId = {}
    local PetStatusParagraph = CraftPetSection:AddParagraph("PetCraftStatus", { Title = "Selected Pet Status", Content = "Select a pet to see details." })
    
    getPlayerPetOptions = function()
        petDisplayToId = {}
        local petOptions, addedNames = {}, {}
        pcall(function()
            local Tiers = require(ReplicatedStorage.Shared.List.Pets.Tiers)
            local playerData = DataController:getData()
            if not (playerData and playerData.inventory and playerData.inventory.pet) then return end
            for petId, petRawData in pairs(playerData.inventory.pet) do
                local petObject = Util.itemUtils.createItemFromData(petRawData)
                if petObject then
                    local s, name = pcall(function() return petObject:getName() end)
                    if s then
                        local tierNum
                        local isShiny = (petRawData.sh == true)
                        pcall(function() tierNum = petObject:getTier() end)
                        local tierName = (tierNum and Tiers[tierNum]) and Tiers[tierNum].name or ""
                        if tierName == "Normal" then tierName = "" end
                        local nameParts = {}
                        if tierName ~= "" then table.insert(nameParts, tierName) end
                        if isShiny then table.insert(nameParts, "Shiny") end
                        table.insert(nameParts, name)
                        local displayName = table.concat(nameParts, " ")
                        if not addedNames[displayName] then
                            table.insert(petOptions, displayName)
                            petDisplayToId[displayName] = petId
                            addedNames[displayName] = true
                        end
                    end
                end
            end
        end)
        if #petOptions == 0 then return {"No pets found"} end
        table.sort(petOptions)
        return petOptions
    end

    updatePetStatusParagraph = function(selectedPets)
        if not selectedPets or next(selectedPets) == nil then PetStatusParagraph:SetContent("No pets selected."); return end
        local playerData = DataController:getData()
        if not (playerData and playerData.inventory and playerData.inventory.pet) then PetStatusParagraph:SetContent("Could not find pet inventory."); return end
        local contentLines = {}
        for displayName, isSelected in pairs(selectedPets) do
            if isSelected then
                local petId = petDisplayToId[displayName]
                if petId and playerData.inventory.pet[petId] then
                    local petObject = Util.itemUtils.createItemFromData(playerData.inventory.pet[petId])
                    if petObject then
                        local _, amount = pcall(function() return petObject:getAmount() end)
                        table.insert(contentLines, string.format("%s (Amount: %d) - ID: %s", displayName, amount or 0, petId))
                    end
                else table.insert(contentLines, string.format("%s (Amount: 0) - ID: %s", displayName, petId or "N/A")) end
            end
        end
        PetStatusParagraph:SetContent(#contentLines == 0 and "No pets selected." or table.concat(contentLines, "\n"))
    end

    local PetDropdown = CraftPetSection:AddDropdown("SelectPetToCraft", {
        Title = "Select Pet(s) to Craft", Values = getPlayerPetOptions(), Multi = true, Searchable = true, Default = {},
        Callback = function(value) updatePetStatusParagraph(value) end
    })

    CraftPetSection:AddButton({ Title = "Refresh Pet List", Callback = function() PetDropdown:SetValues(getPlayerPetOptions()); PetDropdown:SetValue({}); updatePetStatusParagraph({}) end })
    CraftPetSection:AddParagraph("CraftingNote", { Title = "Note", Content = "Crafting requires at least 5 of the same pet to create 1 of the next tier. You might need to rejoin after trying to craft a galaxy pet, and be aware that the pet needs to be released after the space update in order to craft to galaxy." })
    local CraftAmountInput = CraftPetSection:AddInput("CraftAmountInput", { Title = "Craft Amount", Default = "1", Numeric = true })

    CraftPetSection:AddButton({ Title = "Craft Specific Amount",
        Callback = function()
            local selectedPets, amount = PetDropdown.Value, tonumber(CraftAmountInput.Value) or 1
            if not next(selectedPets) then return end
            for displayName, isSelected in pairs(selectedPets) do
                if isSelected then
                    local petId = petDisplayToId[displayName]
                    if petId then pcall(function() PetService:craft({[1]=petId}, false, amount) end); task.wait(0.2) end
                end
            end
            task.wait(1); PetDropdown:SetValues(getPlayerPetOptions()); updatePetStatusParagraph(PetDropdown.Value)
        end
    })

    local CraftAllToggle = CraftPetSection:AddToggle("CraftAllToggle", { Title = "Craft All (Selected)", Default = false })
    CraftAllToggle:OnChanged(function()
        if CraftAllToggle.Value then
            task.spawn(function()
                while CraftAllToggle.Value do
                    local selectedPets, crafted = PetDropdown.Value, false
                    if next(selectedPets) then
                        for displayName, isSelected in pairs(selectedPets) do
                            if isSelected and CraftAllToggle.Value then
                                local petId = petDisplayToId[displayName]
                                if petId then pcall(function() PetService:craft({[1]=petId}, true, 1) end); crafted=true; task.wait(0.5) end
                            end
                        end
                    end
                    if crafted then task.wait(1); PetDropdown:SetValues(getPlayerPetOptions()) end
                    task.wait(1)
                end
            end)
        end
    end)

    task.spawn(function() while task.wait(3) do if PetDropdown and PetDropdown.Value and next(PetDropdown.Value) then pcall(updatePetStatusParagraph, PetDropdown.Value) end end end)    
        
    local MapQuestSection = Tabs.Quest:AddSection("Map Quests")

    local MapQuestStatusParagraph = MapQuestSection:Paragraph("MapQuestStatus", {
        Title = "Map Quest Progress",
        Content = "Loading map quest status...",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    local updateMapQuestStatus = function()
        pcall(function()
            local Maps = require(ReplicatedStorage.Shared.List.Maps)
            DataController:waitForData()
            local playerData = DataController:getData()
            
            if not playerData then
                MapQuestStatusParagraph:SetValue("‚ùå Could not get player data")
                return
            end
            
            -- Find highest map number
            local highestMap = 0
            if playerData.maps then
                for mapNumber, _ in pairs(playerData.maps) do
                    if tonumber(mapNumber) and tonumber(mapNumber) > highestMap then
                        highestMap = tonumber(mapNumber)
                    end
                end
            end
            
            -- Next map to unlock
            local nextMapNumber = highestMap + 1
            local nextMap = Maps[nextMapNumber]
            
            local statusLines = {}
            table.insert(statusLines, string.format("üèÜ Best Map Owned: %d", highestMap))
            
            if nextMap then
                table.insert(statusLines, string.format("üéØ Next Map: Map %d - %s", nextMapNumber, nextMap.name))
                table.insert(statusLines, "")
                
                if nextMap.quests then
                    table.insert(statusLines, "üìã Quest Progress:")
                    
                    for questIndex, questData in pairs(nextMap.quests) do
                        local questType = questData.quest
                        local required = questData.amount
                        local questName = questData.name
                        
                        -- Get progress from mapQuests
                        local currentProgress = playerData.mapQuests[questIndex] or 0
                        
                        -- Cap progress at required amount for display
                        local displayProgress = math.min(currentProgress, required)
                        
                        local isCompleted = currentProgress >= required
                        local status = isCompleted and "‚úÖ" or "‚ùå"
                        local percentage = math.floor((displayProgress / required) * 100)
                        
                        -- Show quest info
                        local displayText = questType
                        if questName then
                            displayText = questType .. " (" .. questName .. ")"
                        end
                        
                        table.insert(statusLines, string.format("%s %s", status, displayText))
                        table.insert(statusLines, string.format("   %s/%s (%d%%)", 
                            Functions.suffixes(displayProgress),
                            Functions.suffixes(required),
                            percentage
                        ))
                    end
                end
            else
                table.insert(statusLines, "üéâ ALL MAPS UNLOCKED!")
            end
            
            MapQuestStatusParagraph:SetValue(table.concat(statusLines, "\n"))
        end)
    end

 
    -- Update map quest status every 5 seconds
    task.spawn(function()
        while true do
            updateMapQuestStatus()
            task.wait(5)
        end
    end)

    -- Toggle in GUI
    MapQuestSection:Toggle("AutoCompleteMapQuest", {
        Title = "Auto Complete Map Quest",
        Description = "Automatically completes map quests and unlocks walls sequentially.",
        Default = false,
        Callback = function(enabled)
            task.spawn(function()
                _G.MapQuestEnabled = enabled
                
                -- Store original states when enabling
                local originalStates = {
                    autoRebirthEnabled = AutoRebirth.Value,
                    selectedRebirthValue = rebirthDropdown.Value,
                    selectedEggValue = EggDropdown.Value,
                    selectedAmountValue = HatchAmount.Value,
                    craftAllToggleState = CraftAllToggle.Value,
                    selectedFarmsForClaim = claimDropdown.Value or {},
                    autoClaimFarmsEnabled = AutoClaimFarm.Value,
                    selectedTreesValue = SelectTreesDropdown.Value,
                    autoCutTreesEnabled = AutoCutTreesToggle.Value,
                    selectedPetsValue = PetDropdown.Value,
                    autoBuyFarmsEnabled = BuyFarm.Value,
                    selectedFarmsToBuy = farmDropdown.Value or {},
                    AutoCraftBuildings = AutoCraftBuildings.Value,
                    autoCraftDropdown = autoCraftDropdown.Value
                }
                
                local function restoreOriginalStates()
                    pcall(function()
                        AutoClick:SetValue(originalStates.autoClickEnabled)
                        AutoRebirth:SetValue(originalStates.autoRebirthEnabled)
                        rebirthDropdown:SetValue(originalStates.selectedRebirthValue)
                        EggDropdown:SetValue(originalStates.selectedEggValue)
                        farmDropdown:SetValue(originalStates.selectedFarmsToBuy)
                        HatchAmount:SetValue(originalStates.selectedAmountValue)
                        AutoHatch:SetValue(originalStates.autoHatchEnabled)
                        CraftAllToggle:SetValue(originalStates.craftAllToggleState)
                        claimDropdown:SetValue(originalStates.selectedFarmsForClaim)
                        AutoClaimFarm:SetValue(originalStates.autoClaimFarmsEnabled)
                        SelectTreesDropdown:SetValue(originalStates.selectedTreesValue)
                        AutoCutTreesToggle:SetValue(originalStates.autoCutTreesEnabled)
                        BuyFarm:SetValue(originalStates.autoBuyFarmsEnabled)
                        PetDropdown:SetValue(originalStates.selectedPetsValue)
                        AutoCraftBuildings:SetValue(originalStates.AutoCraftBuildings)
                        autoCraftDropdown:SetValue(originalStates.autoCraftDropdown)
                    end)
                end
                
                if enabled then
                    if AutoClick and not AutoClick.Value then
                        AutoClick:SetValue(true)
                    end

                    task.spawn(function()
                        while _G.MapQuestEnabled do
                            local success = pcall(function()
                                if not _G.MapQuestEnabled then return end
                                
                                local Maps = require(ReplicatedStorage.Shared.List.Maps)
                                local playerData = DataController:getData()
                                
                                if not playerData then return end
                                
                                AutoHatch:SetValue(false)
                                AutoRebirth:SetValue(false)
                                CraftAllToggle:SetValue(false)
                                AutoClaimFarm:SetValue(false)
                                AutoCutTreesToggle:SetValue(false)
                                BuyFarm:SetValue(false)

                                local highestMap = 0
                                if playerData.maps then
                                    for mapNumber, _ in pairs(playerData.maps) do
                                        if tonumber(mapNumber) and tonumber(mapNumber) > highestMap then
                                            highestMap = tonumber(mapNumber)
                                        end
                                    end
                                end
                                
                                local nextMapNumber = highestMap + 1
                                local nextMap = Maps[nextMapNumber]
                                
                                local allQuestsCompleted = true
                                
                                if nextMap and nextMap.quests then
                                    for questIndex, questData in pairs(nextMap.quests) do
                                        if not _G.MapQuestEnabled then return end
                                        
                                        local currentProgress = playerData.mapQuests[questIndex] or 0
                                        if currentProgress >= questData.amount then
                                            continue
                                        else
                                            allQuestsCompleted = false
                                        end
                                        
                                        -- From here, we are only processing the CURRENT UNFINISHED quest
                                        local questType = questData.quest
                                        local required = questData.amount
                                        local questName = questData.name

                                        if questType == "rebirths" then
                                            local currentRebirths = playerData.rebirths or 0
                                            local rebirthsNeeded = required - currentRebirths

                                            if rebirthsNeeded > 1e98 then -- 1DTG threshold (adjust if needed)
                                                -- Equip fixed 150B rebirths
                                                for _, option in ipairs(rebirthOptions) do
                                                    if option.amount == 150e9 then
                                                        rebirthDropdown:SetValue(option.display)
                                                        break
                                                    end
                                                end

                                                AutoRebirth:SetValue(true)

                                                -- Fire the server request every 3 seconds
                                                task.spawn(function()
                                                    local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
                                                    local MapService = Knit.GetService("MapService")
                                                    while _G.MapQuestEnabled and rebirthsNeeded > 1e12 do
                                                        pcall(function()
                                                            MapService:purchaseSpaceWorld()
                                                        end)
                                                        task.wait(3)
                                                    end
                                                end)

                                            else
                                                -- Normal rebirth handling (existing logic)
                                                local bestOptionDisplay = nil
                                                if rebirthsNeeded > 0 then
                                                    for _, option in ipairs(rebirthOptions) do
                                                        if option.amount >= rebirthsNeeded then
                                                            bestOptionDisplay = option.display
                                                            break
                                                        end
                                                    end
                                                end
                                                if bestOptionDisplay then
                                                    rebirthDropdown:SetValue(bestOptionDisplay)
                                                else
                                                    rebirthDropdown:SetValue("Max Unlocked")
                                                end
                                                AutoRebirth:SetValue(true)
                                            end 

                                        elseif questType == "openEgg" and questName then
                                            local targetEggName = questName
                                            for _, eggOption in ipairs(eggOptions) do
                                                if eggOption:lower():find(targetEggName:lower()) then
                                                    EggDropdown:SetValue(eggOption)
                                                    break
                                                end
                                            end
                                            HatchAmount:SetValue("Max")
                                            AutoHatch:SetValue(true)

                                        elseif questType == "craftAnyGalaxyPets" then
                                            local previousMapNumber = nextMapNumber - 1
                                            local previousMap = Maps[previousMapNumber]
                                            local previousWorldEggName = (previousMap and previousMap.name) or nextMap.name
                                            
                                            for _, eggOption in ipairs(eggOptions) do
                                                if eggOption:lower():find(previousWorldEggName:lower()) then
                                                    EggDropdown:SetValue(eggOption)
                                                    break
                                                end
                                            end
                                            
                                            HatchAmount:SetValue("Max")
                                            AutoHatch:SetValue(true)
                                            
                                            task.wait(2)
                                            PetDropdown:SetValues(getPlayerPetOptions())
                                            local playerPetOptions = getPlayerPetOptions()
                                            local galaxyCraftablePets = {}
                                            
                                            local Eggs = require(ReplicatedStorage.Shared.List.Pets.Eggs)
                                            local previousEggData = Eggs[previousWorldEggName]
                                            local previousWorldPetNames = {}
                                            if previousEggData and previousEggData.pets then
                                                for petName, _ in pairs(previousEggData.pets) do table.insert(previousWorldPetNames, petName) end
                                            end
                                            
                                            for _, displayName in ipairs(playerPetOptions) do
                                                for _, worldPetName in ipairs(previousWorldPetNames) do
                                                    if displayName:find(worldPetName) then
                                                        galaxyCraftablePets[displayName] = true
                                                        break
                                                    end
                                                end
                                            end

                                            local toxicPetNames = {}
                                            if playerData.maps then
                                                for mapNumber, _ in pairs(playerData.maps) do
                                                    local mapNum = tonumber(mapNumber)
                                                    if mapNum and mapNum >= 17 then
                                                        local mapData = Maps[mapNum]
                                                        if mapData and mapData.name then
                                                            local worldEggData = Eggs[mapData.name]
                                                            if worldEggData and worldEggData.pets then
                                                                for petName, chance in pairs(worldEggData.pets) do
                                                                    if chance > 0.01 then table.insert(toxicPetNames, petName) end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end

                                            for _, displayName in ipairs(playerPetOptions) do
                                                for _, toxicPetName in ipairs(toxicPetNames) do
                                                    if displayName:find("Toxic") and displayName:find(toxicPetName) then
                                                        galaxyCraftablePets[displayName] = true
                                                        break
                                                    end
                                                end
                                            end
                                            
                                            if next(galaxyCraftablePets) and PetDropdown then
                                                PetDropdown:SetValue(galaxyCraftablePets)
                                                CraftAllToggle:SetValue(true)
                                            end
                                            
                                        elseif questType == "hatchPet" and questName then
                                            local previousMapNumber = nextMapNumber - 1
                                            local previousMap = Maps[previousMapNumber]
                                            local worldName = (previousMap and previousMap.name) or "Spawn"
                                            
                                            for _, eggOption in ipairs(eggOptions) do
                                                if eggOption:lower():find(worldName:lower()) then
                                                    EggDropdown:SetValue(eggOption)
                                                    break
                                                end
                                            end
                                            
                                            HatchAmount:SetValue("Max")
                                            AutoHatch:SetValue(true)
                
                                        elseif questType == "useAuraDice" then
                                            local bestDiceId, maxAmount = nil, 0
                                            if playerData.inventory and playerData.inventory.auraDice then
                                                for itemId, itemData in pairs(playerData.inventory.auraDice) do
                                                    if (itemData.am or 0) > maxAmount then
                                                        maxAmount = itemData.am
                                                        bestDiceId = itemData.nm or itemId
                                                    end
                                                end
                                            end
                                            if bestDiceId and maxAmount > 0 then
                                                pcall(function() AuraService:roll(bestDiceId) end)
                                                task.wait(2)
                                            end
                                            
                                        elseif questType == "collectFruits" then
                                            rebirthDropdown:SetValue("Max Unlocked")
                                            AutoRebirth:SetValue(true)
                                            
                                            local allFarms = {}
                                            for _, farmName in ipairs(farmOptions) do allFarms[farmName] = true end
                                            farmDropdown:SetValue(allFarms)
                                            BuyFarm:SetValue(true)
                                            
                                            local allClaimFarms = {}
                                            for _, farmName in ipairs(claimFarmOptions) do allClaimFarms[farmName] = true end
                                            claimDropdown:SetValue(allClaimFarms)
                                            AutoClaimFarm:SetValue(true)
                                        
                                        elseif questType == "building" and questName and (questName:lower():find("bridge") or questName:lower():find("wooden")) then
                                                
                                                local bridgeOptionName = "Wooden Bridge"
                                                local foundOption = false
                                                for _, option in ipairs(autoCraftDropdown.Values) do
                                                    if option == bridgeOptionName then
                                                        foundOption = true
                                                        break
                                                    end
                                                end

                                                if foundOption then
                                                    autoCraftDropdown:SetValue({[bridgeOptionName] = true})
                                                    AutoCraftBuildings:SetValue(true)
                                                else
                                                end
                                                
                                        elseif questType == "usePotions" then
                                            local bestPotionId, maxAmount = nil, 0
                                            if playerData.inventory and playerData.inventory.potion then
                                                for itemId, itemData in pairs(playerData.inventory.potion) do
                                                    if (itemData.am or 0) > maxAmount and not (itemData.nm or ""):lower():find("mega") then
                                                        maxAmount = itemData.am
                                                        bestPotionId = itemId
                                                    end
                                                end
                                            end
                                            if bestPotionId and maxAmount > 0 then
                                                local potionsNeeded = math.min(required - currentProgress, maxAmount)
                                                if potionsNeeded > 0 then
                                                    pcall(function() Knit.GetService("InventoryService"):useItem(bestPotionId, {use = potionsNeeded}) end)
                                                    task.wait(2)
                                                end
                                            end
                                            
                                        elseif questType == "useMegaPotions" then
                                            local bestMegaPotionId, maxAmount = nil, 0
                                            if playerData.inventory and playerData.inventory.potion then
                                                for itemId, itemData in pairs(playerData.inventory.potion) do
                                                    if (itemData.am or 0) > maxAmount and (itemData.nm or ""):lower():find("mega") then
                                                        maxAmount = itemData.am
                                                        bestMegaPotionId = itemId
                                                    end
                                                end
                                            end
                                            if bestMegaPotionId and maxAmount > 0 then
                                                local megaPotionsNeeded = math.min(required - currentProgress, maxAmount)
                                                if megaPotionsNeeded > 0 then
                                                    pcall(function() Knit.GetService("InventoryService"):useItem(bestMegaPotionId, {use = megaPotionsNeeded}) end)
                                                    task.wait(2)
                                                end
                                            end
                                        end
                                        break
                                    end
                                else
                                    allQuestsCompleted = true
                                end
                                
                                if allQuestsCompleted then
                                    restoreOriginalStates()
                                    _G.MapQuestEnabled = false
                                    return
                                end
                            end)
                            
                            if not success then end
                            if not _G.MapQuestEnabled then break end
                            task.wait(3)
                        end
                        
                        restoreOriginalStates()
                    end)
                else
                    _G.MapQuestEnabled = false
                    restoreOriginalStates()
                end
            end)
        end
    })
    
    local MapQuestNone = MapQuestSection:Paragraph("MapQuestNone", {
        Title = "Note",
        Content = "For the build quest in the kingdom world, the bridge will be built, but this script won't source the resources. Make sure you have at least 3 ancient ticks, 3 fire aura dice, 5 grapes, and 5 apples.",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    local AngelQuestSection = Tabs.Quest:AddSection("Angel Quests")

    angelQuestEnabled = false

    local AngelQuestStatusParagraph = AngelQuestSection:Paragraph("AngelQuestStatus", {
        Title = "Angel Quest Status",
        Content = "Loading quest status...",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    updateAngelQuestStatus = function()
        pcall(function()
            local AngelQuestsList = require(ReplicatedStorage.Shared.List.AngelQuests)
            DataController:waitForData()
            local playerData = DataController:getData()
            
            local currentTier = playerData.angelQuestTier or 1
            local currentProgress = playerData.angelQuestProgress or 0
            local totalTiers = #AngelQuestsList
            
            if currentTier > totalTiers then
                AngelQuestStatusParagraph:SetValue(string.format("üéâ Completed all %d Angel Quests!", totalTiers))
            else
                local questInfo = AngelQuestsList[currentTier]
                if questInfo then
                    local requiredAmount = questInfo.quest.amount
                    local formattedQuestText = questInfo.text:format(requiredAmount)
                    
                    local statusText = string.format(
                        "üìã Tier: %d/%d\nüéØ Quest: %s\nüìä Progress: %d/%d",
                        currentTier, totalTiers, formattedQuestText, currentProgress, requiredAmount
                    )
                    AngelQuestStatusParagraph:SetValue(statusText)
                else
                    AngelQuestStatusParagraph:SetValue(string.format("‚ùå Unable to read quest for Tier %d", currentTier))
                end
            end
        end)
    end

    getAllAuraDice = function()
        local options, diceMap = {}, {}
        pcall(function()
            local AuraDices = require(ReplicatedStorage.Shared.List.Items.AuraDices)
            for diceId, diceData in pairs(AuraDices) do
                local displayName = diceData.name
                table.insert(options, displayName)
                diceMap[displayName] = diceId
            end
        end)
        table.sort(options)
        return options, diceMap
    end

    local diceOptions, diceIdMap = getAllAuraDice()

    allowedDiceDropdown = AngelQuestSection:Dropdown("AllowedDice", {
        Title = "Allowed Dice",
        Description = "Select which dice to use for aura quests (if none selected, uses any owned dice)",
        Values = diceOptions,
        Multi = true,
        Searchable = true,
        Default = {}
    })


    getCurrentQuestType = function()
        local success, result = pcall(function()
            local AngelQuestsList = require(ReplicatedStorage.Shared.List.AngelQuests)
            DataController:waitForData()
            local playerData = DataController:getData()
            
            if not playerData then 
                return nil 
            end
            
            local currentTier = playerData.angelQuestTier or 1
            
            if currentTier <= #AngelQuestsList then
                local questData = AngelQuestsList[currentTier]
                return questData and questData.quest or nil
            else
                return nil
            end
        end)
        
        if success then
            return result
        else
            return nil
        end
    end


    findBestPotion = function()
        local playerData = DataController:getData()
        if not playerData or not playerData.inventory or not playerData.inventory.exclusive then
            return nil
        end
        
        local bestPotion = nil
        local highestAmount = 0
        
        for itemId, itemData in pairs(playerData.inventory.exclusive) do
            if itemData.nm and itemData.nm:lower():find("potion") and itemData.am and itemData.am > highestAmount then
                highestAmount = itemData.am
                bestPotion = itemId
            end
        end
        
        return bestPotion
    end

    getAvailableAuraDice = function()
        local playerData = DataController:getData()
        if not playerData then
            return {}
        end
        
        local selectedDice = allowedDiceDropdown.Value or {}
        local availableDice = {}
        
        if next(selectedDice) == nil then
            local AuraDices = require(ReplicatedStorage.Shared.List.Items.AuraDices)
            
            for diceId, diceData in pairs(AuraDices) do
                local item = Util.itemUtils.getItemFromName(playerData, diceId)
                if item and item:getAmount() > 0 then
                    table.insert(availableDice, diceId)
                end
            end
        else
            for diceName, isSelected in pairs(selectedDice) do
                if isSelected then
                    local diceId = diceIdMap[diceName]
                    local item = Util.itemUtils.getItemFromName(playerData, diceId)
                    if item and item:getAmount() > 0 then
                        table.insert(availableDice, diceId)
                    end
                end
            end
        end
        
        return availableDice
    end

    setupForQuestType = function(questType)
        if not questType then 
            return 
        end
        
        local questName = questType.quest
        
        if questName:lower():find("egg") or questName:lower():find("hatch") then
            
            local heavenEggFound = false
            
            for i, eggOption in ipairs(eggOptions) do
                if eggOption:lower():find("heaven") then
                    EggDropdown:SetValue(eggOption)
                    selectedEgg = displayToEggName[eggOption] or "Heaven"
                    heavenEggFound = true
                    break
                end
            end
            
            if not heavenEggFound then
            end
            
            HatchAmount:SetValue("Max")
            selectedAmount = hatchAmounts["Max"]
            
            if not _G.AutoHatchEnabled then
                AutoHatch:SetValue(true)
            else
            end
        end
        
        if questName == "destroyTree" then
            AutoEquip:SetValue(true)
            local neededTrees = {}
            for _, treeObject in ipairs(SelectTreesDropdown.Values) do
                local treeName = treeObject.Value:lower()
                if treeName == "spawn" or treeName == "desert" or treeName == "nuclear" then
                    neededTrees[treeObject] = true
                end
            end
            SelectTreesDropdown:SetValue(neededTrees)
            selectedTrees = {}
            for treeType, isSelected in pairs(neededTrees) do
                if isSelected then table.insert(selectedTrees, treeType.Value) end
            end
            if not autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            else
            end
        end
        
        if questName == "craftRing" then
            task.spawn(function()
                while angelQuestEnabled do
                    pcall(function()
                        local Knit = require(ReplicatedStorage.Packages.Knit)
                        Knit.GetService("RingService"):craftRing("basicRing", 1)
                    end)
                    task.wait(5)
                end
            end)
        end
        
        if questName == "usePotions" then
            task.spawn(function()
                while angelQuestEnabled do
                    local potionId = findBestPotion()
                    if potionId then
                        pcall(function()
                            local Knit = require(ReplicatedStorage.Packages.Knit)
                            Knit.GetService("InventoryService"):useItem(potionId, {use = 1})
                        end)
                    else
                    end
                    task.wait(2)
                end
            end)
        end

        if questName == "useAuraDice" or questName == "rollOneInAura" then
            task.spawn(function()
                while angelQuestEnabled do
                    local currentQuest = getCurrentQuestType()
                    if not currentQuest or (currentQuest.quest ~= "useAuraDice" and currentQuest.quest ~= "rollOneInAura") then
                        break 
                    end
                    
                    local availableDice = getAvailableAuraDice()
                    if #availableDice > 0 then
                        local randomDice = availableDice[math.random(1, #availableDice)]
                        pcall(function()
                            AuraService:roll(randomDice)
                        end)
                    else
                    end
                    task.wait(2)
                end
            end)
        end
    end

    storeOriginalSettings = function()
        originalEggSelection = selectedEgg
        originalHatchAmount = selectedAmount
        
        originalAutoHatchState = AutoHatch.Value

        originalTreeSelection = {}
        for treeObject, isSelected in pairs(SelectTreesDropdown.Value) do
            originalTreeSelection[treeObject] = isSelected
        end
        originalAutoCutState = autoBreakRunning
    end

    restoreOriginalSettings = function()
        if originalEggSelection then
            for _, eggOption in ipairs(eggOptions) do
                if eggOption:find(originalEggSelection) then
                    EggDropdown:SetValue(eggOption)
                    selectedEgg = displayToEggName[eggOption] or originalEggSelection
                    break
                end
            end
        end
        
        if originalHatchAmount then
            local amountText = originalHatchAmount == 1 and "1x" or originalHatchAmount == 3 and "3x" or "Max"
            HatchAmount:SetValue(amountText)
            selectedAmount = originalHatchAmount
        end
        
        if not originalAutoHatchState and _G.AutoHatchEnabled then
            AutoHatch:SetValue(false)
        end
        
        if originalTreeSelection then
            SelectTreesDropdown:SetValue(originalTreeSelection)
            
            selectedTrees = {}
            for treeType, isSelected in pairs(originalTreeSelection) do
                if isSelected then table.insert(selectedTrees, treeType.Value) end
            end
        end
        
        if autoBreakRunning ~= originalAutoCutState then
            AutoCutTreesToggle:SetValue(originalAutoCutState)
        end
    end

    angelQuestToggle = AngelQuestSection:Toggle("AutoCompleteAngelQuest", {
        Title = "Auto Complete Angel Quest",
        Description = "Automatically completes the angel quests.",
        Default = false,
        Callback = function(enabled)
            task.spawn(function()
                angelQuestEnabled = enabled
                
                if enabled then
                    storeOriginalSettings()
                    
                    task.spawn(function()
                        task.wait(2)
                        
                        while angelQuestEnabled do
                            local currentQuest = getCurrentQuestType()
                            
                            if currentQuest then
                                setupForQuestType(currentQuest)
                            else
                            end
                            
                            pcall(function()
                                local AngelQuestsList = require(ReplicatedStorage.Shared.List.AngelQuests)
                                DataController:waitForData()
                                local playerData = DataController:getData()
                                
                                local currentTier = playerData.angelQuestTier or 1
                                local currentProgress = playerData.angelQuestProgress or 0
                                
                                if currentTier <= #AngelQuestsList then
                                    local questInfo = AngelQuestsList[currentTier]
                                    if questInfo then
                                        local requiredAmount = questInfo.quest.amount
                                        
                                        if currentProgress >= requiredAmount then
                                            local Knit = require(ReplicatedStorage.Packages.Knit)
                                            Knit.GetService("QuestService"):claimAngelQuest()
                                            restoreOriginalSettings()
                                            task.wait(2)
                                        end
                                    end
                                end
                            end)
                            
                            updateAngelQuestStatus()
                            task.wait(1)
                        end
                    end)
                else
                    restoreOriginalSettings()
                end
            end)
        end
        })

    task.spawn(function()
        while true do
            updateAngelQuestStatus()
            task.wait(5)
        end
    end)


    ClaimSection = Tabs.Claim:AddSection("Claim/Collect")

    local isAutoCollectEnabled = false
    local autoCollectThread = nil

    local function claimChestsInUnlockedMaps()
        if not game:IsLoaded() then game.Loaded:Wait() end
        task.wait(1)

        local Knit = require(ReplicatedStorage.Packages.Knit)
        local Maps = require(ReplicatedStorage.Shared.List.Maps)

        local DataController
        repeat
            DataController = Knit.GetController("DataController")
            task.wait()
        until DataController

        local function getUnlockedZones()
            local playerData = DataController:getData()
            if not playerData or not playerData.maps then return {} end
            local unlockedMapIds = playerData.maps
            local unlockedZones = {}
            for mapId, mapData in pairs(Maps) do
                if mapData.alwaysUnlocked or table.find(unlockedMapIds, mapId) then
                    mapData.id = mapId
                    table.insert(unlockedZones, mapData)
                end
            end
            table.sort(unlockedZones, function(a, b) return a.id < b.id end)
            return unlockedZones
        end

        local function formatZoneName(name)
            return (name:gsub("%s+", ""))
        end

        local function firePrompt(prompt)
            if prompt and prompt:IsA("ProximityPrompt") and prompt.Enabled then
                fireproximityprompt(prompt, math.huge)
            end
        end

        local function getZonePrompts(chestFolder)
            local prompts = {}
            for _, chest in ipairs(chestFolder:GetChildren()) do
                local touch = chest:FindFirstChild("Touch")
                if touch then
                    local prompt = touch:FindFirstChildOfClass("ProximityPrompt")
                    if prompt and prompt.Enabled then
                        table.insert(prompts, prompt)
                    end
                end
            end
            return prompts
        end

        local function beginChestCollection()
            local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            local originalCFrame = humanoidRootPart.CFrame

            local unlockedZones = getUnlockedZones()
            if #unlockedZones == 0 then return end

            for _, zoneData in ipairs(unlockedZones) do
                if not isAutoCollectEnabled then break end 
                if not zoneData.cframe then continue end

                local zoneName = formatZoneName(zoneData.name)
                local mapFolder = Workspace:FindFirstChild("Game") and Workspace.Game.Maps:FindFirstChild(zoneName)
                if not mapFolder then continue end
                local chestFolder = mapFolder:FindFirstChild("MiniChests")
                if not chestFolder then continue end

                humanoidRootPart:PivotTo(zoneData.cframe)
                task.wait(2)

                local lastCount = 0
                local sameCountDuration = 0
                local noPromptCount = 0

                while isAutoCollectEnabled do
                    local prompts = getZonePrompts(chestFolder)
                    local currentCount = #prompts

                    if currentCount == lastCount then
                        sameCountDuration += 1
                    else
                        sameCountDuration = 0
                    end
                    lastCount = currentCount

                    if sameCountDuration >= 10 then
                        break
                    end

                    if #prompts == 0 then
                        noPromptCount += 1
                        if noPromptCount >= 3 then
                            break
                        end
                    else
                        noPromptCount = 0
                        for _, prompt in ipairs(prompts) do
                            if not isAutoCollectEnabled then break end
                            firePrompt(prompt)
                            task.wait(0.25)
                        end
                    end
                    task.wait(1)
                end

                task.wait(1)
            end

            humanoidRootPart:PivotTo(originalCFrame)
        end

        pcall(beginChestCollection)
    end

    ClaimSection:Toggle("AutoPickUp", { Title = "Auto Pick Up", Default = false,
        Callback = function(enabled)
            _G.AutoPickUpEnabled = enabled
            if _G.AutoPickUpThread then task.cancel(_G.AutoPickUpThread); _G.AutoPickUpThread = nil end
            if enabled then
                _G.AutoPickUpThread = task.spawn(function()
                    local orbsFolder = Workspace:FindFirstChild("Debris") and Workspace.Debris:FindFirstChild("Orbs")
                    if not orbsFolder then return end
                    while _G.AutoPickUpEnabled and task.wait(0.2) do
                        local character, hrp = LocalPlayer.Character, nil
                        if character and character:FindFirstChild("HumanoidRootPart") then hrp = character.HumanoidRootPart else continue end
                        local orbsToCollect = {}
                        for _, orb in ipairs(orbsFolder:GetChildren()) do
                            if orb:IsA("BasePart") then
                                orb:SetAttribute("canCollect", true); orb.Anchored = true
                                if (orb.Position - hrp.Position).Magnitude <= math.huge then
                                    table.insert(orbsToCollect, orb.Name)
                                    local attachment = hrp:FindFirstChild("_orbAttachment" .. orb.Name); if attachment then attachment:Destroy() end
                                end
                            end
                        end
                        if #orbsToCollect > 0 then
                            pcall(function() OrbService.collectOrbs:Fire(orbsToCollect) end)
                            for _, orbName in ipairs(orbsToCollect) do local orb = orbsFolder:FindFirstChild(orbName); if orb then orb:Destroy() end end
                        end
                    end
                end)
            end
        end
    })

    pickupStarsThread = nil
    ClaimSection:Toggle("PickupStars", { Title = "Pickup Stars",
        Callback = function(enabled)
            if pickupStarsThread then task.cancel(pickupStarsThread); pickupStarsThread = nil end
            if enabled then
                pickupStarsThread = task.spawn(function()
                    while enabled do
                        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        local debris = Workspace:FindFirstChild("Debris")
                        if hrp and debris then
                            for _, starModel in ipairs(debris:GetChildren()) do
                                if starModel.Name == "FallingStar" then
                                    local starCore = starModel.PrimaryPart
                                    local hideFolder = starCore and starCore:FindFirstChild("hideAfterLanding")
                                    if hideFolder then
                                        local isStillFalling = false
                                        for _, particle in ipairs(hideFolder:GetChildren()) do
                                            if particle:IsA("ParticleEmitter") and particle.Enabled == true then
                                                isStillFalling = true
                                                break
                                            end
                                        end
                                        if not isStillFalling then
                                            pcall(firetouchinterest, hrp, starCore, 0)
                                            pcall(firetouchinterest, hrp, starCore, 1)
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        task.wait(0.1)
                    end
                end)
            end
        end
    })


    local autoClaimThreads = {}
    createClaimToggle = function(id, title, claimFunc)
        ClaimSection:Toggle("AutoClaim"..id, { Title = title, Default = false,
            Callback = function(enabled)
                if autoClaimThreads[id] then task.cancel(autoClaimThreads[id]); autoClaimThreads[id]=nil end
                if enabled then autoClaimThreads[id] = task.spawn(function() while enabled do pcall(claimFunc); task.wait(5) end end) end
            end
        })
    end

    createClaimToggle("Achievements", "Auto Claim Achievements", function()
        local Achievements = require(ReplicatedStorage.Shared.List.Achievements)
        DataController:waitForData()
        local playerData = DataController:getData()
        for achievementKey, achievementData in pairs(Achievements) do
            local currentLevel = 1
            for claimedId, _ in pairs(playerData.claimedAchievements) do if claimedId:find(achievementKey) then currentLevel = currentLevel + 1 end end
            if #achievementData.list >= currentLevel and achievementData.list[currentLevel].amount <= achievementData.getValue(playerData) then
                RewardService:claimAchievement(achievementKey); task.wait(1)
            end
        end
    end)

    local autoClaimPlaytimeEnabled = false
    ClaimSection:Toggle("AutoClaimPlaytime", {
        Title = "Auto Claim Playtime Rewards",
        Default = false,
        Callback = function(enabled)
            autoClaimPlaytimeEnabled = enabled

            if autoClaimPlaytimeThread then
                task.cancel(autoClaimPlaytimeThread)
                autoClaimPlaytimeThread = nil
            end

            if enabled then
                autoClaimPlaytimeThread = task.spawn(function()
                    local Holder = LocalPlayer.PlayerGui.MainUI.Menus.RewardsFrame.Main.Displays.Playtime.Holder

                    while autoClaimPlaytimeEnabled do
                        local success, err = pcall(function()
                            for _, rewardFrame in ipairs(Holder:GetChildren()) do
                                if rewardFrame:IsA("Frame") then
                                    local rewardId = tonumber(rewardFrame.Name)
                                    local timerLabel = rewardFrame:FindFirstChild("Main", true) and rewardFrame.Main:FindFirstChild("Timer")

                                    if timerLabel and timerLabel.Text == "Claim" then
                                        RewardService:claimPlaytimeReward(rewardId)
                                        task.wait(1)
                                    end
                                end
                            end
                        end)

                        if not success then
                        end

                        task.wait(10)
                    end
                end)
            end
        end
    })

    createClaimToggle("Daily", "Auto Claim Daily Reward", function()
        DataController:waitForData()
        local playerData = DataController:getData()
        if workspace:GetServerTimeNow() - playerData.dayReset >= 86400 and math.max(0, 600 - (playerData.dailyRewardRequiredTime or 0)) <= 0 then
            RewardService:claimDailyReward(); task.wait(1)
        end
    end)

    createClaimToggle("Prestige", "Auto Prestige", function()
        local PrestigeService = Knit.GetService("PrestigeService")
        local Prestiges = require(ReplicatedStorage.Shared.List.Prestige.Prestiges)
        DataController:waitForData()
        local playerData = DataController:getData()
        
        if playerData then
            local currentPrestige = playerData.prestige
            local currentPrestigeXP = playerData.prestigeXp
            local nextPrestige = Prestiges[currentPrestige + 1]
            
            if nextPrestige and currentPrestigeXP >= nextPrestige.required then
                PrestigeService:claim()
                task.wait(1)
            end
        end
    end)

    local IndexService = Knit.GetService("IndexService")
    local DataController = Knit.GetController("DataController")
    local PetController = Knit.GetController("PetController")

    local IndexRewards = require(ReplicatedStorage.Shared.List.IndexRewards)
    local Util = require(ReplicatedStorage.Shared.Util)

    ClaimSection:Toggle("AutoClaimIndexRewards", {
        Title = "Auto Claim Index Rewards",
        Default = false,
        Callback = function(enabled)
            autoClaimIndexRewardsEnabled = enabled
            if enabled then
                task.spawn(function()
                    DataController:waitForData()
                    while autoClaimIndexRewardsEnabled do
                        local playerData = DataController:getData()
                        if playerData then
                            local claimed = playerData.claimedIndexRewards or {}
                            local existTable = PetController:getExistTable()
                            local indexedCount = Util.indexUtils.countIndex(playerData, existTable)

                            for rewardId, rewardData in pairs(IndexRewards) do
                                local required = rewardData.required or 0
                                local alreadyClaimed = table.find(claimed, rewardId)


                                if indexedCount >= required and not alreadyClaimed then
                                    -- Claim reward every second until successful
                                    task.spawn(function()
                                        while autoClaimIndexRewardsEnabled and not table.find((DataController:getData().claimedIndexRewards or {}), rewardId) do
                                            local success, err = pcall(function()
                                                IndexService:claimIndexReward(rewardId)
                                            end)
                                            if success then
                                            else
                                            end
                                            task.wait(1)
                                        end
                                    end)
                                end
                            end
                        else
                        end
                        task.wait(5)
                    end
                end)
            else
            end
        end
    })

    supplyDropThread = nil
    ClaimSection:Toggle("OpenSupplyDrops", { Title = "Open Supply Drops", Default = false,
        Callback = function(enabled)
            if supplyDropThread then task.cancel(supplyDropThread); supplyDropThread = nil end
            if enabled then
                supplyDropThread = task.spawn(function()
                    while enabled do
                        local debris = Workspace:FindFirstChild("Debris")
                        if debris then
                            for _, dropEvent in ipairs(debris:GetChildren()) do
                                if dropEvent.Name:find("SupplyDropEvent") then
                                    for _, obj in ipairs(dropEvent:GetChildren()) do
                                        local prompt = obj:FindFirstChild("ProximityPrompt"); if prompt then pcall(fireproximityprompt, prompt) end
                                    end
                                end
                            end
                        end
                        task.wait(1)
                    end
                end)
            end
        end
    })

    local TutorialSection = Tabs.Misc:AddSection("Tutorial")

    TutorialSection:AddButton({
        Title = "Complete Tutorial",
        Callback = function()
            local success, err = pcall(function()
                local TutorialList = require(ReplicatedStorage.Shared.List.Tutorial)
                local function forceCompleteCheck()
                    return true
                end

                local hookedCount = 0
                for i, stageData in ipairs(TutorialList) do
                    if type(stageData) == "table" and type(stageData.stageIsCompleted) == "function" then
                        stageData.stageIsCompleted = forceCompleteCheck
                        hookedCount = hookedCount + 1
                    end
                end
            end)
        end
    })

    AncientWheel = Tabs.Misc:AddSection("Ancient Wheel")
    isAutoSpinEnabled = false
    AncientWheel:Toggle("AutoSpin", { Title = "Auto Spin Ancient Wheel", Default = false,
        Callback = function(enabled)
            isAutoSpinEnabled = enabled
            task.spawn(function()
                while isAutoSpinEnabled do
                    pcall(function() RewardService:ancientWheelSpin() end)
                    task.wait(0.01)
                end
            end)
        end
    })

    
    ClanWheel = Tabs.Misc:AddSection("Clan Wheel")
    isAutoSpinEnabled1 = false
    ClanWheel:Toggle("AutoSpin1", { Title = "Auto Spin Clan Wheel", Default = false,
        Callback = function(enabled)
            isAutoSpinEnabled1 = enabled
            task.spawn(function()
                while isAutoSpinEnabled1 do
                    pcall(function() ClanService:clanWheelSpin()() end)
                    task.wait(60)
                end
            end)
        end
    })

    BoostWheel = Tabs.Misc:AddSection("Boost Wheel")
    isAutoSpinEnabled12 = false
    BoostWheel:Toggle("AutoSpin12", { Title = "Auto Spin Boost Wheel", Default = false,
        Callback = function(enabled)
            isAutoSpinEnabled12 = enabled
            task.spawn(function()
                while isAutoSpinEnabled12 do
                    pcall(function() RewardService:boostWheelSpin()() end)
                    task.wait(60)
                end
            end)
        end
    })


    AncientMerchantSection = Tabs.Misc:AddSection("Ancient Merchant")

    getAllAncientMerchantItems = function()
        local options, itemMap = {}, {}
        pcall(function()
            local AncientMerchant = require(ReplicatedStorage.Shared.List.AncientMerchant)
            for i, offer in ipairs(AncientMerchant) do
                local name, amount, price = offer.item.nm or "Unknown Item", offer.item.am or 1, offer.price or 0
                local displayName = string.format("%s - %d Ancient Tickets", (amount > 1 and (amount .. "x " .. name)) or name, price)
                table.insert(options, displayName)
                itemMap[displayName] = {name = name, amount = amount, price = price}
            end
        end)
        return options, itemMap
    end

    local merchantOptions, merchantItemMap = getAllAncientMerchantItems()
    local selectedMerchantItems = {}

    AncientMerchantSection:Dropdown("SelectItems", {Title = "Select Items", Values = merchantOptions, Multi = true, Searchable = true, Default = {}, Callback = function(value) selectedMerchantItems = value end})

    isAutoBuyEnabled = false
    AncientMerchantSection:Toggle("AutoBuy", {Title = "Auto Buy", Description = "Automatically buys selected items when they appear in the merchant", Default = false, Callback = function(enabled)
        isAutoBuyEnabled = enabled
        if enabled then
            task.spawn(function()
                while isAutoBuyEnabled do
                    if next(selectedMerchantItems) then
                        pcall(function()
                            local AncientMerchantList = require(ReplicatedStorage.Shared.List.AncientMerchant)
                            DataController:waitForData()
                            local data, boughtData, serverTimeNow = DataController:getData(), (DataController:getData()).ancientMerchantBought or {}, Knit.serverTimeNow or os.time()
                            for slot = 1, Values.ancientMerchantSlots(LocalPlayer, data) do
                                local ts = DateTime.fromUnixTimestamp(serverTimeNow + 3600):ToUniversalTime()
                                local seed = ts.Year * 222 + ts.Month * 333 + ts.Day * 444444 + ts.Hour * 33333 + LocalPlayer.UserId + slot
                                local itemData = AncientMerchantList[Functions.getRandom(AncientMerchantList, seed)]
                                if itemData then
                                    local merchantItem = itemData.item
                                    local merchantName = merchantItem.nm or "Unknown"
                                    local merchantAmount = merchantItem.am or 1
                                    
                                    for displayName, isSelected in pairs(selectedMerchantItems) do
                                        if isSelected and merchantItemMap[displayName] then
                                            local selectedItem = merchantItemMap[displayName]
                                            if merchantName == selectedItem.name and merchantAmount == selectedItem.amount then
                                                local key = string.format("%*", seed)
                                                if not boughtData[key] then
                                                    local ancientTickets = 0
                                                    if data.inventory and data.inventory.exclusive then 
                                                        for itemId, item in pairs(data.inventory.exclusive) do 
                                                            if item.nm == "ancientTicket" then 
                                                                ancientTickets = item.am or 0
                                                                break 
                                                            end 
                                                        end 
                                                    end
                                                    if ancientTickets >= selectedItem.price then 
                                                        RewardService:buyAncientMerchant(slot)
                                                        task.wait(2) 
                                                    end
                                                end
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end)
                    end
                    task.wait(5)
                end
            end)
        end
    end})


    PassSection = Tabs.Misc:AddSection("Season Pass")
    PassSection:Toggle("AutoClaimToggle", { Title = "Auto Claim Season Rewards", Description = "Automatically claims all available season pass rewards.", Default = false, Callback = function(s) _G.AutoClaimToggle = s end })
    PassSection:Toggle("AutoResetPassToggle", { Title = "Auto Reset Season Pass", Description = "Automatically resets the pass AFTER all rewards have been claimed.", Default = false, Callback = function(s) _G.AutoResetPassToggle = s end })

    task.spawn(function()
        while task.wait(5) do
            if not (_G.AutoClaimToggle or _G.AutoResetPassToggle) then continue end
            pcall(function()
                local playerData = DataController:getData(); if not playerData then return end
                local seasonNum, currentPassLevel, hasPremiumPass, claimedTiersData, totalTiers = seasonVariables.season, seasonUtils.seasonUtils.getLevel(playerData), playerData[("season%*PassPremium"):format(seasonVariables.season)], playerData[("season%*PassClaimed"):format(seasonVariables.season)], #seasonTiersList
                local allRewardsClaimed = true

                for tier = 1, totalTiers do
                    if tier > currentPassLevel then allRewardsClaimed = false; break end
                    for track = 1, 2 do
                        if track == 2 and not hasPremiumPass then continue end
                        local rewardKey = ("%*%*"):format(track, tier)
                        
                        if not claimedTiersData[rewardKey] then
                            allRewardsClaimed = false
                            if _G.AutoClaimToggle then
                                SeasonService:claimTier(tier, track)
                                task.wait(0.2)
                            end
                        end
                    end
                end
                
                if _G.AutoResetPassToggle and allRewardsClaimed then SeasonService:resetPass() end
            end)
        end
    end)
    
local PetArchiverSection = Tabs.Misc:AddSection("Pet Archiver")

    local petsToKeepInput = PetArchiverSection:AddInput("PetsToKeepInput", {
        Title = "Number of best Pets to KEEP",
        Default = "20",
        Numeric = true,
        Description = "Keeps your strongest pets."
    })

    local keepSpecialToggle = PetArchiverSection:AddToggle("KeepSpecialPetsToggle", {
        Title = "Keep Event Pets",
        Description = "Keep pets with an event boost.",
        Default = true
    })

    PetArchiverSection:AddButton({
        Title = "Archive Unwanted Pets",
        Description = "This will never archive a pet which has a % bonus. This will archive all pets, other then equipped pets, your strongest pets, and event pets (if selected).",
        Callback = function()
            local numToKeep = tonumber(petsToKeepInput.Value) or 20
            local shouldKeepPercentBonus = keepSpecialToggle.Value
            
            local playerData = DataController:getData()
            local PetDefinitions = require(ReplicatedStorage.Shared.List.Pets.Pets)
            
            if not playerData or not playerData.inventory or not playerData.inventory.pet then
                warn("Pet Archiver: Could not load pet inventory data.")
                return
            end

            local allPetsMasterList = {}
            pcall(function()
                for petId, petRawData in pairs(playerData.inventory.pet) do
                    local petObject = Util.itemUtils.createItemFromData(petRawData)
                    if petObject then
                        table.insert(allPetsMasterList, {
                            id = petId,
                            name = petObject:getName(),
                            multiplier = petObject:getMultiplier()
                        })
                    end
                end
            end)
            table.sort(allPetsMasterList, function(a, b) return a.multiplier > b.multiplier end)

            local petsToKeepIds = {}

            -- Rule 1: Keep Top N pets
            for i = 1, math.min(numToKeep, #allPetsMasterList) do
                petsToKeepIds[allPetsMasterList[i].id] = true
            end

            -- Rule 2: Keep ALL equipped pets
            if playerData.equippedPets then
                for petId, _ in pairs(playerData.equippedPets) do
                    petsToKeepIds[petId] = true
                end
            end
            
            -- Rule 3 & 4: Keep special bonus pets
            for _, petData in ipairs(allPetsMasterList) do
                local petDef = PetDefinitions[petData.name]
                if petDef then
                    -- ALWAYS keep pets with the dynamic 'special' key
                    if petDef.special then
                        petsToKeepIds[petData.id] = true
                    end
                    -- CONDITIONALLY keep pets with the 'specialMultiplier' key
                    if petDef.specialMultiplier and shouldKeepPercentBonus then
                        petsToKeepIds[petData.id] = true
                    end
                end
            end

            local petsToArchiveIds = {}
            for petId, _ in pairs(playerData.inventory.pet) do
                if not petsToKeepIds[petId] then
                    petsToArchiveIds[petId] = true
                end
            end

            if next(petsToArchiveIds) then
                pcall(function()
                    PetService:archivePets(petsToArchiveIds, 1)
                end)
                print(string.format("Archiver: Sent %d pets to the archive.", table.getn(petsToArchiveIds)))
            else
                print("Archiver: No pets to archive based on your rules.")
            end
        end
    })
    EventSection = Tabs.Misc:AddSection("Events")
    isAutoBreakingMeteors = false
    EventSection:Toggle("AutoBreakMeteors", { Title = "Auto Break Meteors (Infinite Range)", Default = false,
        Callback = function(Value)
            isAutoBreakingMeteors = Value
            if Value then
                task.spawn(function()
                    while isAutoBreakingMeteors do
                        local allMeteors = CollectionService:GetTagged("Meteor")
                        if #allMeteors > 0 then
                            while #allMeteors > 0 and isAutoBreakingMeteors do
                                for _, meteor in ipairs(allMeteors) do
                                    pcall(function() local id=meteor:GetAttribute("meteorId"); if id then EventService.damageMeteor:Fire(id) end end)
                                end
                                task.wait()
                                allMeteors = CollectionService:GetTagged("Meteor")
                            end
                        end
                        task.wait(5)
                    end
                end)
            end
        end
    })

    -- Hand the library over to our managers
    SaveManager:SetLibrary(Library)
    InterfaceManager:SetLibrary(Library)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetIgnoreIndexes{}
    InterfaceManager:SetFolder("FluentScriptHub")
    SaveManager:SetFolder("FluentScriptHub/specific-game")
    InterfaceManager:BuildInterfaceSection(Tabs.Settings)
    SaveManager:BuildConfigSection(Tabs.Settings)

    Window:SelectTab(1)
    SaveManager:LoadAutoloadConfig()
end

task.spawn(function()
    if not game:IsLoaded() then game.Loaded:Wait() end

    Knit = require(ReplicatedStorage.Packages.Knit)
    Knit.OnStart():await()

    ClickService = Knit.GetService("ClickService")
    EggService = Knit.GetService("EggService")
    RebirthService = Knit.GetService("RebirthService")
    TreeService = Knit.GetService("TreeService")
    AxeService = Knit.GetService("AxeService")
    InventoryService = Knit.GetService("InventoryService")
    PetService = Knit.GetService("PetService")
    RewardService = Knit.GetService("RewardService")
    ClanService = Knit.GetService("ClanService")
    UpgradeService = Knit.GetService("UpgradeService")
    SeasonService = Knit.GetService("SeasonService")
    FarmService = Knit.GetService("FarmService")
    AuraService = Knit.GetService("AuraService")
    EventService = Knit.GetService("EventService")
    OrbService = Knit.GetService("OrbService")
    BuildingService = Knit.GetService("BuildingService")
    LumberjackService = Knit.GetService("LumberjackService")
    DungeonService = Knit.GetService("DungeonService")
    
    DataController = Knit.GetController("DataController")
    EggController = Knit.GetController("EggController")
    TreeController = Knit.GetController("TreeController")
    AuraController = Knit.GetController("AuraController")
    MapController = Knit.GetController("MapController")
    OrbController = Knit.GetController("OrbController")
    ItemController = Knit.GetController("ItemController")
    SoundController = Knit.GetController("SoundController")
    FarmController = Knit.GetController("FarmController")
    BuildingController = Knit.GetController("BuildingController")
    HatchingController = require(LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("Client"):WaitForChild("Controllers"):WaitForChild("HatchingController"))
    
    Functions = require(ReplicatedStorage.Shared.Functions)
    seasonVariables = require(ReplicatedStorage.Shared.Variables)
    seasonUtils = require(ReplicatedStorage.Shared.Util)
    seasonTiersList = require(ReplicatedStorage.Shared.List[("Season%*"):format(seasonVariables.season)].Tiers)
    Util = require(ReplicatedStorage.Shared.Util)
    Values = require(ReplicatedStorage.Shared.Values)   

    Window = Library:Window{
        Title = "bequit army",
        SubTitle = "üéÉ",
        TabWidth = 160,
        Size =  UDim2.fromOffset(580, 460),
        Resize = true,
        Theme = "Darker",
        MinimizeKey = Enum.KeyCode.LeftShift
    }

    Tabs = {
        Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
        Main = Window:AddTab({ Title = "Auto Farm", Icon = "crown" }),
        Tree = Window:AddTab({ Title = "Axe/Tree", Icon = "phosphor-tree-evergreen-duotone" }),
        Farm = Window:AddTab({ Title = "Farming", Icon = "phosphor-farm-bold" }),
        Pet = Window:AddTab({ Title = "Pet Crafting", Icon = "paw-print" }),     
        Craft = Window:AddTab({ Title = "Building", Icon = "hammer" }),
        Quest = Window:AddTab({ Title = "Quests", Icon = "phosphor-scroll-bold" }),
        Claim = Window:AddTab({ Title = "Auto Claim/Collect", Icon = "gift" }),
        Misc = Window:AddTab({ Title = "Misc", Icon = "sparkles" }),
    }

    BuildUI()
end)
