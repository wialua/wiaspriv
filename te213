-- =====================================
-- LinoriaLib Full Integration of Fluent UI Code
-- Adapted by Grok: Keeps original logic intact, only replaces UI calls with LinoriaLib equivalents.
-- Sections simulated with Groupboxes or Dividers/Labels for organization.
-- Paragraphs replaced with dynamic Labels (using SetText for updates).
-- Multi Dropdowns use Multi=true.
-- All callbacks, threads, and game logic unchanged.
-- =====================================

-- ==============================
-- 1. LOAD LIBRARY & ADDONS
-- ==============================
local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- Shortcut tables for easier access
local Options = Library.Options
local Toggles = Library.Toggles

-- ==============================
-- 2. GLOBAL SETTINGS
-- ==============================
Library.ShowToggleFrameInKeybinds = true   -- Show toggles in Keybind menu (mobile-friendly)
Library.ShowCustomCursor = false           -- Use Linoria custom cursor globally
Library.NotifySide = "Left"               -- Notifications appear on Left/Right

-- ==============================
-- 3. CREATE WINDOW
-- ==============================
local Window = Library:CreateWindow({
    Title = "Wia Rebirth Ultimate Champions - Halloween",
    Center = true,
    AutoShow = true,
    Resizable = true,
    ShowCustomCursor = false,
    UnlockMouseWhileOpen = true,
    NotifySide = "Left",
    TabPadding = 8,
    MenuFadeTime = 0.2
})

-- ==============================
-- 4. CREATE TABS
-- ==============================
local Tabs = {
    Halloween = Window:AddTab('Halloween Event'),
    Ana = Window:AddTab('Later'),
}

-- Original code integrations start here (anti-AFK and garbage collect unchanged)
loadstring(game:HttpGet("https://raw.githubusercontent.com/SenhorLDS/ProjectLDSHUB/refs/heads/main/Anti%20AFK"))()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Global variables for game services and controllers
local Knit, ClickService, UpgradeService, DataController, Functions, Util, Values

-- Global variables for UI window and tabs (already defined above)

spawn(function()
    while wait(30) do 
        pcall(function() collectgarbage("collect") end)
    end
end)

-- BuildUI function with LinoriaLib adaptations
BuildUI = function()

    local mobDropdown, AutoHitToggle, EquipBest, HitSpeed, AutoUpgradeSwordToggle, AutoRebirthToggle

    -- Simulate "Auto Click" Section with Left Groupbox
    local AutoClickGroup = Tabs.Halloween:AddLeftGroupbox('Auto Click')

    AutoClickGroup:AddToggle('AutoClick', {
        Text = 'Auto Click',
        Tooltip = 'Otomatik Tıklayıcı!',
        Default = false,
        Callback = function(Value)
            AutoClicking = Value
            if Value then
                task.spawn(function()
                    while AutoClicking do
                        ClickService.click._re:FireServer()
                        task.wait(0.001)
                    end
                end)
            end
        end
    })

    -- Simulate "Auto Hatch (Halloween)" Section with another Groupbox
    local HalloweenHatchGroup = Tabs.Halloween:AddLeftGroupbox('Oto halloween pet açma')

    -- Get egg names from the Halloween map and add the special boss egg
    local halloweenEggOptions = {}
    pcall(function()
        local eggFolder = Workspace.Game.Maps:FindFirstChild("0Halloween") and Workspace.Game.Maps["0Halloween"]:FindFirstChild("Eggs")
        if eggFolder then
            for _, eggModel in ipairs(eggFolder:GetChildren()) do table.insert(halloweenEggOptions, eggModel.Name) end
        end
    end)
    table.insert(halloweenEggOptions, "Halloween (Boss)")
    
    local selectedHalloweenEgg = halloweenEggOptions[1] or "Basic"

    -- UI Element 1: Egg Selection Dropdown
    HalloweenHatchGroup:AddDropdown('SelectHalloweenEgg', {
        Text = 'Select Egg',
        Values = halloweenEggOptions,
        Default = 1,  -- Index-based default
        Callback = function(value) selectedHalloweenEgg = value end
    })

    -- UI Element 2: Hatch Amount Dropdown
    local halloweenHatchAmounts = {["1x"]=1, ["3x"]=3, ["Max"]=99}
    local selectedHalloweenAmount = halloweenHatchAmounts["Max"]
    HalloweenHatchGroup:AddDropdown('SelectHalloweenHatchAmount', {
        Text = 'Select Hatch Amount',
        Values = {"1x", "3x", "Max"},
        Default = 3,  -- Index for "Max"
        Callback = function(value) selectedHalloweenAmount = halloweenHatchAmounts[value] or 1 end
    })

    -- UI Element 3: Lucky Eggs Toggle
    local useHalloweenLuckyEggs = false
    HalloweenHatchGroup:AddToggle('UseHalloweenLuckyEggs', {
        Text = 'Use Lucky Eggs',
        Tooltip = 'Does not apply to the \'Halloween (Boss)\' egg.',
        Default = false,
        Callback = function(enabled) useHalloweenLuckyEggs = enabled end
    })

    -- Ensure the global hatch delay logic is present
    if not _G.SmartHatchDelay then
        _G.SmartHatchDelay = 4.11
        task.spawn(function()
            local hatchTimeLabel = LocalPlayer.PlayerGui.MainUI.Menus.SettingsFrame.Main.List.Multipliers.HatchingSpeed.Main.Amount
            while true do
                pcall(function()
                    local numberString = string.match(hatchTimeLabel.Text, "%d+%.?%d*")
                    if numberString then _G.SmartHatchDelay = (tonumber(numberString) or 4.01) + 0.1 end
                end)
                task.wait(5)
            end
        end)
    end
    
    -- UI Element 4: Auto Hatch Toggle
    local autoHalloweenHatchThread = nil
    HalloweenHatchGroup:AddToggle('AutoHatchHalloween', {
        Text = 'Auto Hatch Event Eggs',
        Default = false,
        Callback = function(enabled)
            if autoHalloweenHatchThread then task.cancel(autoHalloweenHatchThread); autoHalloweenHatchThread = nil end
            if enabled then
                autoHalloweenHatchThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            if selectedHalloweenEgg == "Halloween (Boss)" then
                                Knit.GetService("EggService").openEgg._re:FireServer("Halloween", selectedHalloweenAmount, {isBossCave = true})
                            else
                                local args = {selectedHalloweenEgg, selectedHalloweenAmount}
                                if useHalloweenLuckyEggs then
                                    local anyAvailableLuckyId = next((Knit.GetController("EggController"))._luckyEggs or {})
                                    if anyAvailableLuckyId then table.insert(args, {luckyEggId = anyAvailableLuckyId}) end
                                end
                                Knit.GetService("EggService").openEgg._re:FireServer(unpack(args))
                            end
                        end)
                        task.wait(_G.SmartHatchDelay)
                    end
                end)
            end
        end
    })

    -- UI Element 5: Hide Animation Toggle
    HalloweenHatchGroup:AddToggle('HideHalloweenHatchAnimation', {
        Text = 'Hide Hatch Animation',
        Default = false,
        Callback = function(Value)
            local HatchingController = require(LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("Client"):WaitForChild("Controllers"):WaitForChild("HatchingController"))
            local function overrideFunctions(shouldHide)
                if not HatchingController._originalFunctions and shouldHide then
                    HatchingController._originalFunctions = {
                        playEggAnimation = HatchingController.playEggAnimation, playHatchingAnimation = HatchingController.playHatchingAnimation,
                        animatePetIn = HatchingController.animatePetIn, animatePetOut = HatchingController.animatePetOut,
                        dropEggs = HatchingController.dropEggs, shakeEggs = HatchingController.shakeEggs,
                        scaleAndRemoveEggs = HatchingController.scaleAndRemoveEggs, playRevealSounds = HatchingController.playRevealSounds
                    }
                end
                local emptyFunc = function() return nil end
                for funcName, originalFunc in pairs(HatchingController._originalFunctions or {}) do
                    HatchingController[funcName] = shouldHide and emptyFunc or originalFunc
                end
            end
            overrideFunctions(Value)
        end
    })
    
    -- Simulate "Mini Chests" Section with Right Groupbox (to balance UI)
    local MiniChestsGroup = Tabs.Halloween:AddRightGroupbox('Mini Chests')
    
    local collectChestsThread = nil

    MiniChestsGroup:AddToggle('CollectMiniChests', {
        Text = 'Collect Mini Chests',
        Tooltip = 'Automatically collects the mini chests in the Halloween world.',
        Default = false,
        Callback = function(enabled)
            if collectChestsThread then
                task.cancel(collectChestsThread)
                collectChestsThread = nil
            end

            if enabled then
                collectChestsThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local chestsFolder = Workspace.Game.Maps:FindFirstChild("0Halloween") 
                                and Workspace.Game.Maps["0Halloween"]:FindFirstChild("MiniChests")

                            if chestsFolder then
                                for _, chest in ipairs(chestsFolder:GetChildren()) do
                                    local touchPart = chest:FindFirstChild("Touch")
                                    local prompt = touchPart and touchPart:FindFirstChildOfClass("ProximityPrompt")

                                    if prompt and prompt.Enabled then
                                        fireproximityprompt(prompt)
                                        task.wait(2)
                                    end
                                end
                            end
                        end)
                        task.wait(5)
                    end
                end)
            end
        end
    })

    -- Simulate "Halloween Shop" Section with another Groupbox
    local HalloweenShopGroup = Tabs.Halloween:AddRightGroupbox('Halloween Shop')

    local shopItemNames = {}
    local shopItemMap = {}
    local autoBuyShopThread = nil

    pcall(function()
        local HalloweenShopList = require(ReplicatedStorage.Shared.List.Halloween.HalloweenShop)
        local itemsToSort = {}

        for id, cost in pairs(HalloweenShopList) do
            local displayName = string.format("%s (Cost: %s)", id, Functions.suffixes(cost))
            table.insert(itemsToSort, { display = displayName, id = id, cost = cost })
            shopItemMap[displayName] = { id = id, cost = cost }
        end

        table.sort(itemsToSort, function(a, b) return a.cost < b.cost end)

        for _, itemData in ipairs(itemsToSort) do
            table.insert(shopItemNames, itemData.display)
        end
    end)

    local shopDropdown = HalloweenShopGroup:AddDropdown('SelectShopItems', {
        Text = 'Select Items to Auto Buy',
        Values = shopItemNames,
        Multi = true,
        Callback = function(v) end  -- Placeholder, value accessed via Options.SelectShopItems.Value
    })

    HalloweenShopGroup:AddToggle('AutoBuyShopItems', {
        Text = 'Auto Buy',
        Tooltip = 'Automatically buys selected items you don\'t own and can afford.',
        Default = false,
        Callback = function(enabled)
            if autoBuyShopThread then
                task.cancel(autoBuyShopThread)
                autoBuyShopThread = nil
            end

            if enabled then
                autoBuyShopThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local selectedItems = Options.SelectShopItems.Value
                            if not next(selectedItems) then return end

                            local playerData = DataController:getData()
                            local candyCornItem = Util.itemUtils.getItemFromName(playerData, "candyCorns")
                            local myCandyCorns = candyCornItem and candyCornItem:getAmount() or 0
                            local playerOwnedData = playerData.halloweenShop or {}

                            for displayName, isSelected in pairs(selectedItems) do
                                if isSelected then
                                    local shopData = shopItemMap[displayName]
                                    if not playerOwnedData[shopData.id] and myCandyCorns >= shopData.cost then
                                        -- Corrected function name from buyHalloweenShop to buyShop
                                        Knit.GetService("HalloweenService"):buyShop(shopData.id)
                                        myCandyCorns = myCandyCorns - shopData.cost
                                        task.wait(1)
                                    end
                                end
                            end
                        end)
                        task.wait(5)
                    end
                end)
            end
        end
    })
    

    -- Simulate "Halloween Rewards" Section
    local HalloweenRewardsGroup = Tabs.Halloween:AddLeftGroupbox('Halloween Rewards')

    local autoClaimRewardThread = nil

    HalloweenRewardsGroup:AddToggle('AutoClaimHalloweenReward', {
        Text = 'Auto Claim Halloween Rewards',
        Tooltip = 'Automatically claims rewards when you have Halloween Tickets.',
        Default = false,
        Callback = function(enabled)
            if autoClaimRewardThread then
                task.cancel(autoClaimRewardThread)
                autoClaimRewardThread = nil
            end

            if enabled then
                autoClaimRewardThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local playerData = DataController:getData()
                            if not playerData then return end
                            local halloweenTicketItem = Util.itemUtils.getItemFromName(playerData, "halloweenTicket")
                            local ticketAmount = halloweenTicketItem and halloweenTicketItem:getAmount() or 0
                            if ticketAmount > 0 then
                                Knit.GetService("HalloweenService"):claimHalloweenReward()
                            end
                        end)
                        task.wait(0.25)
                    end
                end)
            end
        end
    })

    -- Simulate "Cursed Chest" Section
    local CursedChestGroup = Tabs.Halloween:AddLeftGroupbox('Cursed Chest')
    
    local useOneKeyThread, useAllKeysThread = nil, nil

    CursedChestGroup:AddToggle('AutoUseOneCursedKey', {
        Text = 'Use 1x Cursed Key',
        Tooltip = 'Uses one Cursed Key (every second).',
        Default = false,
        Callback = function(enabled)
            if useOneKeyThread then task.cancel(useOneKeyThread); useOneKeyThread = nil end
            if enabled then
                useOneKeyThread = task.spawn(function()
                    while enabled do
                        pcall(function() Knit.GetService("HalloweenService"):cursedChest() end)
                        task.wait(1)
                    end
                end)
            end
        end
    })

    CursedChestGroup:AddToggle('AutoUseAllCursedKeys', {
        Text = 'Use All Cursed Keys',
        Tooltip = 'Uses all available Cursed Keys every 5 seconds.',
        Default = false,
        Callback = function(enabled)
            if useAllKeysThread then task.cancel(useAllKeysThread); useAllKeysThread = nil end
            if enabled then
                useAllKeysThread = task.spawn(function()
                    while enabled do
                        pcall(function() Knit.GetService("HalloweenService"):cursedChest(true) end)
                        task.wait(5)
                    end
                end)
            end
        end
    })

    -- Simulate "Halloween Mobs" Section
    local HalloweenMobsGroup = Tabs.Halloween:AddRightGroupbox('Halloween Mobs')

    local mobNames = {}
    local MobsModule = nil
    local autoHitThread = nil

    pcall(function()
        MobsModule = require(ReplicatedStorage.Shared.List.Halloween.Mobs)
        for id, data in pairs(MobsModule) do table.insert(mobNames, id) end
        table.sort(mobNames)
    end)
    
    mobDropdown = HalloweenMobsGroup:AddDropdown('SelectMobs', {
        Text = 'Select Mobs to Target',
        Values = mobNames,
        Multi = true,
        Callback = function(v) end  -- Value accessed via Options.SelectMobs.Value
    })

    AutoHitToggle = HalloweenMobsGroup:AddToggle('AutoHit', {
        Text = 'Auto Kill Mobs',
        Tooltip = 'Kills selected mobs. If none of the selected mbos are available, it will kill mobs based on your weapon damage.',
        Default = false,
        Callback = function(enabled)
            if autoHitThread then task.cancel(autoHitThread); autoHitThread = nil end

            if enabled then
                autoHitThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local selectedMobTypes = Options.SelectMobs.Value
                            local playerData = DataController:getData()
                            local activeMobs = playerData and playerData.mobs
                            
                            if not activeMobs or not next(activeMobs) then return end

                            local availableTypes = {}
                            for instanceId, mobData in pairs(activeMobs) do
                                if selectedMobTypes[mobData.mobId] then
                                    local mobId = mobData.mobId; availableTypes[mobId] = availableTypes[mobId] or {}
                                    if MobsModule[mobId] then table.insert(availableTypes[mobId], { id = instanceId, health = MobsModule[mobId].hp - (mobData.damage or 0) }) end
                                end
                            end

                            local target
                            local typeKeys = {}; for typeName in pairs(availableTypes) do table.insert(typeKeys, typeName) end

                            if #typeKeys > 0 then
                                local chosenTypeName = typeKeys[math.random(1, #typeKeys)]
                                local mobsOfChosenType = availableTypes[chosenTypeName]
                                local lowestHealth = math.huge
                                for _, mob in ipairs(mobsOfChosenType) do if mob.health < lowestHealth then lowestHealth = mob.health end end
                                local weakestTies = {}; for _, mob in ipairs(mobsOfChosenType) do if mob.health == lowestHealth then table.insert(weakestTies, mob) end end
                                if #weakestTies > 0 then target = weakestTies[math.random(1, #weakestTies)] end
                            else
                                local HalloweenItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                                local bestSwordInfo, bestIndex = nil, -1
                                for _, itemData in pairs(playerData.inventory.halloweenEvent or {}) do
                                    local itemStats = HalloweenItems[itemData.nm]
                                    if itemStats and itemStats.index and itemStats.index > bestIndex then bestIndex, bestSwordInfo = itemStats.index, itemStats end
                                end
                                
                                if bestSwordInfo then
                                    local damageLimit = bestSwordInfo.multiplier * 25
                                    local viableTargets = {}
                                    for instanceId, mobData in pairs(activeMobs) do
                                        local mobStats = MobsModule[mobData.mobId]
                                        if mobStats and mobStats.hp <= damageLimit then
                                            table.insert(viableTargets, { id = instanceId, name = mobData.mobId, health = mobStats.hp - (mobData.damage or 0) })
                                        end
                                    end

                                    if #viableTargets > 0 then
                                        table.sort(viableTargets, function(a, b) return a.health > b.health end)
                                        target = viableTargets[1]
                                    end
                                end

                                if not target then
                                    local lowestHealth = math.huge
                                    for instanceId, mobData in pairs(activeMobs) do
                                        local mobStats = MobsModule[mobData.mobId]
                                        if mobStats then
                                            local currentHealth = mobStats.hp - (mobData.damage or 0)
                                            if currentHealth < lowestHealth then
                                                lowestHealth, target = currentHealth, {id = instanceId, name = mobData.mobId, health = currentHealth}
                                            end
                                        end
                                    end
                                end
                            end

                            if target and target.id then
                                Knit.GetService("HalloweenService").damage._re:FireServer(target.id)
                            end
                        end)
                        task.wait(0.25)
                    end
                end)
            end
        end
    })

    local originalWeaponSpeed = Values.weaponSpeed
    HitSpeed = HalloweenMobsGroup:AddToggle('IncreaseSwordSpeed', {
        Text = 'Increase Sword Speed',
        Tooltip = 'Makes your sword swing much faster. This works best when hitting mobs manually.',
        Default = false,
        Callback = function(Value)
            if Value then
                Values.weaponSpeed = function(...) return originalWeaponSpeed(...) / 10 end
            else
                Values.weaponSpeed = originalWeaponSpeed
            end
        end
    })

    local isAutoEquipSwordEnabled = false
    EquipBest = HalloweenMobsGroup:AddToggle('AutoEquipBestSword', {
        Text = 'Auto Equip Best Sword',
        Tooltip = 'Automatically equips the best Halloween sword you own.',
        Default = false,
        Callback = function(enabled)
            isAutoEquipSwordEnabled = enabled
            if enabled then
                task.spawn(function()
                    while isAutoEquipSwordEnabled do
                        pcall(function()
                            local HalloweenEventItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                            local playerData = DataController:getData()
                            
                            if not playerData.inventory or not playerData.inventory.halloweenEvent then return end
                            local bestSwordIndex = -1
                            local bestInventoryId = nil
                            for inventoryId, itemData in pairs(playerData.inventory.halloweenEvent) do
                                local itemStats = HalloweenEventItems[itemData.nm]
                                if itemStats and itemStats.index and (itemData.nm:lower():find("sword") or itemData.nm:lower():find("blade")) then
                                    if itemStats.index > bestSwordIndex then
                                        bestSwordIndex = itemStats.index
                                        bestInventoryId = inventoryId
                                    end
                                end
                            end

                            if not bestInventoryId then return end

                            if not playerData.isHalloweenWeaponEquipped then
                                Knit.GetService("InventoryService"):useItem(bestInventoryId)
                            else
                                local currentInventoryId = nil
                                for inventoryId, itemData in pairs(playerData.inventory.halloweenEvent) do
                                    if itemData.nm and (itemData.nm:lower():find("sword") or itemData.nm:lower():find("blade")) then
                                        currentInventoryId = inventoryId
                                        break
                                    end
                                end

                                if currentInventoryId ~= bestInventoryId then
                                     Knit.GetService("InventoryService"):useItem(bestInventoryId)
                                end
                            end
                        end)
                        task.wait(5)
                    end
                end)
            end
        end
    })

    -- Simulate "Sword Upgrades" Section
    local SwordUpgradesGroup = Tabs.Halloween:AddLeftGroupbox('Sword Upgrades')

    local autoUpgradeSwordThread, originalAutoHitSettings = nil, nil

    -- Helper function to find raw item data from player's inventory
    local function findRawItem(playerData, itemName)
        if not playerData or not playerData.inventory then return nil end
        for category, items in pairs(playerData.inventory) do
            if type(items) == "table" then
                for _, data in pairs(items) do if type(data) == "table" and data.nm == itemName then return data end
                end
            end
        end
        return nil
    end
    
    -- Helper map to find which mobs drop which materials
    local function generateItemSourceMap()
        local sources = {}
        local mobs = require(ReplicatedStorage.Shared.List.Halloween.Mobs)
        for mobId, mobData in pairs(mobs) do
            for _, reward in ipairs(mobData.rewards or {}) do
                if reward.item and reward.item.nm then
                    sources[reward.item.nm] = sources[reward.item.nm] or {}
                    table.insert(sources[reward.item.nm], mobId)
                end
            end
        end
        return sources
    end
    local itemSourceMap = generateItemSourceMap()

    -- The status paragraph that updates every second (use Label and update with SetText)
    local upgradeStatusLabel = SwordUpgradesGroup:AddLabel('Loading...', true)
    Library.Labels.UpgradeStatus = upgradeStatusLabel  -- Index for dynamic update

    -- Background task to keep the status paragraph updated
    task.spawn(function()
        while true do
            pcall(function()
                local playerData = DataController:getData()
                if not playerData then return end

                local HalloweenItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                local WeaponUpgrader = require(ReplicatedStorage.Shared.List.Halloween.WeaponUpgrader)

                -- Find current and next weapon
                local currentWeaponIndex, currentWeaponName = -1, "None"
                for _, itemData in pairs(playerData.inventory.halloweenEvent or {}) do
                    local itemStats = HalloweenItems[itemData.nm]
                    if itemStats and itemStats.index and itemStats.index > currentWeaponIndex then
                        currentWeaponIndex = itemStats.index
                        currentWeaponName = itemStats.name
                    end
                end

                local nextWeaponName = nil
                for name, data in pairs(HalloweenItems) do
                    if data.index and data.index == currentWeaponIndex + 1 then
                        nextWeaponName = name; break
                    end
                end
                
                local contentLines = {"Current: " .. currentWeaponName}
                if not nextWeaponName then
                    table.insert(contentLines, "\n🎉 You have the BEST weapon!")
                else
                    local recipe = WeaponUpgrader[nextWeaponName]
                    table.insert(contentLines, "Next: " .. HalloweenItems[nextWeaponName].name .. "\n")
                    
                    for _, reqItem in ipairs(recipe.required) do
                        local itemName = reqItem:getName()
                        local needed = reqItem:getAmount()
                        local current = (findRawItem(playerData, itemName) or {am=0}).am
                        local status = (current >= needed) and "✅" or "❌"
                        table.insert(contentLines, string.format("%s %s: %s / %s", status, itemName, Functions.suffixes(current), Functions.suffixes(needed)))
                    end
                end
                Library.Labels.UpgradeStatus:SetText(table.concat(contentLines, "\n"))
            end)
            task.wait(1)
        end
    end)

    AutoUpgradeSwordToggle = SwordUpgradesGroup:AddToggle('AutoUpgradeSword', {
        Text = 'Auto Upgrade Sword',
        Tooltip = 'Automatically upgrades your sword and farms only the necessary materials.',
        Default = false,
        Callback = function(enabled)
            if autoUpgradeSwordThread then task.cancel(autoUpgradeSwordThread); autoUpgradeSwordThread = nil end

            if enabled then
                originalAutoHitSettings = { selectedMobs = Options.SelectMobs.Value, autoHitState = Toggles.AutoHit.Value, EquipBestState = Toggles.AutoEquipBestSword.Value, HitSpeedState = Toggles.IncreaseSwordSpeed.Value }
                
                autoUpgradeSwordThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local playerData = DataController:getData()
                            local HalloweenItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                            local WeaponUpgrader = require(ReplicatedStorage.Shared.List.Halloween.WeaponUpgrader)
                            local MobsModule = require(ReplicatedStorage.Shared.List.Halloween.Mobs)

                            -- Find current and next weapon
                            local currentWeaponIndex = -1
                            for _, itemData in pairs(playerData.inventory.halloweenEvent or {}) do
                                local itemStats = HalloweenItems[itemData.nm]
                                if itemStats and itemStats.index and itemStats.index > currentWeaponIndex then currentWeaponIndex = itemStats.index end
                            end
                            local nextWeaponName = nil
                            for name, data in pairs(HalloweenItems) do
                                if data.index and data.index == currentWeaponIndex + 1 then nextWeaponName = name; break end
                            end
                            if not nextWeaponName then 
                                Toggles.AutoHit:SetValue(false) -- Max weapon, so turn off farming
                                return 
                            end

                            -- Check requirements and separate missing materials
                            local canAfford, missingMaterials, isMissingCandy = true, {}, false
                            for _, reqItem in ipairs(WeaponUpgrader[nextWeaponName].required) do
                                local itemName, needed = reqItem:getName(), reqItem:getAmount()
                                if (findRawItem(playerData, itemName) or {am=0}).am < needed then
                                    canAfford = false
                                    if itemName == "candyCorns" then
                                        isMissingCandy = true
                                    else
                                        table.insert(missingMaterials, itemName)
                                    end
                                end
                            end

                            if canAfford then
                                Knit.GetService("HalloweenWeaponService"):upgradeWeapon()
                                task.wait(2)
                            else
                                -- NEW FARMING LOGIC
                                local mobsToFarm = {}
                                
                                -- Priority 1: Farm specific mobs for non-candy materials
                                if #missingMaterials > 0 then
                                    for _, material in ipairs(missingMaterials) do
                                        if itemSourceMap[material] then
                                            for _, mobId in ipairs(itemSourceMap[material]) do
                                                mobsToFarm[mobId:lower()] = true
                                            end
                                        end
                                    end
                                -- Priority 2: If ONLY candy is missing, farm the best mob for it
                                elseif isMissingCandy then
                                    local bestSwordInfo, bestIndex = nil, -1
                                    for _, itemData in pairs(playerData.inventory.halloweenEvent) do
                                        local itemStats = HalloweenItems[itemData.nm]
                                        if itemStats and itemStats.index and itemStats.index > bestIndex then bestIndex, bestSwordInfo = itemStats.index, itemStats end
                                    end
                                    if bestSwordInfo then
                                        local damageLimit = bestSwordInfo.multiplier * 25
                                        local viableTargets = {}
                                        for mobId, mobData in pairs(MobsModule) do
                                            if mobData.hp <= damageLimit then table.insert(viableTargets, {id = mobId, data = mobData}) end
                                        end
                                        if #viableTargets > 0 then
                                            table.sort(viableTargets, function(a,b) return a.data.hp > b.data.hp end)
                                            mobsToFarm[viableTargets[1].id:lower()] = true
                                        end
                                    end
                                end

                                -- Update UI
                                local newSelection = {}
                                for mobId, _ in pairs(mobsToFarm) do
                                    for _, mobValue in ipairs(Options.SelectMobs.Values) do
                                        if mobValue:lower() == mobId:lower() then newSelection[mobValue] = true end
                                    end
                                end
                                Options.SelectMobs:SetValue(newSelection)
                                Toggles.IncreaseSwordSpeed:SetValue(next(newSelection) ~= nil)
                                Toggles.AutoEquipBestSword:SetValue(next(newSelection) ~= nil)
                                Toggles.AutoHit:SetValue(next(newSelection) ~= nil)
                            end
                        end)
                        task.wait(2)
                    end
                end)
            else
                if originalAutoHitSettings then
                    Options.SelectMobs:SetValue(originalAutoHitSettings.selectedMobs)
                    Toggles.AutoHit:SetValue(originalAutoHitSettings.autoHitState)
                    Toggles.AutoEquipBestSword:SetValue(originalAutoHitSettings.EquipBestState)
                    Toggles.IncreaseSwordSpeed:SetValue(originalAutoHitSettings.HitSpeedState)
                    originalAutoHitSettings = nil
                end
            end
        end
    })

    
    -- Simulate "Halloween Rebirth" Section
    local HalloweenRebirthGroup = Tabs.Halloween:AddRightGroupbox('Halloween Rebirth')

    local autoRebirthThread, originalAutoHitSettings = nil, nil

    -- NEW: This function dynamically builds a map of items that have ONLY ONE mob source.
    local function generateUniqueDropMap()
        local uniqueMap = {}
        pcall(function()
            local mobs = require(ReplicatedStorage.Shared.List.Halloween.Mobs)
            local itemSources = {} -- First, find ALL sources for each item
            for mobId, mobData in pairs(mobs) do
                for _, reward in ipairs(mobData.rewards or {}) do
                    if reward.item and reward.item.nm then
                        itemSources[reward.item.nm] = itemSources[reward.item.nm] or {}
                        table.insert(itemSources[reward.item.nm], mobId)
                    end
                end
            end
            -- Now, filter for the ones with only one source
            for itemName, sources in pairs(itemSources) do
                if #sources == 1 then
                    uniqueMap[itemName] = sources[1] -- Map item name directly to the single mobId
                end
            end
        end)
        return uniqueMap
    end
    local uniqueDropMap = generateUniqueDropMap()

    local function findRawItem(playerData, itemName)
        if not playerData or not playerData.inventory then return nil end
        for _, items in pairs(playerData.inventory) do
            if type(items) == "table" then for _, data in pairs(items) do if type(data) == "table" and data.nm == itemName then return data end end end
        end
        return nil
    end

    -- Rebirth status (use dynamic Label)
    local rebirthStatusLabel = HalloweenRebirthGroup:AddLabel('Loading...', true)
    Library.Labels.RebirthStatus = rebirthStatusLabel

    task.spawn(function() while true do pcall(function()
        local data=DataController:getData(); if not data then return end; local list=require(ReplicatedStorage.Shared.List.Halloween.HalloweenRebirths)
        local cur=data.halloweenRebirths or 0; local nxt=cur+1; local reqs=list[nxt]
        local lines={"Current Rebirths: "..cur}; if not reqs then table.insert(lines,"\n🎉 MAXIMUM REBIRTH LEVEL!") else
        table.insert(lines,"Target: Rebirth "..nxt.."\n"); table.insert(lines,string.format("Candy Corns: %s / %s",Functions.suffixes((findRawItem(data,"candyCorns")or{am=0}).am),Functions.suffixes(reqs.candyCorns)))
        for _,rItem in ipairs(reqs.required or {}) do table.insert(lines,string.format("%s: %s / %s",rItem:getName(),Functions.suffixes((findRawItem(data,rItem:getName())or{am=0}).am),Functions.suffixes(rItem:getAmount()))) end
        end; Library.Labels.RebirthStatus:SetText(table.concat(lines,"\n"))
    end); task.wait(3) end end)
    
    AutoRebirthToggle = HalloweenRebirthGroup:AddToggle('AutoRebirth', {
        Text = 'Auto Rebirth',
        Tooltip = 'WARNING: Resets Candy Corns. This will farm mobs for needed materials.',
        Default = false,
        Callback = function(enabled)
            if autoRebirthThread then task.cancel(autoRebirthThread); autoRebirthThread = nil end

            if enabled then
                originalAutoHitSettings = { selectedMobs = Options.SelectMobs.Value, autoHitState = Toggles.AutoHit.Value, EquipBestState = Toggles.AutoEquipBestSword.Value, HitSpeedState = Toggles.IncreaseSwordSpeed.Value }
                
                autoRebirthThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local playerData = DataController:getData()
                            local HalloweenRebirths = require(ReplicatedStorage.Shared.List.Halloween.HalloweenRebirths)
                            local currentRebirths = playerData.halloweenRebirths or 0
                            
                            local mobsToFarm = {}
                            local foundPriorityTarget = false

                            -- Find the EARLIEST future rebirth with missing UNIQUE materials
                            for tier = currentRebirths + 1, #HalloweenRebirths do
                                for _, reqItem in ipairs(HalloweenRebirths[tier].required or {}) do
                                    local itemName = reqItem:getName()
                                    -- Check if this item has a unique source
                                    if uniqueDropMap[itemName] then
                                        local playerAmount = (findRawItem(playerData, itemName) or {am=0}).am
                                        if playerAmount < reqItem:getAmount() then
                                            -- We have a deficit for a uniquely dropped item. This is our target.
                                            mobsToFarm[uniqueDropMap[itemName]] = true
                                            foundPriorityTarget = true
                                        end
                                    end
                                end
                                -- If we found any mobs to farm for this tier, stop looking at later tiers
                                if foundPriorityTarget then break end
                            end
                            
                            -- Update the Auto Hit UI based on our findings
                            local finalTargets = {}; for mobId in pairs(mobsToFarm) do table.insert(finalTargets, mobId) end
                            local newSelection = {}; if #finalTargets > 0 then
                                for _, mobIdValue in ipairs(Options.SelectMobs.Values) do
                                    for _, targetId in ipairs(finalTargets) do
                                        if mobIdValue:lower() == targetId:lower() then newSelection[mobIdValue] = true; break end
                                    end
                                end
                            end
                            Options.SelectMobs:SetValue(newSelection)
                            Toggles.AutoHit:SetValue(#finalTargets > 0)
                            Toggles.AutoEquipBestSword:SetValue(next(newSelection) ~= nil)
                            Toggles.IncreaseSwordSpeed:SetValue(next(newSelection) ~= nil)

                            -- Check if the CURRENT rebirth is affordable and execute
                            local currentRequirements = HalloweenRebirths[currentRebirths + 1]
                            if currentRequirements then
                                local canAfford = true
                                if (findRawItem(playerData, "candyCorns") or {am=0}).am < currentRequirements.candyCorns then canAfford = false end
                                for _, reqItem in ipairs(currentRequirements.required or {}) do
                                    if (findRawItem(playerData, reqItem:getName()) or {am=0}).am < reqItem:getAmount() then canAfford = false; break end
                                end
                                if canAfford then
                                    Knit.GetService("HalloweenService"):halloweenRebirth()
                                    task.wait(2)
                                end
                            end
                        end)
                        task.wait(3)
                    end
                end)
            else
                if originalAutoHitSettings then
                    Options.SelectMobs:SetValue(originalAutoHitSettings.selectedMobs)
                    Toggles.AutoHit:SetValue(originalAutoHitSettings.autoHitState)
                    Toggles.AutoEquipBestSword:SetValue(originalAutoHitSettings.EquipBestState)
                    Toggles.IncreaseSwordSpeed:SetValue(originalAutoHitSettings.HitSpeedState)
                    originalAutoHitSettings = nil
                end
            end
        end
    })
    
    -- Simulate "Boss Cave" Section
    local BossCaveGroup = Tabs.Halloween:AddLeftGroupbox('Boss Cave')

    local autoCaveThread, originalToggleStates = nil, nil
    
    local isEventStartingSoon = false
    local inCaveTimer = "N/A"

    -- Cave timer (dynamic Label)
    local caveTimerLabel = BossCaveGroup:AddLabel('Initializing...', true)
    Library.Labels.CaveTimer = caveTimerLabel

    -- Background task to read the in-game timer from the GUI
    task.spawn(function()
        local timerLabel = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainUI"):WaitForChild("HUD"):WaitForChild("Bars"):WaitForChild("BossCave"):WaitForChild("Timer")
        
        while true do
            pcall(function()
                local currentText = timerLabel.Text
                inCaveTimer = (currentText ~= "" and currentText) or "N/A"
                
                local cycle = (Knit.serverTimeNow - 3600) % 10800
                isEventStartingSoon = cycle <= 300
                local time = isEventStartingSoon and 300 - cycle or 10800 - cycle
                local status = isEventStartingSoon and "Starts in: %s" or "Opens in: %s"
                
                local statusText = status:format(Functions.formatTime(time)) .. "\nIn-Cave Time: " .. inCaveTimer
                Library.Labels.CaveTimer:SetText(statusText)
            end)
            task.wait(1)
        end
    end)

    BossCaveGroup:AddToggle('AutoJoinAndFight', {
        Text = 'Auto Join + Fight',
        Tooltip = 'Joins the cave and fights the mobs. Temporarily disables other farming mob toggles while in the cave.',
        Default = false,
        Callback = function(enabled)
            if autoCaveThread then task.cancel(autoCaveThread); autoCaveThread = nil end

            if enabled then
                originalToggleStates = {
                    autoRebirth = Toggles.AutoRebirth.Value, autoUpgrade = Toggles.AutoUpgradeSword.Value,
                    autoHitMobs = Toggles.AutoHit.Value, equipBest = Toggles.AutoEquipBestSword.Value, hitSpeed = Toggles.IncreaseSwordSpeed.Value
                }
                
                autoCaveThread = task.spawn(function()
                    local hasPausedOtherToggles = false
                    local currentTargetId = nil
                    
                    while enabled do
                        pcall(function()
                            local cycle = (Knit.serverTimeNow - 3600) % 10800

                            if isEventStartingSoon and cycle >= 270 and cycle <= 300 then
                                if not hasPausedOtherToggles then
                                    hasPausedOtherToggles = true; print("[Boss Cave] Event starting soon! Pausing other farming toggles.")
                                    task.defer(function() Toggles.AutoRebirth:SetValue(false); Toggles.AutoUpgradeSword:SetValue(false); Toggles.AutoHit:SetValue(false); Toggles.AutoEquipBestSword:SetValue(true); Toggles.IncreaseSwordSpeed:SetValue(true) end)
                                end
                                print("[Boss Cave] Attempting to join..."); Knit.GetService("BossCaveService"):joinBossCave(); task.wait(9);
                            
                            -- State 2: Fighting Phase
                            elseif inCaveTimer ~= "N/A" and inCaveTimer ~= "00:00" then
                                if not hasPausedOtherToggles then
                                    hasPausedOtherToggles = true; print("[Boss Cave] Detected inside cave. Pausing other farming toggles.")
                                    task.defer(function() Toggles.AutoRebirth:SetValue(false); Toggles.AutoUpgradeSword:SetValue(false); Toggles.AutoHit:SetValue(false); Toggles.AutoEquipBestSword:SetValue(true); Toggles.IncreaseSwordSpeed:SetValue(true) end)
                                end
                                
                                local isTargetValid=false; if currentTargetId then for _,m in ipairs(game:GetService("CollectionService"):GetTagged("bossCaveMob")) do if m:GetAttribute("mobId")==currentTargetId then isTargetValid=true; break end end end
                                if not isTargetValid then currentTargetId=nil; local all=game:GetService("CollectionService"):GetTagged("bossCaveMob"); if #all>0 then currentTargetId=all[1]:GetAttribute("mobId") end end
                                if currentTargetId then Knit.GetService("BossCaveService").damage._re:FireServer(currentTargetId) end
                            
                            -- State 3: Restoration Phase (The "else" for the conditions above)
                            elseif hasPausedOtherToggles then
                                if inCaveTimer == "00:00" then print("[Boss Cave] In-cave timer is 00:00. Re-enabling toggles (Attempt 1)...") else print("[Boss Cave] Event ended. Re-enabling toggles (Attempt 1)...") end
                                task.defer(function() Toggles.AutoRebirth:SetValue(originalToggleStates.autoRebirth); Toggles.AutoUpgradeSword:SetValue(originalToggleStates.autoUpgrade); Toggles.AutoHit:SetValue(originalToggleStates.autoHitMobs); Toggles.AutoEquipBestSword:SetValue(originalToggleStates.equipBest); Toggles.IncreaseSwordSpeed:SetValue(originalToggleStates.hitSpeed) end)
                                task.wait(1)
                                print("[Boss Cave] Re-enabling toggles (Attempt 2)...")
                                task.defer(function() Toggles.AutoRebirth:SetValue(originalToggleStates.autoRebirth); Toggles.AutoUpgradeSword:SetValue(originalToggleStates.autoUpgrade); Toggles.AutoHit:SetValue(originalToggleStates.autoHitMobs); Toggles.AutoEquipBestSword:SetValue(originalToggleStates.equipBest); Toggles.IncreaseSwordSpeed:SetValue(originalToggleStates.hitSpeed) end)
                                
                                hasPausedOtherToggles = false; currentTargetId = nil
                                print("[Boss Cave] Restoration complete.")
                            end
                        end)
                        task.wait(0.25)
                    end
                end)
            else
                if originalToggleStates then
                    print("[Boss Cave] Master toggle disabled. Restoring all original settings.")
                    task.defer(function()
                        Toggles.AutoRebirth:SetValue(originalToggleStates.autoRebirth); Toggles.AutoUpgradeSword:SetValue(originalToggleStates.autoUpgrade); Toggles.AutoHit:SetValue(originalToggleStates.autoHitMobs)
                        Toggles.AutoEquipBestSword:SetValue(originalToggleStates.equipBest); Toggles.IncreaseSwordSpeed:SetValue(originalToggleStates.hitSpeed); originalToggleStates = nil
                    end)
                end
            end
        end
    })


    BossCaveGroup:AddToggle('ClaimBossChest', {
        Text = 'Claim Boss Chest',
        Tooltip = 'Automatically claims the Boss Chest.',
        Default = false,
        Callback = function(enabled)
            local claimThread
            if claimThread then task.cancel(claimThread) end

            if enabled then
                claimThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            Knit.GetService("BossCaveService"):claimBossChest()
                        end)
                        task.wait(10)
                    end
                end)
            end
        end
    })


    -- Simulate "Forest Upgrades" Section
    local ForestUpgradesGroup = Tabs.Halloween:AddRightGroupbox('Forest Upgrades')

    local forestUpgradeNames, ForestUpgradesModule, forestAutoUpgradeThread = {}, nil, nil

    pcall(function()
        ForestUpgradesModule = require(ReplicatedStorage.Shared.List.Halloween.ForestUpgrades)
        for name, _ in pairs(ForestUpgradesModule) do table.insert(forestUpgradeNames, name) end
        table.sort(forestUpgradeNames)
    end)
    
    if #forestUpgradeNames > 0 then
        local upgradesDropdown = ForestUpgradesGroup:AddDropdown('ForestUpgradesDropdown', {
            Text = 'Select Forest Upgrades',
            Values = forestUpgradeNames,
            Multi = true,
            Callback = function(v) end  -- Value via Options.ForestUpgradesDropdown.Value
        })

        ForestUpgradesGroup:AddToggle('AutoUpgradeForest', {
            Text = 'Auto Upgrade',
            Tooltip = 'Automatically buys selected upgrades when you can afford them.',
            Default = false,
            Callback = function(enabled)
                if forestAutoUpgradeThread then task.cancel(forestAutoUpgradeThread); forestAutoUpgradeThread = nil end
                if enabled then
                    forestAutoUpgradeThread = task.spawn(function()
                        while enabled do
                            pcall(function()
                                local selectedUpgrades = Options.ForestUpgradesDropdown.Value
                                if not next(selectedUpgrades) then return end
                                local playerData = DataController:getData()
                                for upgradeName, isSelected in pairs(selectedUpgrades) do
                                    if not enabled then break end
                                    if isSelected then
                                        local currentLevel = (playerData.forestUpgrades and playerData.forestUpgrades[upgradeName]) or 0
                                        local upgradeInfo = ForestUpgradesModule[upgradeName]
                                        local nextUpgradeData = upgradeInfo and upgradeInfo.upgrades and upgradeInfo.upgrades[currentLevel + 1]
                                        if nextUpgradeData then
                                            local cost = nextUpgradeData.cost
                                            local playerItem = Util.itemUtils.getItemFromName(playerData, cost:getName())
                                            local playerAmount = playerItem and playerItem:getAmount() or 0
                                            if playerAmount >= cost:getAmount() then
                                                UpgradeService:upgradeForest(upgradeName)
                                                task.wait(1) 
                                            end
                                        end
                                    end
                                end
                            end)
                            task.wait(5) 
                        end
                    end)
                end
            end
        })
    end
    
    -- Final UI setup calls (adapted to LinoriaLib Save/Theme)
    ThemeManager:SetLibrary(Library)
    SaveManager:SetLibrary(Library)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetIgnoreIndexes({})
    ThemeManager:SetFolder("FluentScriptHub")  -- Kept as is
    SaveManager:SetFolder("FluentScriptHub/specific-game")
    SaveManager:BuildConfigSection(Tabs.Settings)
    ThemeManager:ApplyToTab(Tabs.Settings)
    SaveManager:LoadAutoloadConfig()
end

task.spawn(function()
    if not game:IsLoaded() then game.Loaded:Wait() end

    -- Initialize Knit and all necessary game services/controllers first
    Knit = require(ReplicatedStorage.Packages.Knit)
    Knit.OnStart():await()

    ClickService = Knit.GetService("ClickService")
    UpgradeService = Knit.GetService("UpgradeService")
    
    DataController = Knit.GetController("DataController")
    
    Functions = require(ReplicatedStorage.Shared.Functions)
    Util = require(ReplicatedStorage.Shared.Util)
    Values = require(ReplicatedStorage.Shared.Values)   

    -- Now that services are ready, build the UI
    BuildUI()
end)

local SolGrup = Tabs.Ana:AddLeftGroupbox('Auto Rebirth')

-- Rebirth Sayısını ayarlamak için bir Textbox ekliyoruz
SolGrup:AddInput('RebirthSayisiTextbox', {
    Default = '27',  -- Varsayılan olarak 27 yazıyor
    Text = 'Rebirth Sayısı',
    Placeholder = 'Yazınız...',
    Callback = function(v) 
        -- Burada Textbox içindeki değeri alıyoruz ve sayıya dönüştürüyoruz
        RebirthSayisi = tonumber(v) or 27  -- Eğer geçerli bir sayı değilse, varsayılan 27 kullanılır
        print("Rebirth Sayısı Ayarlandı:", RebirthSayisi)
    end
})

-- Auto-Rebirth Toggle'ı ekliyoruz
SolGrup:AddToggle('AutoRebirthToggle', {
    Text = 'Auto Rebirth (Sürekli)',
    Tooltip = 'Toggle açık olduğunda sürekli rebirth atılır.',
    Default = false,  -- Başlangıçta kapalı
    Callback = function(state) 
        -- Toggle açıldığında aktif olacak fonksiyon
        if state then
            -- Burada sürekli rebirth tetikleme işlemi başlatılır
            while Toggles.AutoRebirthToggle.Value do
                -- Event'i tetikleyerek rebirth işlemini başlatıyoruz
                local Event = game:GetService("ReplicatedStorage").Packages.Knit.Services:GetChildren()[6].RF["jag k\195\164nner en bot, hon heter anna, anna heter hon"]
                Event:InvokeServer(RebirthSayisi)
                wait(0.1)  -- Hızlı bir şekilde işlem yapılabilmesi için kısa bir bekleme süresi (0.1 saniye)
            end
        end
    end
})

-- Toggle'ın durumu değiştiğinde çalışacak fonksiyon (isteğe bağlı)
Toggles.AutoRebirthToggle:OnChanged(function()
    print("Auto Rebirth Toggle durumu:", Toggles.AutoRebirthToggle.Value)
end)
