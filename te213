-- LinoriaLib yÃ¼kleme
local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- KÄ±sa yollar
local Options = Library.Options
local Toggles = Library.Toggles

-- Orijinal script baÄŸÄ±mlÄ±lÄ±klarÄ± (deÄŸiÅŸtirilmedi)
local SaveManagerFluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/Pet-Warriors/refs/heads/main/test"))()
local InterfaceManagerFluent = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()
loadstring(game:HttpGet("https://raw.githubusercontent.com/SenhorLDS/ProjectLDSHUB/refs/heads/main/Anti%20AFK"))()

-- Roblox servisleri
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Knit ve oyun servisleri
local Knit, ClickService, UpgradeService, DataController, Functions, Util, Values

-- Global UI referanslarÄ±
local Window, Tabs

-- Hafif GC
spawn(function()
    while wait(30) do 
        pcall(function() collectgarbage("collect") end)
    end
end)

-- BuildUI: TÃ¼m Ã¶zellikleri Linoria groupbox/elementlerine taÅŸÄ±yoruz
BuildUI = function()
    -- Sekme ve grup tanÄ±mlarÄ±
    local HalloweenTab = Tabs.Halloween
    local PumpkinTab = Tabs.PumpkinHunt
    local SettingsTab = Tabs.Settings

    -- Halloween sekmesi; sol/saÄŸ grup kutularÄ±
    local Left = HalloweenTab:AddLeftGroupbox('Core & Hatch')
    local Right = HalloweenTab:AddRightGroupbox('Combat & Progress')

    -- Ek gruplar (Linoria dÃ¼zeni iÃ§in bÃ¶lÃ¼mlere daÄŸÄ±tÄ±m)
    local ShopBox = HalloweenTab:AddLeftGroupbox('Shop & Rewards')
    local ChestBox = HalloweenTab:AddLeftGroupbox('Cursed/Boss Cave')
    local ForestBox = HalloweenTab:AddRightGroupbox('Forest Upgrades')
    local PotBox = HalloweenTab:AddRightGroupbox('Monsters Pot')
    local WheelBox = HalloweenTab:AddLeftGroupbox('Halloween Wheel')
    local RebirthBox = HalloweenTab:AddRightGroupbox('Rebirth')

    -- DeÄŸiÅŸkenler
    local mobDropdown, AutoHitToggle, EquipBest, HitSpeed, AutoUpgradeSwordToggle, AutoRebirthToggle

    -- 1) Auto Click
    Left:AddToggle('AutoClick', {
        Text = 'Auto Click',
        Tooltip = 'Automatically clicks for you - Extremely fast!',
        Default = false,
        Callback = function(Value)
            AutoClicking = Value
            if Value then
                task.spawn(function()
                    while AutoClicking do
                        ClickService.click._re:FireServer()
                        task.wait(0.001)
                    end
                end)
            end
        end
    })

    -- 2) Auto Hatch (Halloween)
    local halloweenEggOptions = {}
    pcall(function()
        local eggFolder = Workspace.Game.Maps:FindFirstChild("0Halloween") and Workspace.Game.Maps["0Halloween"]:FindFirstChild("Eggs")
        if eggFolder then
            for _, eggModel in ipairs(eggFolder:GetChildren()) do table.insert(halloweenEggOptions, eggModel.Name) end
        end
    end)
    table.insert(halloweenEggOptions, "Spooky (Boss)")
    local selectedHalloweenEgg = halloweenEggOptions[1] or "Basic"

    Left:AddDivider()
    Left:AddLabel('Auto Hatch (Halloween)')

    Left:AddDropdown('SelectHalloweenEgg', {
        Values = halloweenEggOptions,
        Default = selectedHalloweenEgg,
        Multi = false,
        Text = 'Select Egg',
        Callback = function(value) selectedHalloweenEgg = value end
    })

    local halloweenHatchAmounts = {["1x"]=1, ["3x"]=3, ["Max"]=99}
    local selectedHalloweenAmount = halloweenHatchAmounts["Max"]
    Left:AddDropdown('SelectHalloweenHatchAmount', {
        Values = {"1x","3x","Max"},
        Default = "Max",
        Multi = false,
        Text = 'Select Hatch Amount',
        Callback = function(value) selectedHalloweenAmount = halloweenHatchAmounts[value] or 1 end
    })

    local useHalloweenLuckyEggs = false
    Left:AddToggle('UseHalloweenLuckyEggs', {
        Text = 'Use Lucky Eggs',
        Tooltip = "Does not apply to the 'Spooky (Boss)' egg.",
        Default = false,
        Callback = function(enabled) useHalloweenLuckyEggs = enabled end
    })

    if not _G.SmartHatchDelay then
        _G.SmartHatchDelay = 4.11
        task.spawn(function()
            local hatchTimeLabel = LocalPlayer.PlayerGui.MainUI.Menus.SettingsFrame.Main.List.Multipliers.HatchingSpeed.Main.Amount
            while true do
                pcall(function()
                    local numberString = string.match(hatchTimeLabel.Text, "%d+%.?%d*")
                    if numberString then _G.SmartHatchDelay = (tonumber(numberString) or 4.01) + 0.1 end
                end)
                task.wait(5)
            end
        end)
    end

    local autoHalloweenHatchThread
    Left:AddToggle('AutoHatchHalloween', {
        Text = 'Auto Hatch Event Eggs',
        Default = false,
        Callback = function(enabled)
            if autoHalloweenHatchThread then task.cancel(autoHalloweenHatchThread); autoHalloweenHatchThread = nil end
            if enabled then
                autoHalloweenHatchThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            if selectedHalloweenEgg == "Spooky (Boss)" then
                                Knit.GetService("EggService").openEgg._re:FireServer("Spooky", selectedHalloweenAmount, {isBossCave = true})
                            else
                                local args = {selectedHalloweenEgg, selectedHalloweenAmount}
                                if useHalloweenLuckyEggs then
                                    local anyAvailableLuckyId = next((Knit.GetController("EggController"))._luckyEggs or {})
                                    if anyAvailableLuckyId then table.insert(args, {luckyEggId = anyAvailableLuckyId}) end
                                end
                                Knit.GetService("EggService").openEgg._re:FireServer(unpack(args))
                            end
                        end)
                        task.wait(_G.SmartHatchDelay)
                    end
                end)
            end
        end
    })

    Left:AddToggle('HideHalloweenHatchAnimation', {
        Text = 'Hide Hatch Animation',
        Default = false,
        Callback = function(Value)
            local HatchingController = require(LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("Client"):WaitForChild("Controllers"):WaitForChild("HatchingController"))
            local function overrideFunctions(shouldHide)
                if not HatchingController._originalFunctions and shouldHide then
                    HatchingController._originalFunctions = {
                        playEggAnimation = HatchingController.playEggAnimation, playHatchingAnimation = HatchingController.playHatchingAnimation,
                        animatePetIn = HatchingController.animatePetIn, animatePetOut = HatchingController.animatePetOut,
                        dropEggs = HatchingController.dropEggs, shakeEggs = HatchingController.shakeEggs,
                        scaleAndRemoveEggs = HatchingController.scaleAndRemoveEggs, playRevealSounds = HatchingController.playRevealSounds
                    }
                end
                local emptyFunc = function() return nil end
                for funcName, originalFunc in pairs(HatchingController._originalFunctions or {}) do
                    HatchingController[funcName] = shouldHide and emptyFunc or originalFunc
                end
            end
            overrideFunctions(Value)
        end
    })

    -- 3) Mini Chests
    Left:AddDivider()
    Left:AddLabel('Mini Chests')

    local collectChestsThread
    Left:AddToggle('CollectMiniChests', {
        Text = 'Collect Mini Chests',
        Tooltip = 'Automatically collects the mini chests in the Halloween world (must be in Halloween map).',
        Default = false,
        Callback = function(enabled)
            if collectChestsThread then task.cancel(collectChestsThread); collectChestsThread = nil end
            if enabled then
                collectChestsThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local chestsFolder = Workspace.Game.Maps:FindFirstChild("0Halloween") 
                                and Workspace.Game.Maps["0Halloween"]:FindFirstChild("MiniChests")
                            if chestsFolder then
                                for _, chest in ipairs(chestsFolder:GetChildren()) do
                                    local touchPart = chest:FindFirstChild("Touch")
                                    local prompt = touchPart and touchPart:FindFirstChildOfClass("ProximityPrompt")
                                    if prompt and prompt.Enabled then
                                        fireproximityprompt(prompt)
                                        task.wait(2)
                                    end
                                end
                            end
                        end)
                        task.wait(5)
                    end
                end)
            end
        end
    })

    -- 4) Shop & Rewards
    ShopBox:AddLabel('Halloween Shop')

    local shopItemNames, shopItemMap, autoBuyShopThread = {}, {}, nil
    pcall(function()
        local HalloweenShopList = require(ReplicatedStorage.Shared.List.Halloween.HalloweenShop)
        local itemsToSort = {}
        for id, cost in pairs(HalloweenShopList) do
            local displayName = string.format("%s (Cost: %s)", id, Functions.suffixes(cost))
            table.insert(itemsToSort, { display = displayName, id = id, cost = cost })
            shopItemMap[displayName] = { id = id, cost = cost }
        end
        table.sort(itemsToSort, function(a, b) return a.cost < b.cost end)
        for _, itemData in ipairs(itemsToSort) do table.insert(shopItemNames, itemData.display) end
    end)

    local shopDropdown = ShopBox:AddDropdown('SelectShopItems', {
        Values = shopItemNames,
        Multi = true,
        Default = {},
        Text = 'Select Items to Auto Buy'
    })

    ShopBox:AddToggle('AutoBuyShopItems', {
        Text = 'Auto Buy',
        Tooltip = "Automatically buys selected items you don't own and can afford.",
        Default = false,
        Callback = function(enabled)
            if autoBuyShopThread then task.cancel(autoBuyShopThread); autoBuyShopThread = nil end
            if enabled then
                autoBuyShopThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local selectedItems = shopDropdown.Value
                            if not next(selectedItems) then return end
                            local playerData = DataController:getData()
                            local candyCornItem = Util.itemUtils.getItemFromName(playerData, "candyCorns")
                            local myCandyCorns = candyCornItem and candyCornItem:getAmount() or 0
                            local playerOwnedData = playerData.halloweenShop or {}
                            for displayName, isSelected in pairs(selectedItems) do
                                if isSelected then
                                    local shopData = shopItemMap[displayName]
                                    if not playerOwnedData[shopData.id] and myCandyCorns >= shopData.cost then
                                        Knit.GetService("HalloweenService"):buyShop(shopData.id)
                                        myCandyCorns = myCandyCorns - shopData.cost
                                        task.wait(1)
                                    end
                                end
                            end
                        end)
                        task.wait(5)
                    end
                end)
            end
        end
    })

    ShopBox:AddDivider()
    ShopBox:AddLabel('Halloween Rewards')

    local autoClaimRewardThread
    ShopBox:AddToggle('AutoClaimHalloweenReward', {
        Text = 'Auto Claim Halloween Rewards',
        Tooltip = 'Automatically claims rewards when you have Halloween Tickets.',
        Default = false,
        Callback = function(enabled)
            if autoClaimRewardThread then task.cancel(autoClaimRewardThread); autoClaimRewardThread = nil end
            if enabled then
                autoClaimRewardThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local playerData = DataController:getData()
                            if not playerData then return end
                            local halloweenTicketItem = Util.itemUtils.getItemFromName(playerData, "halloweenTicket")
                            local ticketAmount = halloweenTicketItem and halloweenTicketItem:getAmount() or 0
                            if ticketAmount > 0 then
                                Knit.GetService("HalloweenService"):claimHalloweenReward()
                            end
                        end)
                        task.wait(0.25)
                    end
                end)
            end
        end
    })

    -- 5) Cursed Chest
    ChestBox:AddLabel('Cursed Chest')
    local useOneKeyThread, useAllKeysThread = nil, nil

    ChestBox:AddToggle('AutoUseOneCursedKey', {
        Text = 'Use 1x Cursed Key',
        Tooltip = 'Uses one Cursed Key (every second).',
        Default = false,
        Callback = function(enabled)
            if useOneKeyThread then task.cancel(useOneKeyThread); useOneKeyThread = nil end
            if enabled then
                useOneKeyThread = task.spawn(function()
                    while enabled do
                        pcall(function() Knit.GetService("HalloweenService"):cursedChest() end)
                        task.wait(1)
                    end
                end)
            end
        end
    })

    ChestBox:AddToggle('AutoUseAllCursedKeys', {
        Text = 'Use All Cursed Keys',
        Tooltip = 'Uses all available Cursed Keys every 5 seconds.',
        Default = false,
        Callback = function(enabled)
            if useAllKeysThread then task.cancel(useAllKeysThread); useAllKeysThread = nil end
            if enabled then
                useAllKeysThread = task.spawn(function()
                    while enabled do
                        pcall(function() Knit.GetService("HalloweenService"):cursedChest(true) end)
                        task.wait(5)
                    end
                end)
            end
        end
    })

    -- 6) Halloween Mobs (Combat)
    Right:AddLabel('Halloween Mobs')

    local mobNames, MobsModule, autoHitThread = {}, nil, nil
    pcall(function()
        MobsModule = require(ReplicatedStorage.Shared.List.Halloween.Mobs)
        for id, _ in pairs(MobsModule) do table.insert(mobNames, id) end
        table.sort(mobNames)
    end)

    mobDropdown = Right:AddDropdown('SelectMobs', {
        Values = mobNames,
        Multi = true,
        Default = {},
        Text = 'Select Mobs to Target'
    })

    AutoHitToggle = Right:AddToggle('AutoHit', {
        Text = 'Auto Kill Mobs',
        Tooltip = 'Kills selected mobs. If none available, picks by your weapon damage.',
        Default = false,
        Callback = function(enabled)
            if autoHitThread then task.cancel(autoHitThread); autoHitThread = nil end
            if enabled then
                autoHitThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local selectedMobTypes = mobDropdown.Value
                            local playerData = DataController:getData()
                            local activeMobs = playerData and playerData.mobs
                            if not activeMobs or not next(activeMobs) then return end

                            local availableTypes = {}
                            for instanceId, mobData in pairs(activeMobs) do
                                if selectedMobTypes[mobData.mobId] then
                                    local mobId = mobData.mobId
                                    availableTypes[mobId] = availableTypes[mobId] or {}
                                    if MobsModule[mobId] then
                                        table.insert(availableTypes[mobId], { id = instanceId, health = MobsModule[mobId].hp - (mobData.damage or 0) })
                                    end
                                end
                            end

                            local target
                            local typeKeys = {}; for typeName in pairs(availableTypes) do table.insert(typeKeys, typeName) end
                            if #typeKeys > 0 then
                                local chosenTypeName = typeKeys[math.random(1, #typeKeys)]
                                local mobsOfChosenType = availableTypes[chosenTypeName]
                                local lowestHealth = math.huge
                                for _, mob in ipairs(mobsOfChosenType) do if mob.health < lowestHealth then lowestHealth = mob.health end end
                                local weakestTies = {}; for _, mob in ipairs(mobsOfChosenType) do if mob.health == lowestHealth then table.insert(weakestTies, mob) end end
                                if #weakestTies > 0 then target = weakestTies[math.random(1, #weakestTies)] end
                            else
                                local HalloweenItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                                local bestSwordInfo, bestIndex = nil, -1
                                for _, itemData in pairs(playerData.inventory.halloweenEvent or {}) do
                                    local itemStats = HalloweenItems[itemData.nm]
                                    if itemStats and itemStats.index and itemStats.index > bestIndex then bestIndex, bestSwordInfo = itemStats.index, itemStats end
                                end
                                if bestSwordInfo then
                                    local damageLimit = bestSwordInfo.multiplier * 25
                                    local viableTargets = {}
                                    for instanceId, mobData in pairs(activeMobs) do
                                        local mobStats = MobsModule[mobData.mobId]
                                        if mobStats and mobStats.hp <= damageLimit then
                                            table.insert(viableTargets, { id = instanceId, name = mobData.mobId, health = mobStats.hp - (mobData.damage or 0) })
                                        end
                                    end
                                    if #viableTargets > 0 then
                                        table.sort(viableTargets, function(a, b) return a.health > b.health end)
                                        target = viableTargets[1]
                                    end
                                end
                                if not target then
                                    local lowestHealth = math.huge
                                    for instanceId, mobData in pairs(activeMobs) do
                                        local mobStats = MobsModule[mobData.mobId]
                                        if mobStats then
                                            local currentHealth = mobStats.hp - (mobData.damage or 0)
                                            if currentHealth < lowestHealth then
                                                lowestHealth, target = currentHealth, {id = instanceId, name = mobData.mobId, health = currentHealth}
                                            end
                                        end
                                    end
                                end
                            end

                            if target and target.id then
                                Knit.GetService("HalloweenService").damage._re:FireServer(target.id)
                            end
                        end)
                        task.wait(0.25)
                    end
                end)
            end
        end
    })

    local originalWeaponSpeed = Values.weaponSpeed
    HitSpeed = Right:AddToggle('IncreaseSwordSpeed', {
        Text = 'Increase Sword Speed',
        Tooltip = 'Makes your sword swing much faster; best when hitting manually.',
        Default = false,
        Callback = function(Value)
            if Value then
                Values.weaponSpeed = function(...) return originalWeaponSpeed(...) / 10 end
            else
                Values.weaponSpeed = originalWeaponSpeed
            end
        end
    })

    local isAutoEquipSwordEnabled = false
    EquipBest = Right:AddToggle('AutoEquipBestSword', {
        Text = 'Auto Equip Best Sword',
        Tooltip = 'Automatically equips the best Halloween sword you own.',
        Default = false,
        Callback = function(enabled)
            isAutoEquipSwordEnabled = enabled
            if enabled then
                task.spawn(function()
                    while isAutoEquipSwordEnabled do
                        pcall(function()
                            local HalloweenEventItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                            local playerData = DataController:getData()
                            if not playerData.inventory or not playerData.inventory.halloweenEvent then return end
                            local bestSwordIndex = -1
                            local bestInventoryId = nil
                            for inventoryId, itemData in pairs(playerData.inventory.halloweenEvent) do
                                local itemStats = HalloweenEventItems[itemData.nm]
                                if itemStats and itemStats.index and (itemData.nm:lower():find("sword") or itemData.nm:lower():find("blade")) then
                                    if itemStats.index > bestSwordIndex then
                                        bestSwordIndex = itemStats.index
                                        bestInventoryId = inventoryId
                                    end
                                end
                            end
                            if not bestInventoryId then return end
                            if not playerData.isHalloweenWeaponEquipped then
                                Knit.GetService("InventoryService"):useItem(bestInventoryId)
                            else
                                local currentInventoryId = nil
                                for inventoryId, itemData in pairs(playerData.inventory.halloweenEvent) do
                                    if itemData.nm and (itemData.nm:lower():find("sword") or itemData.nm:lower():find("blade")) then
                                        currentInventoryId = inventoryId
                                        break
                                    end
                                end
                                if currentInventoryId ~= bestInventoryId then
                                    Knit.GetService("InventoryService"):useItem(bestInventoryId)
                                end
                            end
                        end)
                        task.wait(5)
                    end
                end)
            end
        end
    })

    -- 7) Sword Upgrades
    Right:AddDivider()
    Right:AddLabel('Sword Upgrades')

    local function findRawItem(playerData, itemName)
        if not playerData or not playerData.inventory then return nil end
        for category, items in pairs(playerData.inventory) do
            if type(items) == "table" then
                for _, data in pairs(items) do
                    if type(data) == "table" and data.nm == itemName then return data end
                end
            end
        end
        return nil
    end

    local function generateItemSourceMap()
        local sources = {}
        local mobs = require(ReplicatedStorage.Shared.List.Halloween.Mobs)
        for mobId, mobData in pairs(mobs) do
            for _, reward in ipairs(mobData.rewards or {}) do
                if reward.item and reward.item.nm then
                    sources[reward.item.nm] = sources[reward.item.nm] or {}
                    table.insert(sources[reward.item.nm], mobId)
                end
            end
        end
        return sources
    end
    local itemSourceMap = generateItemSourceMap()

    -- Paragraph -> indeksli label
    Right:AddLabel('UpgradeProgress', true, 'UpgradeStatus')
    Library.Labels.UpgradeStatus:SetText('Loading...')

    task.spawn(function()
        while true do
            pcall(function()
                local playerData = DataController:getData()
                if not playerData then return end
                local HalloweenItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                local WeaponUpgrader = require(ReplicatedStorage.Shared.List.Halloween.WeaponUpgrader)
                local currentWeaponIndex, currentWeaponName = -1, "None"
                for _, itemData in pairs(playerData.inventory.halloweenEvent or {}) do
                    local itemStats = HalloweenItems[itemData.nm]
                    if itemStats and itemStats.index and itemStats.index > currentWeaponIndex then
                        currentWeaponIndex = itemStats.index
                        currentWeaponName = itemStats.name
                    end
                end
                local nextWeaponName = nil
                for name, data in pairs(HalloweenItems) do
                    if data.index and data.index == currentWeaponIndex + 1 then nextWeaponName = name; break end
                end
                local contentLines = {"Current: " .. currentWeaponName}
                if not nextWeaponName then
                    table.insert(contentLines, "\nðŸŽ‰ You have the BEST weapon!")
                else
                    local recipe = WeaponUpgrader[nextWeaponName]
                    table.insert(contentLines, "Next: " .. HalloweenItems[nextWeaponName].name .. "\n")
                    for _, reqItem in ipairs(recipe.required) do
                        local itemName = reqItem:getName()
                        local needed = reqItem:getAmount()
                        local current = (findRawItem(playerData, itemName) or {am=0}).am
                        local status = (current >= needed) and "âœ…" or "âŒ"
                        table.insert(contentLines, string.format("%s %s: %s / %s", status, itemName, Functions.suffixes(current), Functions.suffixes(needed)))
                    end
                end
                Library.Labels.UpgradeStatus:SetText(table.concat(contentLines, "\n"))
            end)
            task.wait(1)
        end
    end)

    local autoUpgradeSwordThread, originalAutoHitSettingsSword
    AutoUpgradeSwordToggle = Right:AddToggle('AutoUpgradeSword', {
        Text = 'Auto Upgrade Sword',
        Tooltip = 'Automatically upgrades your sword and farms only the necessary materials.',
        Default = false,
        Callback = function(enabled)
            if autoUpgradeSwordThread then task.cancel(autoUpgradeSwordThread); autoUpgradeSwordThread = nil end
            if enabled then
                originalAutoHitSettingsSword = { selectedMobs = mobDropdown.Value, autoHitState = AutoHitToggle.Value, EquipBestState = EquipBest.Value, HitSpeedState = HitSpeed.Value }
                autoUpgradeSwordThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local playerData = DataController:getData()
                            local HalloweenItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                            local WeaponUpgrader = require(ReplicatedStorage.Shared.List.Halloween.WeaponUpgrader)
                            local MModule = require(ReplicatedStorage.Shared.List.Halloween.Mobs)

                            local currentWeaponIndex = -1
                            for _, itemData in pairs(playerData.inventory.halloweenEvent or {}) do
                                local itemStats = HalloweenItems[itemData.nm]
                                if itemStats and itemStats.index and itemStats.index > currentWeaponIndex then currentWeaponIndex = itemStats.index end
                            end
                            local nextWeaponName = nil
                            for name, data in pairs(HalloweenItems) do
                                if data.index and data.index == currentWeaponIndex + 1 then nextWeaponName = name; break end
                            end
                            if not nextWeaponName then
                                AutoHitToggle:SetValue(false)
                                return
                            end

                            local canAfford, missingMaterials, isMissingCandy = true, {}, false
                            for _, reqItem in ipairs(WeaponUpgrader[nextWeaponName].required) do
                                local itemName, needed = reqItem:getName(), reqItem:getAmount()
                                if (findRawItem(playerData, itemName) or {am=0}).am < needed then
                                    canAfford = false
                                    if itemName == "candyCorns" then isMissingCandy = true else table.insert(missingMaterials, itemName) end
                                end
                            end

                            if canAfford then
                                Knit.GetService("HalloweenWeaponService"):upgradeWeapon()
                                task.wait(2)
                            else
                                local mobsToFarm = {}
                                if #missingMaterials > 0 then
                                    for _, material in ipairs(missingMaterials) do
                                        if itemSourceMap[material] then
                                            for _, mobId in ipairs(itemSourceMap[material]) do
                                                mobsToFarm[mobId:lower()] = true
                                            end
                                        end
                                    end
                                elseif isMissingCandy then
                                    local bestSwordInfo, bestIndex = nil, -1
                                    for _, itemData in pairs(playerData.inventory.halloweenEvent) do
                                        local itemStats = HalloweenItems[itemData.nm]
                                        if itemStats and itemStats.index and itemStats.index > bestIndex then bestIndex, bestSwordInfo = itemStats.index, itemStats end
                                    end
                                    if bestSwordInfo then
                                        local damageLimit = bestSwordInfo.multiplier * 25
                                        local viableTargets = {}
                                        for mobId, mobData in pairs(MModule) do
                                            if mobData.hp <= damageLimit then table.insert(viableTargets, {id = mobId, data = mobData}) end
                                        end
                                        if #viableTargets > 0 then
                                            table.sort(viableTargets, function(a,b) return a.data.hp > b.data.hp end)
                                            mobsToFarm[viableTargets[1].id:lower()] = true
                                        end
                                    end
                                end

                                local newSelection = {}
                                for mobId, _ in pairs(mobsToFarm) do
                                    for _, mobValue in ipairs(mobDropdown.Values) do
                                        if mobValue:lower() == mobId:lower() then newSelection[mobValue] = true end
                                    end
                                end
                                mobDropdown:SetValue(newSelection)
                                HitSpeed:SetValue(next(newSelection) ~= nil)
                                EquipBest:SetValue(next(newSelection) ~= nil)
                                AutoHitToggle:SetValue(next(newSelection) ~= nil)
                            end
                        end)
                        task.wait(2)
                    end
                end)
            else
                if originalAutoHitSettingsSword then
                    mobDropdown:SetValue(originalAutoHitSettingsSword.selectedMobs)
                    AutoHitToggle:SetValue(originalAutoHitSettingsSword.autoHitState)
                    EquipBest:SetValue(originalAutoHitSettingsSword.EquipBestState)
                    HitSpeed:SetValue(originalAutoHitSettingsSword.HitSpeedState)
                    originalAutoHitSettingsSword = nil
                end
            end
        end
    })

    -- 8) Monsters Pot
    PotBox:AddLabel('Monsters Pot')

    local potOptions, potOptionMap, selectedPotOptionIndex = {}, {}, 1
    pcall(function()
        local MonstersPotList = require(ReplicatedStorage.Shared.List.Halloween.MonstersPot)
        for i, data in ipairs(MonstersPotList) do
            if data.required and #data.required > 0 then
                local reqItem = data.required[1]
                local displayName = string.format("%s - %dx", reqItem.nm, reqItem.am)
                table.insert(potOptions, displayName)
                potOptionMap[displayName] = { index = i, reqName = reqItem.nm, reqAmount = reqItem.am }
            end
        end
    end)

    PotBox:AddDropdown('SelectPotItems', {
        Values = potOptions,
        Default = potOptions[1],
        Text = 'Select Mob Items',
        Callback = function(value)
            for i, name in ipairs(potOptions) do
                if name == value then selectedPotOptionIndex = i; break end
            end
        end
    })

    local craftAmountInput = PotBox:AddInput('CraftAmount', {
        Default = '1',
        Numeric = true,
        Text = 'Amount',
        Callback = function() end
    })

    PotBox:AddButton('Exchange Items (Amount)', function()
        local amount = tonumber(Options.CraftAmount.Value) or 1
        if amount > 0 then
            Knit.GetService("HalloweenService"):monstersPot(selectedPotOptionIndex, amount)
        end
    end)

    local autoExchangeAllThread
    PotBox:AddToggle('ExchangeAll', {
        Text = 'Exchange All',
        Tooltip = 'Crafts max possible for selected item continuously.',
        Default = false,
        Callback = function(enabled)
            if autoExchangeAllThread then task.cancel(autoExchangeAllThread); autoExchangeAllThread = nil end
            if enabled then
                autoExchangeAllThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local currentSelectionName = potOptions[selectedPotOptionIndex]
                            local selectionData = potOptionMap[currentSelectionName]
                            if selectionData then
                                local playerData = DataController:getData()
                                local playerItemAmount = 0
                                if playerData.inventory and playerData.inventory.halloweenEvent then
                                    for _, inventoryItemData in pairs(playerData.inventory.halloweenEvent) do
                                        if inventoryItemData.nm == selectionData.reqName then
                                            playerItemAmount = inventoryItemData.am or 0
                                            break
                                        end
                                    end
                                end
                                local maxCraftable = 0
                                if selectionData.reqAmount > 0 then
                                    maxCraftable = math.floor(playerItemAmount / selectionData.reqAmount)
                                end
                                if maxCraftable > 0 then
                                    Knit.GetService("HalloweenService"):monstersPot(selectedPotOptionIndex, maxCraftable)
                                    task.wait(1)
                                end
                            end
                        end)
                        task.wait(3)
                    end
                end)
            end
        end
    })

    -- 9) Wheel
    WheelBox:AddLabel('Halloween Wheel')
    local selectedWheelTier = 1
    WheelBox:AddDropdown('SelectWheelTier', {
        Values = {1,2,3,4},
        Default = selectedWheelTier,
        Text = 'Select Tier',
        Callback = function(value) selectedWheelTier = value end
    })

    local autoSpinThread
    WheelBox:AddToggle('AutoSpinWheel', {
        Text = 'Auto Spin Wheel',
        Default = false,
        Callback = function(enabled)
            if autoSpinThread then task.cancel(autoSpinThread); autoSpinThread = nil end
            if enabled then
                autoSpinThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            Knit.GetService("HalloweenService"):halloweenWheelSpin(selectedWheelTier)
                        end)
                        task.wait(0.5)
                    end
                end)
            end
        end
    })

    -- 10) Rebirth
    RebirthBox:AddLabel('Halloween Rebirth')

    local function generateUniqueDropMap()
        local uniqueMap = {}
        pcall(function()
            local mobs = require(ReplicatedStorage.Shared.List.Halloween.Mobs)
            local itemSources = {}
            for mobId, mobData in pairs(mobs) do
                for _, reward in ipairs(mobData.rewards or {}) do
                    if reward.item and reward.item.nm then
                        itemSources[reward.item.nm] = itemSources[reward.item.nm] or {}
                        table.insert(itemSources[reward.item.nm], mobId)
                    end
                end
            end
            for itemName, sources in pairs(itemSources) do
                if #sources == 1 then uniqueMap[itemName] = sources[1] end
            end
        end)
        return uniqueMap
    end
    local uniqueDropMap = generateUniqueDropMap()

    local function findRawItem2(playerData, itemName)
        if not playerData or not playerData.inventory then return nil end
        for _, items in pairs(playerData.inventory) do
            if type(items) == "table" then
                for _, data in pairs(items) do
                    if type(data) == "table" and data.nm == itemName then return data end
                end
            end
        end
        return nil
    end

    RebirthBox:AddLabel('Next Rebirth Progress', true, 'RebirthStatus')
    Library.Labels.RebirthStatus:SetText('Loading...')

    task.spawn(function()
        while true do
            pcall(function()
                local data = DataController:getData(); if not data then return end
                local list = require(ReplicatedStorage.Shared.List.Halloween.HalloweenRebirths)
                local cur = data.halloweenRebirths or 0; local nxt = cur + 1; local reqs = list[nxt]
                local lines = {"Current Rebirths: "..cur}
                if not reqs then
                    table.insert(lines, "\nðŸŽ‰ MAXIMUM REBIRTH LEVEL!")
                else
                    table.insert(lines, "Target: Rebirth "..nxt.."\n")
                    table.insert(lines, string.format("Candy Corns: %s / %s", Functions.suffixes((findRawItem2(data,"candyCorns")or{am=0}).am), Functions.suffixes(reqs.candyCorns)))
                    for _, rItem in ipairs(reqs.required or {}) do
                        table.insert(lines, string.format("%s: %s / %s", rItem:getName(), Functions.suffixes((findRawItem2(data, rItem:getName())or{am=0}).am), Functions.suffixes(rItem:getAmount())))
                    end
                end
                Library.Labels.RebirthStatus:SetText(table.concat(lines, "\n"))
            end)
            task.wait(3)
        end
    end)

    local autoRebirthThread, originalAutoHitSettingsRebirth
    AutoRebirthToggle = RebirthBox:AddToggle('AutoRebirth', {
        Text = 'Auto Rebirth',
        Tooltip = 'WARNING: Resets Candy Corns. Farms mobs for needed materials.',
        Default = false,
        Callback = function(enabled)
            if autoRebirthThread then task.cancel(autoRebirthThread); autoRebirthThread = nil end
            if enabled then
                originalAutoHitSettingsRebirth = { selectedMobs = mobDropdown.Value, autoHitState = AutoHitToggle.Value, EquipBestState = EquipBest.Value, HitSpeedState = HitSpeed.Value }
                autoRebirthThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local playerData = DataController:getData()
                            local HalloweenRebirths = require(ReplicatedStorage.Shared.List.Halloween.HalloweenRebirths)
                            local currentRebirths = playerData.halloweenRebirths or 0
                            local mobsToFarm = {}
                            local foundPriorityTarget = false

                            for tier = currentRebirths + 1, #HalloweenRebirths do
                                for _, reqItem in ipairs(HalloweenRebirths[tier].required or {}) do
                                    local itemName = reqItem:getName()
                                    if uniqueDropMap[itemName] then
                                        local playerAmount = (findRawItem2(playerData, itemName) or {am=0}).am
                                        if playerAmount < reqItem:getAmount() then
                                            mobsToFarm[uniqueDropMap[itemName]] = true
                                            foundPriorityTarget = true
                                        end
                                    end
                                end
                                if foundPriorityTarget then break end
                            end

                            local finalTargets = {}; for mobId in pairs(mobsToFarm) do table.insert(finalTargets, mobId) end
                            local newSelection = {}
                            if #finalTargets > 0 then
                                for _, mobIdValue in ipairs(mobDropdown.Values) do
                                    for _, targetId in ipairs(finalTargets) do
                                        if mobIdValue:lower() == targetId:lower() then newSelection[mobIdValue] = true; break end
                                    end
                                end
                            end
                            mobDropdown:SetValue(newSelection)
                            AutoHitToggle:SetValue(#finalTargets > 0)
                            EquipBest:SetValue(next(newSelection) ~= nil)
                            HitSpeed:SetValue(next(newSelection) ~= nil)

                            local currentRequirements = HalloweenRebirths[currentRebirths + 1]
                            if currentRequirements then
                                local canAfford = true
                                if (findRawItem2(playerData, "candyCorns") or {am=0}).am < currentRequirements.candyCorns then canAfford = false end
                                for _, reqItem in ipairs(currentRequirements.required or {}) do
                                    if (findRawItem2(playerData, reqItem:getName()) or {am=0}).am < reqItem:getAmount() then canAfford = false; break end
                                end
                                if canAfford then
                                    Knit.GetService("HalloweenService"):halloweenRebirth()
                                    task.wait(2)
                                end
                            end
                        end)
                        task.wait(3)
                    end
                end)
            else
                if originalAutoHitSettingsRebirth then
                    mobDropdown:SetValue(originalAutoHitSettingsRebirth.selectedMobs)
                    AutoHitToggle:SetValue(originalAutoHitSettingsRebirth.autoHitState)
                    EquipBest:SetValue(originalAutoHitSettingsRebirth.EquipBestState)
                    HitSpeed:SetValue(originalAutoHitSettingsRebirth.HitSpeedState)
                    originalAutoHitSettingsRebirth = nil
                end
            end
        end
    })

    -- 11) Boss Cave
    ChestBox:AddDivider()
    ChestBox:AddLabel('Boss Cave')

    local autoCaveThread, originalToggleStates = nil, nil
    local isEventStartingSoon = false
    local inCaveTimer = "N/A"

    ChestBox:AddLabel('Boss Cave Status', true, 'CaveTimer')
    Library.Labels.CaveTimer:SetText('Initializing...')

    task.spawn(function()
        local timerLabel = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainUI"):WaitForChild("HUD"):WaitForChild("Bars"):WaitForChild("BossCave"):WaitForChild("Timer")
        while true do
            pcall(function()
                local currentText = timerLabel.Text
                inCaveTimer = (currentText ~= "" and currentText) or "N/A"
                local cycle = (Knit.serverTimeNow - 3600) % 10800
                isEventStartingSoon = cycle <= 300
                local time = isEventStartingSoon and 300 - cycle or 10800 - cycle
                local status = isEventStartingSoon and "Starts in: %s" or "Opens in: %s"
                local statusText = status:format(Functions.formatTime(time)) .. "\nIn-Cave Time: " .. inCaveTimer
                Library.Labels.CaveTimer:SetText(statusText)
            end)
            task.wait(1)
        end
    end)

    ChestBox:AddToggle('AutoJoinAndFight', {
        Text = 'Auto Join + Fight',
        Tooltip = 'Joins the cave and fights. Temporarily disables other mob farm toggles.',
        Default = false,
        Callback = function(enabled)
            if autoCaveThread then task.cancel(autoCaveThread); autoCaveThread = nil end
            if enabled then
                autoCaveThread = task.spawn(function()
                    local hasPausedOtherToggles = false
                    local currentTargetId = nil
                    while task.wait(0.25) do
                        pcall(function()
                            local cycle = (Knit.serverTimeNow - 3600) % 10800
                            local isJoiningTime = isEventStartingSoon and cycle >= 270 and cycle <= 300
                            local isInCave = inCaveTimer ~= "N/A" and inCaveTimer ~= "00:00"
                            if isJoiningTime or isInCave then
                                if not hasPausedOtherToggles then
                                    hasPausedOtherToggles = true
                                    originalToggleStates = {
                                        autoRebirth = AutoRebirthToggle.Value, autoUpgrade = AutoUpgradeSwordToggle.Value,
                                        autoHitMobs = AutoHitToggle.Value, equipBest = EquipBest.Value, hitSpeed = HitSpeed.Value,
                                    }
                                    task.defer(function()
                                        AutoRebirthToggle:SetValue(false)
                                        AutoUpgradeSwordToggle:SetValue(false)
                                        AutoHitToggle:SetValue(false)
                                        EquipBest:SetValue(true)
                                        HitSpeed:SetValue(true)
                                    end)
                                end
                                if isJoiningTime then
                                    Knit.GetService("BossCaveService"):joinBossCave()
                                    task.wait(9)
                                end
                                if isInCave then
                                    local isTargetValid = false
                                    if currentTargetId then
                                        for _, mob in ipairs(game:GetService("CollectionService"):GetTagged("bossCaveMob")) do
                                            if mob:GetAttribute("mobId") == currentTargetId then
                                                isTargetValid = true
                                                break
                                            end
                                        end
                                    end
                                    if not isTargetValid then
                                        currentTargetId = nil
                                        local allMobs = game:GetService("CollectionService"):GetTagged("bossCaveMob")
                                        if #allMobs > 0 then currentTargetId = allMobs[1]:GetAttribute("mobId") end
                                    end
                                    if currentTargetId then
                                        Knit.GetService("BossCaveService").damage._re:FireServer(currentTargetId)
                                    end
                                end
                            elseif hasPausedOtherToggles then
                                if originalToggleStates then
                                    task.defer(function()
                                        AutoRebirthToggle:SetValue(originalToggleStates.autoRebirth)
                                        AutoUpgradeSwordToggle:SetValue(originalToggleStates.autoUpgrade)
                                        AutoHitToggle:SetValue(originalToggleStates.autoHitMobs)
                                        EquipBest:SetValue(originalToggleStates.equipBest)
                                        HitSpeed:SetValue(originalToggleStates.hitSpeed)
                                    end)
                                end
                                hasPausedOtherToggles = false
                                currentTargetId = nil
                            end
                        end)
                    end
                end)
            else
                if originalToggleStates then
                    task.defer(function()
                        AutoRebirthToggle:SetValue(originalToggleStates.autoRebirth)
                        AutoUpgradeSwordToggle:SetValue(originalToggleStates.autoUpgrade)
                        AutoHitToggle:SetValue(originalToggleStates.autoHitMobs)
                        EquipBest:SetValue(originalToggleStates.equipBest)
                        HitSpeed:SetValue(originalToggleStates.hitSpeed)
                    end)
                    originalToggleStates = nil
                end
            end
        end
    })

    ChestBox:AddToggle('ClaimBossChest', {
        Text = 'Claim Boss Chest',
        Tooltip = 'Automatically claims the Boss Chest.',
        Default = false,
        Callback = function(enabled)
            local claimThread
            if claimThread then task.cancel(claimThread) end
            if enabled then
                claimThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            Knit.GetService("BossCaveService"):claimBossChest()
                        end)
                        task.wait(10)
                    end
                end)
            end
        end
    })

    -- 12) Forest Upgrades
    local forestUpgradeNames, ForestUpgradesModule, forestAutoUpgradeThread = {}, nil, nil
    pcall(function()
        ForestUpgradesModule = require(ReplicatedStorage.Shared.List.Halloween.ForestUpgrades)
        for name, _ in pairs(ForestUpgradesModule) do table.insert(forestUpgradeNames, name) end
        table.sort(forestUpgradeNames)
    end)

    if #forestUpgradeNames > 0 then
        local upgradesDropdown = ForestBox:AddDropdown('ForestUpgradesDropdown', {
            Values = forestUpgradeNames,
            Multi = true,
            Default = {},
            Text = 'Select Forest Upgrades'
        })

        ForestBox:AddToggle('AutoUpgradeForest', {
            Text = 'Auto Upgrade',
            Tooltip = 'Automatically buys selected upgrades when affordable.',
            Default = false,
            Callback = function(enabled)
                if forestAutoUpgradeThread then task.cancel(forestAutoUpgradeThread); forestAutoUpgradeThread = nil end
                if enabled then
                    forestAutoUpgradeThread = task.spawn(function()
                        while enabled do
                            pcall(function()
                                local selectedUpgrades = upgradesDropdown.Value
                                if not next(selectedUpgrades) then return end
                                local playerData = DataController:getData()
                                for upgradeName, isSelected in pairs(selectedUpgrades) do
                                    if not enabled then break end
                                    if isSelected then
                                        local currentLevel = (playerData.forestUpgrades and playerData.forestUpgrades[upgradeName]) or 0
                                        local upgradeInfo = ForestUpgradesModule[upgradeName]
                                        local nextUpgradeData = upgradeInfo and upgradeInfo.upgrades and upgradeInfo.upgrades[currentLevel + 1]
                                        if nextUpgradeData then
                                            local cost = nextUpgradeData.cost
                                            local playerItem = Util.itemUtils.getItemFromName(playerData, cost:getName())
                                            local playerAmount = playerItem and playerItem:getAmount() or 0
                                            if playerAmount >= cost:getAmount() then
                                                UpgradeService:upgradeForest(upgradeName)
                                                task.wait(1)
                                            end
                                        end
                                    end
                                end
                            end)
                            task.wait(5)
                        end
                    end)
                end
            end
        })
    end

    -- Pumpkin Hunt tab
    local PumpkinSection = PumpkinTab:AddLeftGroupbox('Pumpkin Hunt')

    PumpkinSection:AddButton('Claim All Hints & Some Pumpkins', function()
        task.spawn(function()
            local HalloweenService = Knit.GetService("HalloweenService")
            local CodesService = Knit.GetService("CodesService")
            local PumpkinHuntData = require(ReplicatedStorage.Shared.List.Halloween.PumpkinHunt)
            for pumpkinId, data in pairs(PumpkinHuntData) do
                if data.hints then
                    for hintId, hintData in pairs(data.hints) do
                        if hintData.isFindable then
                            HalloweenService:claimPumpkinHuntHint(pumpkinId, hintId)
                            task.wait(0.1)
                        end
                    end
                end
            end
            CodesService:redeem("13"); task.wait(0.2)
            CodesService:redeem("9X7M2KQ5RD"); task.wait(0.2)
            CodesService:redeem("trickortreat"); task.wait(0.2)
            for pumpkinId, data in pairs(PumpkinHuntData) do
                if data.isFindable then
                    HalloweenService:claimPumpkinHuntPumpkin(pumpkinId)
                    task.wait(0.1)
                end
            end
        end)
    end)

    local getHauntedPumpkinThread, originalHauntedPumpkinSettings
    local AutoBossCaveToggle = Toggles.AutoJoinAndFight -- cave toggle referansÄ±

    PumpkinSection:AddToggle('GetHauntedPumpkin', {
        Text = 'Get Haunted Pumpkin',
        Tooltip = "Requires hints from the button above. Kills spiders/pumpkins in sequence.",
        Default = false,
        Callback = function(enabled)
            if getHauntedPumpkinThread then task.cancel(getHauntedPumpkinThread); getHauntedPumpkinThread = nil end
            if enabled then
                local initialPlayerData = DataController:getData()
                if initialPlayerData and initialPlayerData.pumpkinHuntFound and initialPlayerData.pumpkinHuntFound.hauntedPumpkin then
                    task.defer(function() Toggles.GetHauntedPumpkin:SetValue(false) end)
                    return
                end
                originalHauntedPumpkinSettings = {
                    autoHit = AutoHitToggle.Value,
                    autoBossCave = AutoBossCaveToggle and AutoBossCaveToggle.Value or false,
                    equipBest = EquipBest.Value,
                    mobSelection = mobDropdown.Value
                }
                getHauntedPumpkinThread = task.spawn(function()
                    local MobsModuleLocal = require(ReplicatedStorage.Shared.List.Halloween.Mobs)
                    local function killMobUntilDead(targetId)
                        local currentData = DataController:getData()
                        while currentData and currentData.mobs and currentData.mobs[targetId] do
                            Knit.GetService("HalloweenService").damage._re:FireServer(targetId)
                            task.wait(0.3)
                            currentData = DataController:getData()
                        end
                    end
                    while task.wait(3) do
                        pcall(function()
                            local playerData = DataController:getData()
                            if playerData.pumpkinHuntFound and playerData.pumpkinHuntFound.hauntedPumpkin then
                                Toggles.GetHauntedPumpkin:SetValue(false)
                                return
                            end
                            local availableSpiders, availablePumpkins = {}, {}
                            for instanceId, mobData in pairs(playerData.mobs or {}) do
                                local mobStats = MobsModuleLocal[mobData.mobId]
                                if mobStats then
                                    local currentHealth = mobStats.hp - (mobData.damage or 0)
                                    local mobInfo = { id = instanceId, health = currentHealth }
                                    if mobData.mobId:lower() == "spider" then table.insert(availableSpiders, mobInfo)
                                    elseif mobData.mobId:lower() == "pumpkin" then table.insert(availablePumpkins, mobInfo) end
                                end
                            end
                            if #availableSpiders >= 3 and #availablePumpkins >= 2 then
                                AutoHitToggle:SetValue(false)
                                if AutoBossCaveToggle then AutoBossCaveToggle:SetValue(false) end
                                EquipBest:SetValue(true)
                                local killOrder = {"spider","pumpkin","spider","spider","pumpkin"}
                                local spidersToKill = availableSpiders
                                local pumpkinsToKill = availablePumpkins
                                for _, mobTypeToKill in ipairs(killOrder) do
                                    local target
                                    if mobTypeToKill == "spider" then target = table.remove(spidersToKill, 1)
                                    elseif mobTypeToKill == "pumpkin" then target = table.remove(pumpkinsToKill, 1) end
                                    if target then killMobUntilDead(target.id) else break end
                                end
                                return
                            elseif #availableSpiders > 3 or #availablePumpkins > 2 then
                                AutoHitToggle:SetValue(false)
                                if AutoBossCaveToggle then AutoBossCaveToggle:SetValue(false) end
                                EquipBest:SetValue(true)
                                if #availableSpiders > 3 then
                                    table.sort(availableSpiders, function(a,b) return a.health < b.health end)
                                    killMobUntilDead(availableSpiders[1].id)
                                end
                                if #availablePumpkins > 2 then
                                    table.sort(availablePumpkins, function(a,b) return a.health < b.health end)
                                    killMobUntilDead(availablePumpkins[1].id)
                                end
                                return
                            else
                                if AutoBossCaveToggle then AutoBossCaveToggle:SetValue(false) end
                                EquipBest:SetValue(true)
                                local mobsToFarm = {}
                                for _, mobName in ipairs(mobDropdown.Values) do
                                    local lowerName = mobName:lower()
                                    if lowerName ~= "spider" and lowerName ~= "pumpkin" then
                                        mobsToFarm[mobName] = true
                                    end
                                end
                                mobDropdown:SetValue(mobsToFarm)
                                AutoHitToggle:SetValue(true)
                            end
                        end)
                    end
                end)
            else
                if originalHauntedPumpkinSettings then
                    AutoHitToggle:SetValue(originalHauntedPumpkinSettings.autoHit)
                    if AutoBossCaveToggle then AutoBossCaveToggle:SetValue(originalHauntedPumpkinSettings.autoBossCave) end
                    EquipBest:SetValue(originalHauntedPumpkinSettings.equipBest)
                    mobDropdown:SetValue(originalHauntedPumpkinSettings.mobSelection)
                    originalHauntedPumpkinSettings = nil
                end
            end
        end
    })

    PumpkinTab:AddRightGroupbox('Info'):AddLabel('Zombie Pumpkin', true, 'ZombiePumpkinInfo')
    Library.Labels.ZombiePumpkinInfo:SetText("Bu yumurtayÄ± almak iÃ§in: Halloween Ã‡arkÄ±'nÄ± (100m) 5 kez Ã§evir, Jungle Egg'den altÄ±n maymunlar yap ve yukarÄ±daki dÃ¼ÄŸme ile ipuÃ§larÄ±nÄ± aÃ§")

    -- Settings sekmesi
    local MenuGroup = SettingsTab:AddLeftGroupbox('Menu Settings')
    MenuGroup:AddToggle('ShowKeybinds', {
        Text='Show Keybinds',
        Default=true,
        Callback=function(v) Library.KeybindFrame.Visible = v end
    })
    MenuGroup:AddToggle('CustomCursor', {
        Text='Custom Cursor',
        Default=true,
        Callback=function(v) Library.ShowCustomCursor = v end
    })
    MenuGroup:AddLabel('Menu Key'):AddKeyPicker('MenuBind', { Default = 'RightShift', NoUI = true })
    MenuGroup:AddButton('Unload', function() Library:Unload() end)
    Library.ToggleKeybind = Options.MenuBind

    -- Linoria Tema ve KayÄ±t
    ThemeManager:SetLibrary(Library)
    SaveManager:SetLibrary(Library)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetIgnoreIndexes({'MenuBind'})
    ThemeManager:SetFolder('FluentScriptHub')
    SaveManager:SetFolder('FluentScriptHub/specific-game')
    SaveManager:SetSubFolder('Place')
    SaveManager:BuildConfigSection(SettingsTab)
    ThemeManager:ApplyToTab(SettingsTab)
    SaveManager:LoadAutoloadConfig()

    -- Watermark (isteÄŸe baÄŸlÄ±, kullanÄ±cÄ± dostu)
    Library:SetWatermarkVisibility(true)
    local FPS=60; local Timer=tick(); local Counter=0
    local Conn=game:GetService('RunService').RenderStepped:Connect(function()
        Counter+=1
        if tick()-Timer>=1 then FPS=Counter; Timer=tick(); Counter=0 end
        Library:SetWatermark(('RCU Halloween | %s FPS | %s ms'):format(FPS, math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())))
    end)
    Library:OnUnload(function() Conn:Disconnect(); print('UI Unloaded') end)
end

-- BaÅŸlatma: Knit ve servisleri baÅŸlat, Linoria penceresini oluÅŸtur, sekmeleri ekle, UIâ€™yi kur
task.spawn(function()
    if not game:IsLoaded() then game.Loaded:Wait() end

    -- Knit init
    Knit = require(ReplicatedStorage.Packages.Knit)
    Knit.OnStart():await()

    ClickService = Knit.GetService("ClickService")
    UpgradeService = Knit.GetService("UpgradeService")
    DataController = Knit.GetController("DataController")
    Functions = require(ReplicatedStorage.Shared.Functions)
    Util = require(ReplicatedStorage.Shared.Util)
    Values = require(ReplicatedStorage.Shared.Values)

    -- Linoria pencere
    local WindowConfig = {
        Title = 'bequit army Halloween ðŸŽƒ',
        Center = true,
        AutoShow = true,
        Resizable = false,
        ShowCustomCursor = true,
        UnlockMouseWhileOpen = true,
        NotifySide = "Left",
        TabPadding = 8,
        MenuFadeTime = 0.2
    }
    Window = Library:CreateWindow(WindowConfig)

    -- Sekmeler
    Tabs = {
        Halloween = Window:AddTab('Halloween Event'),
        PumpkinHunt = Window:AddTab('Pumpkin Hunt'),
        Settings = Window:AddTab('Settings')
    }

    -- UI kur
    BuildUI()
end)
