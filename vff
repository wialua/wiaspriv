local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local MarketplaceService = game:GetService("MarketplaceService")
local Camera = Workspace.CurrentCamera
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local Options = Library.Options
local Toggles = Library.Toggles

Library.ShowToggleFrameInKeybinds = true
Library.ShowCustomCursor = true
Library.NotifySide = "Left"

local gameName = MarketplaceService:GetProductInfo(game.PlaceId).Name
local Window = Library:CreateWindow({
    Title = 'ðŸ”¥ ' .. gameName .. ' ðŸ”¥',
    Center = true,
    AutoShow = true,
    Resizable = true,
    ShowCustomCursor = true,
    UnlockMouseWhileOpen = true,
    NotifySide = "Left",
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Hitbox = Window:AddTab('Hitbox'),
    Aimbot = Window:AddTab('Aimbot'),
    SilentAim = Window:AddTab('Silent Aim'),
    VIP = Window:AddTab('VIP'),
    ['UI AyarlarÄ±'] = Window:AddTab('UI AyarlarÄ±'),
}

Library:SetWatermarkVisibility(false)

-- Settings
local HitboxSettings = {
    Enabled = false,
    Size = 8,
    Transparency = 0.7,
    BodyPart = "Head",
    Optimized = false,
}

local AimbotSettings = {
    Enabled = false,
    Mode = "Hold",
    Keybind = Enum.UserInputType.MouseButton2,
    FOV = 100,
    FOVVisible = true,
    FOVTransparency = 0.5,
    FOVColor = Color3.fromRGB(255, 255, 255),
    FOVThickness = 1,
    FOVNumSides = 64,
    MaxDistance = 1000,
    WallCheck = true,
    VisibleCheck = true,
    TeamCheck = true,
    TargetAimbot = false,
    TargetPlayer = nil,
    Triggerbot = false,
    TriggerbotWallCheck = true,
    TriggerbotVisibleCheck = true,
    TriggerbotTeamCheck = true,
    AimbotBodyPart = "Head",
}

local SilentAimSettings = {
    Enabled = false,
    Mode = "All", -- All, Nearby, FOV
    BodyPart = "HumanoidRootPart",
    HitboxEnabled = false,
    HitboxSize = 100,
    HitboxTransparency = 0.7,
    Distance = 50, -- for Nearby
    FOV = 200,
    FOVVisible = true,
    FOVTransparency = 0.5,
    FOVColor = Color3.fromRGB(255, 255, 255),
    FOVThickness = 1,
    FOVNumSides = 64,
    MaxDistance = 1000,
    TeamCheck = true,
}

local VIPSettings = {
    PunchKillAura = false,
    MeleeKillAura = false,
    GrenadeKeybind = Enum.KeyCode.G,
    ShottySilentAim = false,
    ShottyDistance = 30,
    SelectedPlayer = nil,
    SelectedWheel = "Random",
}

local ActiveHitboxes = {} -- for regular hitbox
local ActiveVRHitboxes = {} -- separate for VR hitbox to avoid conflicts
local IgnoredPlayerName = "MAD_CITYAIMBOTLOL"
local Connections = {}
local HitboxTag = "HitboxExpanded"
local VRHitboxTag = "VRHitboxExpanded"
local AimbotLocked = false
local AimbotTarget = nil
local FixedTargetPart = nil
local TriggerbotDebounce = false
local OptimizedConn = nil
local KillAuraDebounce = false
local ShottyDebounce = false
local SilentAimDebounce = false

local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Radius = AimbotSettings.FOV
FOVCircle.Thickness = AimbotSettings.FOVThickness
FOVCircle.Color = AimbotSettings.FOVColor
FOVCircle.Transparency = AimbotSettings.FOVTransparency
FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
FOVCircle.NumSides = AimbotSettings.FOVNumSides

local VRFOVCircle = Drawing.new("Circle")
VRFOVCircle.Visible = false
VRFOVCircle.Radius = SilentAimSettings.FOV
VRFOVCircle.Thickness = SilentAimSettings.FOVThickness
VRFOVCircle.Color = SilentAimSettings.FOVColor
VRFOVCircle.Transparency = SilentAimSettings.FOVTransparency
VRFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
VRFOVCircle.NumSides = SilentAimSettings.FOVNumSides

-- Team-based player filtering
local function GetTeamFilteredPlayers()
    local players = {}
    local localTeam = LocalPlayer.Team and LocalPlayer.Team.Name or ""
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName then
            local playerTeam = player.Team and player.Team.Name or ""
            local exclude = false
            if localTeam == "Police" or localTeam == "Heroes" then
                exclude = playerTeam == "Police" or playerTeam == "Heroes"
            elseif localTeam == "Prisoners" or localTeam == "Criminals" or localTeam == "Villains" then
                exclude = playerTeam == "Prisoners" or playerTeam == "Criminals" or playerTeam == "Villains"
            end
            if not exclude then
                table.insert(players, {Name = player.Name})
            end
        end
    end
    return players
end

local function UpdateVIPDropdown()
    local players = GetTeamFilteredPlayers()
    local values = {}
    for _, p in ipairs(players) do
        table.insert(values, p.Name)
    end
    Options.VIPPlayerDropdown:SetValues(values)
    if #values > 0 and not table.find(values, VIPSettings.SelectedPlayer) then
        Options.VIPPlayerDropdown:SetValue(values[1])
    elseif #values == 0 then
        Options.VIPPlayerDropdown:SetValue(nil)
    end
end

local function ShouldExpandHitbox(player)
    if not player or player == LocalPlayer or player.Name == IgnoredPlayerName then
        return false
    end
    local playerTeam = player.Team and player.Team.Name or ""
    local localTeam = LocalPlayer.Team and LocalPlayer.Team.Name or ""
    if localTeam == "Prisoners" or localTeam == "Criminals" or localTeam == "Villains" then
        return playerTeam == "Police" or playerTeam == "Heroes"
    elseif localTeam == "Police" or localTeam == "Heroes" then
        return playerTeam == "Prisoners" or playerTeam == "Criminals" or playerTeam == "Villains"
    end
    return true
end

local function IsPlayerVisible(player, part)
    if not part or not player or not player.Character then
        return true
    end
    local ignoreList = {LocalPlayer.Character, Camera}
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = ignoreList
    raycastParams.IgnoreWater = true
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin).Unit * math.min(AimbotSettings.MaxDistance, SilentAimSettings.MaxDistance)
    local result = Workspace:Raycast(origin, direction, raycastParams)
    return result and result.Instance and result.Instance:IsDescendantOf(player.Character)
end

local function IsPlayerBehindWall(player, part)
    if not part or not player or not player.Character then
        return false
    end
    local ignoreList = {LocalPlayer.Character, Camera}
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = ignoreList
    raycastParams.IgnoreWater = true
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin).Unit * math.min(AimbotSettings.MaxDistance, SilentAimSettings.MaxDistance)
    local result = Workspace:Raycast(origin, direction, raycastParams)
    return not (result and result.Instance and result.Instance:IsDescendantOf(player.Character))
end

local function IsWithinFOV(part, fov)
    if not part then
        return false
    end
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then
        return false
    end
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local distance = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
    return distance <= fov
end

local function IsInView(player, distanceLimit)
    if not player or not player.Character then return false end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    local part = player.Character:FindFirstChild("Head") -- Use Head for visibility check
    if not humanoid or humanoid.Health <= 0 or not part then return false end
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then return false end
    local distance = (part.Position - Camera.CFrame.Position).Magnitude
    if distance > (distanceLimit or math.huge) then return false end
    return true
end

local function GetClosestPlayer()
    if AimbotSettings.TargetAimbot and AimbotSettings.TargetPlayer then
        local player = Players:FindFirstChild(AimbotSettings.TargetPlayer)
        if player and player.Character and player.Character:IsDescendantOf(Workspace) then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local part = player.Character:FindFirstChild(AimbotSettings.AimbotBodyPart)
            if humanoid and humanoid.Health > 0 and part and part:IsA("BasePart") then
                if (not AimbotSettings.TeamCheck or ShouldExpandHitbox(player)) and
                   IsWithinFOV(part, AimbotSettings.FOV) and
                   (not AimbotSettings.WallCheck or not IsPlayerBehindWall(player, part)) and
                   (not AimbotSettings.VisibleCheck or IsPlayerVisible(player, part)) then
                    return player, part
                end
            end
        end
        return nil, nil
    end

    local closestPlayer, closestPart, closestDistance = nil, nil, math.huge
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName and player.Character and player.Character:IsDescendantOf(Workspace) then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local part = player.Character:FindFirstChild(AimbotSettings.AimbotBodyPart)
            if humanoid and humanoid.Health > 0 and part and part:IsA("BasePart") then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    local worldDist = (Camera.CFrame.Position - part.Position).Magnitude
                    if worldDist <= AimbotSettings.MaxDistance and screenDist < closestDistance and
                       (not AimbotSettings.TeamCheck or ShouldExpandHitbox(player)) and
                       IsWithinFOV(part, AimbotSettings.FOV) and
                       (not AimbotSettings.WallCheck or not IsPlayerBehindWall(player, part)) and
                       (not AimbotSettings.VisibleCheck or IsPlayerVisible(player, part)) then
                        closestPlayer, closestPart, closestDistance = player, part, screenDist
                    end
                end
            end
        end
    end
    return closestPlayer, closestPart
end

local function ApplyHitbox(player)
    if not HitboxSettings.Enabled or not ShouldExpandHitbox(player) or not player then
        return
    end
    local character = player.Character
    if not character or not character:IsDescendantOf(Workspace) then
        return
    end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        return
    end
    local part = character:FindFirstChild(HitboxSettings.BodyPart)
    if part and part:IsA("BasePart") and not ActiveHitboxes[player] then
        ActiveHitboxes[player] = {
            part = part,
            originalSize = part.Size,
            originalMassless = part.Massless,
            originalTransparency = part.Transparency,
            originalCanCollide = part.CanCollide
        }
        part.Size = Vector3.new(HitboxSettings.Size, HitboxSettings.Size, HitboxSettings.Size)
        part.Transparency = HitboxSettings.Transparency
        part.CanCollide = false
        part.Massless = true
        CollectionService:AddTag(part, HitboxTag)
    end
end

local function RestoreHitbox(player)
    if ActiveHitboxes[player] then
        local data = ActiveHitboxes[player]
        local part = data.part
        if part and part:IsA("BasePart") and part:IsDescendantOf(Workspace) then
            part.Size = data.originalSize
            part.Transparency = data.originalTransparency
            part.CanCollide = data.originalCanCollide
            part.Massless = data.originalMassless
            CollectionService:RemoveTag(part, HitboxTag)
        end
        ActiveHitboxes[player] = nil
    end
end

local function UpdateAllHitboxes()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName then
            RestoreHitbox(player)
            if HitboxSettings.Enabled and ShouldExpandHitbox(player) then
                task.defer(ApplyHitbox, player)
            end
        end
    end
end

local function UpdateVisibleHitboxes()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName then
            if HitboxSettings.Enabled and ShouldExpandHitbox(player) and IsInView(player, AimbotSettings.MaxDistance) then
                task.defer(ApplyHitbox, player)
            else
                RestoreHitbox(player)
            end
        end
    end
end

local function ToggleOptimized(value)
    HitboxSettings.Optimized = value
    if value then
        if OptimizedConn then OptimizedConn:Disconnect() end
        OptimizedConn = RunService.Heartbeat:Connect(UpdateVisibleHitboxes)
        Library:Notify("Optimized Hitbox Modu EtkinleÅŸtirildi", 3)
    else
        if OptimizedConn then
            OptimizedConn:Disconnect()
            OptimizedConn = nil
        end
        UpdateAllHitboxes()
        Library:Notify("Optimized Hitbox Modu Devre DÄ±ÅŸÄ± BÄ±rakÄ±ldÄ±", 3)
    end
end

local function ApplyVRHitbox(player)
    if not SilentAimSettings.HitboxEnabled or not ShouldExpandHitbox(player) or not player then
        return
    end
    local character = player.Character
    if not character or not character:IsDescendantOf(Workspace) then
        return
    end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        return
    end
    if not ActiveVRHitboxes[player] then
        ActiveVRHitboxes[player] = {}
    end
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and not ActiveVRHitboxes[player][part.Name] then
            -- Limit size for Head to avoid bugs
            local size = (part.Name == "Head") and math.min(SilentAimSettings.HitboxSize, 20) or SilentAimSettings.HitboxSize
            ActiveVRHitboxes[player][part.Name] = {
                part = part,
                originalSize = part.Size,
                originalMassless = part.Massless,
                originalTransparency = part.Transparency,
                originalCanCollide = part.CanCollide
            }
            part.Size = Vector3.new(size, size, size)
            part.Transparency = SilentAimSettings.HitboxTransparency
            part.CanCollide = false
            part.Massless = true
            CollectionService:AddTag(part, VRHitboxTag)
        end
    end
end

local function RestoreVRHitbox(player)
    if ActiveVRHitboxes[player] then
        for _, data in pairs(ActiveVRHitboxes[player]) do
            local part = data.part
            if part and part:IsA("BasePart") and part:IsDescendantOf(Workspace) then
                part.Size = data.originalSize
                part.Transparency = data.originalTransparency
                part.CanCollide = data.originalCanCollide
                part.Massless = data.originalMassless
                CollectionService:RemoveTag(part, VRHitboxTag)
            end
        end
        ActiveVRHitboxes[player] = nil
    end
end

local function UpdateAllVRHitboxes()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName then
            RestoreVRHitbox(player)
            if SilentAimSettings.HitboxEnabled and ShouldExpandHitbox(player) then
                task.defer(ApplyVRHitbox, player)
            end
        end
    end
end

local function SendVR(player, part)
    if not player or not part then return end
    pcall(function()
        local args = { [1] = "VR", [2] = part }
        ReplicatedStorage:WaitForChild("Event"):FireServer(unpack(args))
    end)
end

local function SilentAimLoop(input)
    if not SilentAimSettings.Enabled or SilentAimDebounce then return end
    SilentAimDebounce = true
    task.spawn(function()
        local targets = {}
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName and player.Character and player.Character:IsDescendantOf(Workspace) then
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                local part = player.Character:FindFirstChild(SilentAimSettings.BodyPart)
                if humanoid and humanoid.Health > 0 and part and (not SilentAimSettings.TeamCheck or ShouldExpandHitbox(player)) then
                    local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    local inRange = true
                    if SilentAimSettings.Mode == "Nearby" then
                        inRange = distance <= SilentAimSettings.Distance
                    elseif SilentAimSettings.Mode == "FOV" then
                        inRange = IsWithinFOV(part, SilentAimSettings.FOV)
                    elseif SilentAimSettings.Mode == "All" then
                        inRange = distance <= SilentAimSettings.MaxDistance
                    end
                    if inRange then
                        table.insert(targets, {player = player, part = part})
                    end
                end
            end
        end
        for _, target in ipairs(targets) do
            SendVR(target.player, target.part)
        end
        SilentAimDebounce = false
    end)
end

local function SendPunch(player)
    if not player or not player.Character or not player.Character:IsDescendantOf(Workspace) then return end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health > 0 then
        for _ = 1, 10 do
            pcall(function()
                local args = { [1] = "Punch", [2] = humanoid }
                ReplicatedStorage:WaitForChild("Event"):FireServer(unpack(args))
            end)
            task.wait(0.01)
        end
    end
end

local function SendMelee(player)
    if not player or not player.Character or not player.Character:IsDescendantOf(Workspace) then return end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health > 0 then
        for _ = 1, 10 do
            pcall(function()
                local args = { [1] = "Melee", [2] = humanoid }
                ReplicatedStorage:WaitForChild("Event"):FireServer(unpack(args))
            end)
            task.wait(0.01)
        end
    end
end

local function KillAuraLoop()
    if not (VIPSettings.PunchKillAura or VIPSettings.MeleeKillAura) or KillAuraDebounce then return end
    KillAuraDebounce = true
    task.spawn(function()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName and player.Character and player.Character:IsDescendantOf(Workspace) then
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid.Health > 0 and ShouldExpandHitbox(player) then
                    local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance <= 10 then
                        if VIPSettings.PunchKillAura then
                            task.defer(SendPunch, player)
                        end
                        if VIPSettings.MeleeKillAura then
                            task.defer(SendMelee, player)
                        end
                    end
                end
            end
        end
        KillAuraDebounce = false
    end)
end

local function ThrowGrenade(targetPos)
    pcall(function()
        local args = { [1] = "ThrowGrenade", [2] = targetPos }
        ReplicatedStorage:WaitForChild("Event"):FireServer(unpack(args))
    end)
end

local function SendShotty(target)
    pcall(function()
        local args = { [1] = "SHOTTY", [2] = target }
        ReplicatedStorage:WaitForChild("Event"):FireServer(unpack(args))
    end)
end

local function GetVehicleTarget(player, wheel)
    if not player or not player.Character or not player.Character:IsDescendantOf(Workspace) then return nil end
    local vehicle = Workspace:FindFirstChild("ObjectSelection"):FindFirstChild(player.Name .. "'s Vehicle")
    if not vehicle then return nil end
    if wheel == "Random" then
        local wheels = {"FrontLeftWheel", "FrontRightWheel", "BackLeftWheel", "BackRightWheel"}
        wheel = wheels[math.random(1, #wheels)]
    end
    local target = vehicle:FindFirstChild(wheel) or vehicle:FindFirstChild("Body"):FindFirstChild("Body") or vehicle:FindFirstChild("Body"):FindFirstChild("Bottom")
    return target
end

local function SilentShottyLoop()
    if not VIPSettings.ShottySilentAim or ShottyDebounce then return end
    ShottyDebounce = true
    task.spawn(function()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Name ~= IgnoredPlayerName and player.Character and player.Character:IsDescendantOf(Workspace) then
                local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                if distance <= VIPSettings.ShottyDistance and ShouldExpandHitbox(player) then
                    local target = GetVehicleTarget(player, VIPSettings.SelectedWheel)
                    if target then
                        SendShotty(target)
                    end
                end
            end
        end
        ShottyDebounce = false
    end)
end

local function SetupPlayer(player)
    if not player or player == LocalPlayer or player.Name == IgnoredPlayerName then return end
    Connections[player] = Connections[player] or {}

    local charAddedConn = player.CharacterAdded:Connect(function(character)
        task.spawn(function()
            local timeout = tick() + 2
            while not character:IsDescendantOf(Workspace) or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChildOfClass("Humanoid") do
                if tick() > timeout then return end
                task.wait()
            end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                if HitboxSettings.Enabled and ShouldExpandHitbox(player) and (not HitboxSettings.Optimized or IsInView(player, AimbotSettings.MaxDistance)) then
                    ApplyHitbox(player)
                end
                if SilentAimSettings.HitboxEnabled and ShouldExpandHitbox(player) then
                    ApplyVRHitbox(player)
                end
            end
        end)
    end)
    table.insert(Connections[player], charAddedConn)

    if player.Character then
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local healthConn = humanoid.HealthChanged:Connect(function(health)
                if health > 0 then
                    if HitboxSettings.Enabled and ShouldExpandHitbox(player) and (not HitboxSettings.Optimized or IsInView(player, AimbotSettings.MaxDistance)) then
                        task.defer(ApplyHitbox, player)
                    end
                    if SilentAimSettings.HitboxEnabled and ShouldExpandHitbox(player) then
                        task.defer(ApplyVRHitbox, player)
                    end
                else
                    RestoreHitbox(player)
                    RestoreVRHitbox(player)
                end
            end)
            table.insert(Connections[player], healthConn)

            local diedConn = humanoid.Died:Connect(function()
                RestoreHitbox(player)
                RestoreVRHitbox(player)
            end)
            table.insert(Connections[player], diedConn)

            local stateConn = humanoid.StateChanged:Connect(function(_, newState)
                if newState == Enum.HumanoidStateType.Running then
                    if HitboxSettings.Enabled and ShouldExpandHitbox(player) and (not HitboxSettings.Optimized or IsInView(player, AimbotSettings.MaxDistance)) then
                        task.defer(ApplyHitbox, player)
                    end
                    if SilentAimSettings.HitboxEnabled and ShouldExpandHitbox(player) then
                        task.defer(ApplyVRHitbox, player)
                    end
                end
            end)
            table.insert(Connections[player], stateConn)
        end

        local ancestryConn = player.Character.AncestryChanged:Connect(function()
            if player.Character and player.Character:IsDescendantOf(Workspace) then
                if HitboxSettings.Enabled and ShouldExpandHitbox(player) and (not HitboxSettings.Optimized or IsInView(player, AimbotSettings.MaxDistance)) then
                    task.defer(ApplyHitbox, player)
                end
                if SilentAimSettings.HitboxEnabled and ShouldExpandHitbox(player) then
                    task.defer(ApplyVRHitbox, player)
                end
            end
        end)
        table.insert(Connections[player], ancestryConn)
    end

    if player.Character and player.Character:IsDescendantOf(Workspace) then
        if HitboxSettings.Enabled and ShouldExpandHitbox(player) and (not HitboxSettings.Optimized or IsInView(player, AimbotSettings.MaxDistance)) then
            ApplyHitbox(player)
        end
        if SilentAimSettings.HitboxEnabled and ShouldExpandHitbox(player) then
            ApplyVRHitbox(player)
        end
    end

    local watchdogConn = RunService.Heartbeat:Connect(function()
        if not player:IsDescendantOf(game) then return end
        local character = player.Character
        if character and character:IsDescendantOf(Workspace) and character:FindFirstChildOfClass("Humanoid") then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                if HitboxSettings.Enabled and ShouldExpandHitbox(player) and not ActiveHitboxes[player] and (not HitboxSettings.Optimized or IsInView(player, AimbotSettings.MaxDistance)) then
                    task.defer(ApplyHitbox, player)
                end
                if SilentAimSettings.HitboxEnabled and ShouldExpandHitbox(player) and not ActiveVRHitboxes[player] then
                    task.defer(ApplyVRHitbox, player)
                end
            end
        end
    end)
    table.insert(Connections[player], watchdogConn)
end

Players.PlayerAdded:Connect(function(player)
    SetupPlayer(player)
    UpdateVIPDropdown()
end)

Players.PlayerRemoving:Connect(function(player)
    RestoreHitbox(player)
    RestoreVRHitbox(player)
    if Connections[player] then
        for _, conn in ipairs(Connections[player]) do
            conn:Disconnect()
        end
        Connections[player] = nil
    end
    if AimbotSettings.TargetPlayer == player.Name then
        AimbotSettings.TargetPlayer = nil
        AimbotLocked = false
        AimbotTarget = nil
        FixedTargetPart = nil
    end
    UpdateVIPDropdown()
end)

Workspace.ChildAdded:Connect(function(child)
    if child:IsA("Model") and child:FindFirstChildOfClass("Humanoid") then
        local player = Players:GetPlayerFromCharacter(child)
        if player and player ~= LocalPlayer and player.Name ~= IgnoredPlayerName then
            if HitboxSettings.Enabled and ShouldExpandHitbox(player) and (not HitboxSettings.Optimized or IsInView(player, AimbotSettings.MaxDistance)) then
                task.defer(ApplyHitbox, player)
            end
            if SilentAimSettings.HitboxEnabled and ShouldExpandHitbox(player) then
                task.defer(ApplyVRHitbox, player)
            end
        end
    end
end)

Workspace.ChildRemoved:Connect(function(child)
    if child:IsA("Model") then
        local player = Players:GetPlayerFromCharacter(child)
        if player then
            RestoreHitbox(player)
            RestoreVRHitbox(player)
        end
    end
end)

local teamConn = LocalPlayer:GetPropertyChangedSignal("Team"):Connect(function()
    task.defer(function()
        if HitboxSettings.Optimized then
            UpdateVisibleHitboxes()
        else
            UpdateAllHitboxes()
        end
        UpdateAllVRHitboxes()
        UpdateVIPDropdown()
        Library:Notify("TakÄ±m deÄŸiÅŸtirildi, hitbox'lar gÃ¼ncellendi!", 3)
    end)
end)
table.insert(Connections, teamConn)

local aimbotConn = RunService.Heartbeat:Connect(function()
    if not AimbotSettings.Enabled then
        AimbotTarget = nil
        FixedTargetPart = nil
        FOVCircle.Visible = false
        return
    end

    FOVCircle.Radius = AimbotSettings.FOV
    FOVCircle.Transparency = AimbotSettings.FOVTransparency
    FOVCircle.Color = AimbotSettings.FOVColor
    FOVCircle.Thickness = AimbotSettings.FOVThickness
    FOVCircle.NumSides = AimbotSettings.FOVNumSides
    FOVCircle.Visible = AimbotSettings.FOVVisible
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    if not AimbotLocked then
        AimbotTarget = nil
        FixedTargetPart = nil
        return
    end

    if AimbotSettings.Mode == "Toggle" then
        if not FixedTargetPart or not FixedTargetPart.Parent or not FixedTargetPart:IsDescendantOf(Workspace) then
            local _, part = GetClosestPlayer()
            FixedTargetPart = part
        end
        AimbotTarget = FixedTargetPart
    else
        local _, part = GetClosestPlayer()
        AimbotTarget = part
    end

    if AimbotTarget then
        local player = Players:GetPlayerFromCharacter(AimbotTarget.Parent)
        local humanoid = AimbotTarget.Parent:FindFirstChildOfClass("Humanoid")
        if not player or not humanoid or humanoid.Health <= 0 or not IsWithinFOV(AimbotTarget, AimbotSettings.FOV) or (AimbotSettings.WallCheck and IsPlayerBehindWall(player, AimbotTarget)) or (AimbotSettings.VisibleCheck and not IsPlayerVisible(player, AimbotTarget)) then
            AimbotLocked = false
            FixedTargetPart = nil
            AimbotTarget = nil
            Library:Notify("Hedef geÃ§ersiz, aimbot kilidi aÃ§Ä±ldÄ±!", 3)
            return
        end
    else
        return
    end

    if AimbotTarget then
        local targetPos = AimbotTarget.Position
        local currentPos = Camera.CFrame.Position
        local newCFrame = CFrame.new(currentPos, targetPos)
        Camera.CFrame = newCFrame
    end

    if AimbotSettings.Triggerbot and not TriggerbotDebounce then
        TriggerbotDebounce = true
        task.spawn(function()
            local mousePos = UserInputService:GetMouseLocation()
            local ray = Camera:ViewportPointToRay(mousePos.X, mousePos.Y)
            local raycastParams = RaycastParams.new()
            raycastParams.FilterType = Enum.RaycastFilterType.Exclude
            raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
            local result = Workspace:Raycast(ray.Origin, ray.Direction * AimbotSettings.MaxDistance, raycastParams)
            if result and result.Instance and CollectionService:HasTag(result.Instance, HitboxTag) then
                local player = Players:GetPlayerFromCharacter(result.Instance.Parent)
                if player and (not AimbotSettings.TriggerbotTeamCheck or ShouldExpandHitbox(player)) and
                   (not AimbotSettings.TriggerbotWallCheck or not IsPlayerBehindWall(player, result.Instance)) and
                   (not AimbotSettings.TriggerbotVisibleCheck or IsPlayerVisible(player, result.Instance)) then
                    if mouse1press and mouse1release then
                        mouse1press()
                        task.wait(0.01)
                        mouse1release()
                    else
                        Library:Notify("Triggerbot desteklenmiyor!", 3)
                    end
                end
            end
            TriggerbotDebounce = false
        end)
    end
end)
table.insert(Connections, aimbotConn)

local silentAimConn = RunService.Heartbeat:Connect(function()
    if not SilentAimSettings.Enabled then
        VRFOVCircle.Visible = false
        return
    end

    VRFOVCircle.Radius = SilentAimSettings.FOV
    VRFOVCircle.Transparency = SilentAimSettings.FOVTransparency
    VRFOVCircle.Color = SilentAimSettings.FOVColor
    VRFOVCircle.Thickness = SilentAimSettings.FOVThickness
    VRFOVCircle.NumSides = SilentAimSettings.FOVNumSides
    VRFOVCircle.Visible = (SilentAimSettings.Mode == "FOV") and SilentAimSettings.FOVVisible
    VRFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
end)
table.insert(Connections, silentAimConn)

local killAuraConn = RunService.Heartbeat:Connect(function()
    KillAuraLoop()
    SilentShottyLoop()
end)
table.insert(Connections, killAuraConn)

local inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    local isAimbotKey = (input.UserInputType == AimbotSettings.Keybind) or (input.KeyCode == AimbotSettings.Keybind)
    local isGrenadeKey = (input.KeyCode == VIPSettings.GrenadeKeybind)
    local isMouse1 = (input.UserInputType == Enum.UserInputType.MouseButton1)

    if isAimbotKey then
        if AimbotSettings.Mode == "Hold" then
            AimbotLocked = true
        elseif AimbotSettings.Mode == "Toggle" then
            AimbotLocked = not AimbotLocked
            if AimbotLocked then
                local _, part = GetClosestPlayer()
                FixedTargetPart = part
            else
                FixedTargetPart = nil
            end
            Library:Notify("Aimbot " .. (AimbotLocked and "Kilitlendi" or "Kilidi AÃ§Ä±ldÄ±"), 3)
        end
    elseif isGrenadeKey then
        task.spawn(function()
            if VIPSettings.SelectedPlayer then
                local player = Players:FindFirstChild(VIPSettings.SelectedPlayer)
                if player and player.Character and player.Character.HumanoidRootPart then
                    ThrowGrenade(player.Character.HumanoidRootPart.Position)
                end
            else
                local mousePos = UserInputService:GetMouseLocation()
                local ray = Camera:ViewportPointToRay(mousePos.X, mousePos.Y)
                local result = Workspace:Raycast(ray.Origin, ray.Direction * 1000)
                if result then
                    ThrowGrenade(result.Position)
                end
            end
        end)
    elseif isMouse1 then
        if VIPSettings.SelectedPlayer and VIPSettings.ShottySilentAim then
            task.spawn(function()
                local player = Players:FindFirstChild(VIPSettings.SelectedPlayer)
                if player then
                    local target = GetVehicleTarget(player, VIPSettings.SelectedWheel)
                    if target then
                        SendShotty(target)
                    end
                end
            end)
        end
        if SilentAimSettings.Enabled then
            SilentAimLoop(input)
        end
    end
end)
table.insert(Connections, inputConn)

local inputEndConn = UserInputService.InputEnded:Connect(function(input)
    if AimbotSettings.Mode == "Hold" then
        local isKeybind = (input.UserInputType == AimbotSettings.Keybind) or (input.KeyCode == AimbotSettings.Keybind)
        if isKeybind then
            AimbotLocked = false
            AimbotTarget = nil
        end
    end
end)
table.insert(Connections, inputEndConn)

for _, player in ipairs(Players:GetPlayers()) do
    SetupPlayer(player)
end

-- UI Setup - TÃ¼rkÃ§e
local HitboxGroupBox = Tabs.Hitbox:AddLeftGroupbox('Hitbox Kontrolleri')
HitboxGroupBox:AddToggle('HitboxToggle', {
    Text = 'Hitbox GeniÅŸletmeyi EtkinleÅŸtir',
    Default = false,
    Tooltip = 'Hitbox geniÅŸletmeyi aÃ§/kapat',
    Risky = true,
    Callback = function(Value)
        HitboxSettings.Enabled = Value
        if Value then
            if HitboxSettings.Optimized then
                ToggleOptimized(true)
            else
                UpdateAllHitboxes()
            end
        else
            for player in pairs(ActiveHitboxes) do
                RestoreHitbox(player)
            end
        end
        Library:Notify("Hitbox GeniÅŸletme " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

HitboxGroupBox:AddToggle('OptimizedHitboxToggle', {
    Text = 'Optimized Mod',
    Default = false,
    Tooltip = 'Sadece gÃ¶rÃ¼nÃ¼r oyunculara uygula (FPS iyileÅŸtirme)',
    Callback = function(Value)
        ToggleOptimized(Value)
    end
})

HitboxGroupBox:AddDropdown('BodyPartDropdown', {
    Values = {'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso'},
    Default = 'Head',
    Text = 'VÃ¼cut ParÃ§asÄ±',
    Tooltip = 'GeniÅŸletilecek parÃ§a',
    Callback = function(Value)
        for player in pairs(ActiveHitboxes) do
            RestoreHitbox(player)
        end
        HitboxSettings.BodyPart = Value
        if HitboxSettings.Enabled then
            if HitboxSettings.Optimized then
                UpdateVisibleHitboxes()
            else
                UpdateAllHitboxes()
            end
        end
        Library:Notify("VÃ¼cut ParÃ§asÄ±: " .. Value, 3)
    end
})

HitboxGroupBox:AddSlider('HitboxSizeSlider', {
    Text = 'Boyut',
    Default = 8,
    Min = 5,
    Max = 20, -- Limit to avoid bugs
    Rounding = 1,
    Tooltip = 'Hitbox boyutu',
    Callback = function(Value)
        HitboxSettings.Size = Value
        if HitboxSettings.Enabled then
            if HitboxSettings.Optimized then
                UpdateVisibleHitboxes()
            else
                UpdateAllHitboxes()
            end
        end
        Library:Notify("Boyut: " .. Value, 3)
    end
})

HitboxGroupBox:AddSlider('HitboxTransparencySlider', {
    Text = 'ÅžeffaflÄ±k',
    Default = 0.7,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Tooltip = 'Hitbox ÅŸeffaflÄ±ÄŸÄ±',
    Callback = function(Value)
        HitboxSettings.Transparency = Value
        if HitboxSettings.Enabled then
            if HitboxSettings.Optimized then
                UpdateVisibleHitboxes()
            else
                UpdateAllHitboxes()
            end
        end
        Library:Notify("ÅžeffaflÄ±k: " .. Value, 3)
    end
})

local AimbotGroupBox = Tabs.Aimbot:AddLeftGroupbox('Aimbot Kontrolleri')
AimbotGroupBox:AddToggle('AimbotToggle', {
    Text = 'Aimbot EtkinleÅŸtir',
    Default = false,
    Tooltip = 'Aimbot aÃ§/kapat',
    Risky = true,
    Callback = function(Value)
        AimbotSettings.Enabled = Value
        AimbotLocked = false
        AimbotTarget = nil
        FixedTargetPart = nil
        Library:Notify("Aimbot " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

AimbotGroupBox:AddDropdown('AimbotMode', {
    Values = {'Hold', 'Toggle'},
    Default = 'Hold',
    Text = 'Mod',
    Tooltip = 'Aimbot modu',
    Callback = function(Value)
        AimbotSettings.Mode = Value
        AimbotLocked = false
        AimbotTarget = nil
        FixedTargetPart = nil
        Library:Notify("Mod: " .. Value, 3)
    end
})

AimbotGroupBox:AddLabel('TuÅŸ'):AddKeyPicker('AimbotKeybind', {
    Default = 'MouseButton2',
    Mode = 'Toggle',
    Text = 'Aimbot TuÅŸu',
    Tooltip = 'Kilit tuÅŸu',
    ChangedCallback = function(New)
        AimbotSettings.Keybind = New
        Library:Notify("TuÅŸ: " .. tostring(New), 3)
    end
})

AimbotGroupBox:AddToggle('FOVToggle', {
    Text = 'FOV GÃ¶ster',
    Default = true,
    Tooltip = 'FOV Ã§emberi gÃ¶ster',
    Callback = function(Value)
        AimbotSettings.FOVVisible = Value
        Library:Notify("FOV " .. (Value and "GÃ¶steriliyor" or "Gizli"), 3)
    end
})

AimbotGroupBox:AddSlider('FOVSlider', {
    Text = 'FOV Boyutu',
    Default = 100,
    Min = 10,
    Max = 500,
    Rounding = 0,
    Tooltip = 'FOV boyutu',
    Callback = function(Value)
        AimbotSettings.FOV = Value
        Library:Notify("FOV Boyutu: " .. Value, 3)
    end
})

AimbotGroupBox:AddSlider('FOVTransparencySlider', {
    Text = 'FOV ÅžeffaflÄ±k',
    Default = 0.5,
    Min = 0.1,
    Max = 1,
    Rounding = 2,
    Tooltip = 'FOV ÅŸeffaflÄ±ÄŸÄ±',
    Callback = function(Value)
        AimbotSettings.FOVTransparency = Value
        Library:Notify("FOV ÅžeffaflÄ±k: " .. Value, 3)
    end
})

AimbotGroupBox:AddLabel('FOV Rengi'):AddColorPicker('FOVColorPicker', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'FOV Rengi',
    Callback = function(Value)
        AimbotSettings.FOVColor = Value
        Library:Notify("FOV Rengi DeÄŸiÅŸti", 3)
    end
})

AimbotGroupBox:AddSlider('FOVThicknessSlider', {
    Text = 'FOV KalÄ±nlÄ±k',
    Default = 1,
    Min = 1,
    Max = 5,
    Rounding = 0,
    Tooltip = 'FOV kalÄ±nlÄ±ÄŸÄ±',
    Callback = function(Value)
        AimbotSettings.FOVThickness = Value
        Library:Notify("FOV KalÄ±nlÄ±k: " .. Value, 3)
    end
})

AimbotGroupBox:AddSlider('FOVNumSidesSlider', {
    Text = 'FOV Kenar SayÄ±sÄ±',
    Default = 64,
    Min = 12,
    Max = 128,
    Rounding = 0,
    Tooltip = 'FOV yumuÅŸaklÄ±ÄŸÄ±',
    Callback = function(Value)
        AimbotSettings.FOVNumSides = Value
        Library:Notify("FOV Kenar: " .. Value, 3)
    end
})

AimbotGroupBox:AddSlider('MaxDistanceSlider', {
    Text = 'Max Mesafe',
    Default = 1000,
    Min = 100,
    Max = 5000,
    Rounding = 0,
    Tooltip = 'Max aim mesafesi',
    Callback = function(Value)
        AimbotSettings.MaxDistance = Value
        Library:Notify("Max Mesafe: " .. Value, 3)
    end
})

AimbotGroupBox:AddToggle('WallCheckToggle', {
    Text = 'Duvar Kontrol',
    Default = true,
    Tooltip = 'Duvar arkasÄ± kontrol',
    Callback = function(Value)
        AimbotSettings.WallCheck = Value
        Library:Notify("Duvar Kontrol " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('VisibleCheckToggle', {
    Text = 'GÃ¶rÃ¼nÃ¼rlÃ¼k Kontrol',
    Default = true,
    Tooltip = 'GÃ¶rÃ¼nÃ¼r kontrol',
    Callback = function(Value)
        AimbotSettings.VisibleCheck = Value
        Library:Notify("GÃ¶rÃ¼nÃ¼rlÃ¼k " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TeamCheckToggle', {
    Text = 'TakÄ±m Kontrol',
    Default = true,
    Tooltip = 'TakÄ±m arkadaÅŸÄ± kontrol',
    Callback = function(Value)
        AimbotSettings.TeamCheck = Value
        Library:Notify("TakÄ±m Kontrol " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TargetAimbotToggle', {
    Text = 'Hedef Aimbot',
    Default = false,
    Tooltip = 'Belirli oyuncu aim',
    Callback = function(Value)
        AimbotSettings.TargetAimbot = Value
        if not Value then
            AimbotSettings.TargetPlayer = nil
        end
        Library:Notify("Hedef Aimbot " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

AimbotGroupBox:AddDropdown('TargetPlayerDropdown', {
    SpecialType = 'Player',
    ExcludeLocalPlayer = true,
    Text = 'Hedef Oyuncu',
    Tooltip = 'Hedef seÃ§',
    Callback = function(Value)
        AimbotSettings.TargetPlayer = Value
        Library:Notify("Hedef: " .. Value, 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotToggle', {
    Text = 'Triggerbot EtkinleÅŸtir',
    Default = false,
    Tooltip = 'Otomatik tÄ±kla',
    Risky = true,
    Callback = function(Value)
        AimbotSettings.Triggerbot = Value
        Library:Notify("Triggerbot " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotWallCheckToggle', {
    Text = 'Triggerbot Duvar Kontrol',
    Default = true,
    Tooltip = 'Triggerbot duvar kontrol',
    Callback = function(Value)
        AimbotSettings.TriggerbotWallCheck = Value
        Library:Notify("Triggerbot Duvar " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotVisibleCheckToggle', {
    Text = 'Triggerbot GÃ¶rÃ¼nÃ¼rlÃ¼k',
    Default = true,
    Tooltip = 'Triggerbot gÃ¶rÃ¼nÃ¼r kontrol',
    Callback = function(Value)
        AimbotSettings.TriggerbotVisibleCheck = Value
        Library:Notify("Triggerbot GÃ¶rÃ¼nÃ¼rlÃ¼k " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

AimbotGroupBox:AddToggle('TriggerbotTeamCheckToggle', {
    Text = 'Triggerbot TakÄ±m Kontrol',
    Default = true,
    Tooltip = 'Triggerbot takÄ±m kontrol',
    Callback = function(Value)
        AimbotSettings.TriggerbotTeamCheck = Value
        Library:Notify("Triggerbot TakÄ±m " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

AimbotGroupBox:AddDropdown('AimbotBodyPartDropdown', {
    Values = {'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso'},
    Default = 'Head',
    Text = 'Hedef ParÃ§a',
    Tooltip = 'Aimbot hedef parÃ§asÄ±',
    Callback = function(Value)
        AimbotSettings.AimbotBodyPart = Value
        Library:Notify("Hedef ParÃ§a: " .. Value, 3)
    end
})

local VIPGroupBox = Tabs.VIP:AddLeftGroupbox('VIP Kontrolleri')
VIPGroupBox:AddToggle('PunchKillAuraToggle', {
    Text = 'Yumruk Aura',
    Default = false,
    Tooltip = 'YakÄ±n oyunculara yumruk',
    Risky = true,
    Callback = function(Value)
        VIPSettings.PunchKillAura = Value
        Library:Notify("Yumruk Aura " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

VIPGroupBox:AddToggle('MeleeKillAuraToggle', {
    Text = 'Melee Aura',
    Default = false,
    Tooltip = 'YakÄ±n oyunculara melee',
    Risky = true,
    Callback = function(Value)
        VIPSettings.MeleeKillAura = Value
        Library:Notify("Melee Aura " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

VIPGroupBox:AddLabel('Bomba TuÅŸu'):AddKeyPicker('GrenadeKeybind', {
    Default = 'G',
    Mode = 'Press',
    Text = 'Bomba TuÅŸu',
    Tooltip = 'Bomba at',
    ChangedCallback = function(New)
        VIPSettings.GrenadeKeybind = New
        Library:Notify("Bomba TuÅŸu: " .. tostring(New), 3)
    end
})

VIPGroupBox:AddDropdown('VIPPlayerDropdown', {
    Values = {},
    Text = 'Hedef Oyuncu',
    Tooltip = 'Hedef seÃ§',
    Callback = function(Value)
        VIPSettings.SelectedPlayer = Value
        Library:Notify("Hedef: " .. Value, 3)
    end
})

VIPGroupBox:AddDropdown('WheelDropdown', {
    Values = {'Random', 'FrontLeftWheel', 'FrontRightWheel', 'BackLeftWheel', 'BackRightWheel', 'Body'},
    Default = 'Random',
    Text = 'AraÃ§ ParÃ§asÄ±',
    Tooltip = 'Shotty parÃ§asÄ±',
    Callback = function(Value)
        VIPSettings.SelectedWheel = Value
        Library:Notify("ParÃ§a: " .. Value, 3)
    end
})

VIPGroupBox:AddToggle('ShottySilentAimToggle', {
    Text = 'Shotty Silent Aim',
    Default = false,
    Tooltip = 'YakÄ±n araÃ§lara shotty',
    Risky = true,
    Callback = function(Value)
        VIPSettings.ShottySilentAim = Value
        Library:Notify("Shotty Silent Aim " .. (Value and "Etkin" or "Devre DÄ±ÅŸÄ±"), 3)
    end
})

VIPGroupBox:AddSlider('ShottyDistanceSlider', {
    Text = 'Shotty Mesafe',
    Default = 30,
    Min = 10,
    Max = 100,
    Rounding = 0,
    Tooltip = 'Shotty max mesafe',
    Callback = function(Value)
        VIPSettings.ShottyDistance = Value
        Library:Notify("Shotty Mesafe: " .. Value, 3)
    end
})

VIPGroupBox:AddButton({
    Text = 'Polis Ol',
    Func = function()
        pcall(function()
            local args = { [1] = "SetTeam", [2] = "Police" }
            ReplicatedStorage:WaitForChild("RemoteFunction"):InvokeServer(unpack(args))
            Library:Notify("Polis oldun!", 3)
        end)
    end,
    Tooltip = 'Polis takÄ±mÄ±na geÃ§'
})

VIPGroupBox:AddButton({
    Text = 'Mahkum Ol',
    Func = function()
        pcall(function()
            local args = { [1] = "SetTeam", [2] = "Prisoners" }
            ReplicatedStorage:WaitForChild("RemoteFunction"):InvokeServer(unpack(args))
            Library:Notify("Mahkum oldun!", 3)
        end)
    end,
    Tooltip = 'Mahkum takÄ±mÄ±na geÃ§'
})

VIPGroupBox:AddButton({
    Text = 'Kahraman Ol',
    Func = function()
        pcall(function()
            local args = { [1] = "SetTeam", [2] = "Heroes" }
            ReplicatedStorage:WaitForChild("RemoteFunction"):InvokeServer(unpack(args))
            Library:Notify("Kahraman oldun!", 3)
        end)
    end,
    Tooltip = 'Kahraman takÄ±mÄ±na geÃ§'
})

local MenuGroup = Tabs['UI AyarlarÄ±']:AddLeftGroupbox('MenÃ¼')
MenuGroup:AddToggle("KeybindMenuOpen", {
    Default = Library.KeybindFrame.Visible,
    Text = "TuÅŸ MenÃ¼sÃ¼ AÃ§",
    Callback = function(value) Library.KeybindFrame.Visible = value end
})
MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "Ã–zel Ä°mleÃ§",
    Default = true,
    Callback = function(Value) Library.ShowCustomCursor = Value end
})
MenuGroup:AddDivider()
MenuGroup:AddLabel("MenÃ¼ TuÅŸu"):AddKeyPicker("MenuKeybind", {
    Default = "RightShift",
    NoUI = true,
    Text = "MenÃ¼ tuÅŸu"
})
MenuGroup:AddButton("Kapat", function() Library:Unload() end)

Library.ToggleKeybind = Options.MenuKeybind
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')
SaveManager:BuildConfigSection(Tabs['UI AyarlarÄ±'])
ThemeManager:ApplyToTab(Tabs['UI AyarlarÄ±'])
SaveManager:LoadAutoloadConfig()

Library:OnUnload(function()
    for player in pairs(ActiveHitboxes) do
        RestoreHitbox(player)
    end
    for player in pairs(ActiveVRHitboxes) do
        RestoreVRHitbox(player)
    end
    if OptimizedConn then OptimizedConn:Disconnect() end
    for _, conns in pairs(Connections) do
        if typeof(conns) == "table" then
            for _, conn in ipairs(conns) do
                conn:Disconnect()
            end
        else
            conns:Disconnect()
        end
    end
    Connections = {}
    FOVCircle:Remove()
    VRFOVCircle:Remove()
    print('KapatÄ±ldÄ±!')
    Library.Unloaded = true
end)

UpdateVIPDropdown()
Library:Notify("Script GÃ¼ncellendi! Silent Aim eklendi, UI TÃ¼rkÃ§e, buglar dÃ¼zeltildi.", 5)
